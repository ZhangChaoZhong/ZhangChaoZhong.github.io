<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="d4_pdYcNwIYae3EhA8wFzZvB6zxWe5KWfSnaliXR-Rc" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangchaozhong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="（1）基础面向过程VS面向对象⭐️对比面向过程，是两种不同的处理问题的角度  面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做 什么  比如：洗衣机洗衣服  面向过程会将任务拆解成一系列的步骤（函数），1、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—– 4、清洗—–&gt;5、烘干  面向对象会拆出人和洗衣机两个对象：  人：打开洗衣机 放衣">
<meta property="og:type" content="article">
<meta property="og:title" content="1.2Java基础">
<meta property="og:url" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="生于九六年晚冬">
<meta property="og:description" content="（1）基础面向过程VS面向对象⭐️对比面向过程，是两种不同的处理问题的角度  面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做 什么  比如：洗衣机洗衣服  面向过程会将任务拆解成一系列的步骤（函数），1、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—– 4、清洗—–&gt;5、烘干  面向对象会拆出人和洗衣机两个对象：  人：打开洗衣机 放衣">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220530095956933.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/da66634efe7a48409f3fc002af881eca.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/86735519.jpg">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210702215318688.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/88729818.jpg">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/34384414.jpg">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220211120633893.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210705103857095.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/7af40ad162d9f2d3e1256ea3d1b8f31b6327cc27.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426104758235.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105203573.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105733852.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210723084524957.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105536011.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105658461.png">
<meta property="article:published_time" content="2021-01-02T14:10:00.000Z">
<meta property="article:modified_time" content="2022-06-12T09:12:50.000Z">
<meta property="article:author" content="ChaoZhong Zhang">
<meta property="article:tag" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220530095956933.png">

<link rel="canonical" href="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>1.2Java基础 | 生于九六年晚冬</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生于九六年晚冬</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangchaozhong.github.io/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="ChaoZhong Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生于九六年晚冬">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          1.2Java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 22:10:00" itemprop="dateCreated datePublished" datetime="2021-01-02T22:10:00+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-12 17:12:50" itemprop="dateModified" datetime="2022-06-12T17:12:50+08:00">2022-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" itemprop="url" rel="index"><span itemprop="name">学习路线</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h2><h3 id="面向过程VS面向对象⭐️"><a href="#面向过程VS面向对象⭐️" class="headerlink" title="面向过程VS面向对象⭐️"></a>面向过程VS面向对象⭐️</h3><p>对比面向过程，是两种不同的处理问题的角度 </p>
<p>面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做 什么 </p>
<p>比如：洗衣机洗衣服 </p>
<p>面向过程会将任务拆解成一系列的步骤（函数），1、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—– 4、清洗—–&gt;5、烘干 </p>
<p>面向对象会拆出人和洗衣机两个对象： </p>
<p>人：打开洗衣机 放衣服 放洗衣粉 </p>
<p>洗衣机：清洗 烘干 </p>
<blockquote>
<p>从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护</p>
</blockquote>
<span id="more"></span>

<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象三大特征</a></h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指<strong>把一个对象的状态信息（也就是属性）隐藏在对象内部</strong>，不允许外部对象直接访问对象的内部信息。</p>
<p>我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p>
<p><strong>好处：</strong></p>
<ol>
<li>良好的封装能够<strong>减少耦合</strong>。</li>
<li><strong>隐藏实现细节</strong>。</li>
</ol>
<p>1）<strong>javabean</strong>的属性私有，提供get，set对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String name; </span><br><span class="line">public void setName(String name)&#123; </span><br><span class="line">	this.name = &quot;tuling_&quot;+name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该name有自己的命名规则，明显不能由外部直接赋值 </p>
<p>2）<strong>orm（ 对象关系映射）框架</strong> </p>
<p>操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E7%BB%A7%E6%89%BF">继承</a></h4><p>继承是<strong>使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义可以增加新的数属性或新的功能，也可以用父类的功能。</p>
<blockquote>
<p>动物（父类）：猫，狗</p>
</blockquote>
<p><strong>好处：</strong></p>
<p>通过使用继承，可以快速地创建新的类，可以<strong>提高代码的重用，程序的可维护性</strong>，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>注意：</strong></p>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的<strong>私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</p>
<p>子类可以用自己的方式实现父类的方法。</p>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<h4 id="多态-⭐️"><a href="#多态-⭐️" class="headerlink" title="多态 ⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%A4%9A%E6%80%81">多态</a> ⭐️</h4><p><strong>同一个行为具有多个不同表现形式的能力</strong></p>
<p><strong>静态的多态性：编译时，重载（不能称为多态），动态多态性：运行时，继承</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li><p>可替换性（打印机：打印彩色，也可以打印黑白）</p>
</li>
<li><p>可扩充性（加新的子类不影响已存在类的多态性、继承性）</p>
</li>
<li><p>接口性（由子类来实现接口）</p>
</li>
</ol>
<p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li><strong>父类引用指向子类对象</strong>：Parent p = new Child();</li>
</ul>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有<strong>继承（类）/实现（接口）</strong>的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li>
<li>多态<strong>不能调用“只在子类存在但在父类不存在”</strong>的方法；</li>
<li>如果子类重写了父类的方法，<strong>真正执行的是子类覆盖的方法</strong>，如果子类没有覆盖父类的方法，执行的是父类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;A and D&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;A and A&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;B and B&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;B and A&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">            A a1 = <span class="keyword">new</span> A();  </span><br><span class="line">            A a2 = <span class="keyword">new</span> B();  </span><br><span class="line">            B b = <span class="keyword">new</span> B();  </span><br><span class="line">            C c = <span class="keyword">new</span> C();  </span><br><span class="line">            D d = <span class="keyword">new</span> D();  </span><br><span class="line">              </span><br><span class="line">            System.out.println(<span class="string">&quot;1--&quot;</span> + a1.show(b));  </span><br><span class="line">            System.out.println(<span class="string">&quot;2--&quot;</span> + a1.show(c));  </span><br><span class="line">            System.out.println(<span class="string">&quot;3--&quot;</span> + a1.show(d));  </span><br><span class="line">            System.out.println(<span class="string">&quot;4--&quot;</span> + a2.show(b));  <span class="comment">//4--B and A .首先a2是A引用，B实例，调用show（B b）方法，此方法在父类A中没有定义，所以B中方法show(B b)不会调用（多态必须父类中已定义该方法），再按优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</span></span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;5--&quot;</span> + a2.show(c));  <span class="comment">//同上</span></span><br><span class="line">            System.out.println(<span class="string">&quot;6--&quot;</span> + a2.show(d));  <span class="comment">//A and D .查找B中没有show(D d)方法，再查A中，有，执行。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;7--&quot;</span> + b.show(b));  </span><br><span class="line">            System.out.println(<span class="string">&quot;8--&quot;</span> + b.show(c));  <span class="comment">//B and B .</span></span><br><span class="line">            System.out.println(<span class="string">&quot;9--&quot;</span> + b.show(d));        </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1--A and A</span></span><br><span class="line"><span class="comment">2--A and A</span></span><br><span class="line"><span class="comment">3--A and D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4--B and A</span></span><br><span class="line"><span class="comment">5--B and A</span></span><br><span class="line"><span class="comment">6--A and D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7--B and B</span></span><br><span class="line"><span class="comment">8--B and B</span></span><br><span class="line"><span class="comment">9--A and D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="python-C-Java有什么区别⭐️"><a href="#python-C-Java有什么区别⭐️" class="headerlink" title="python C++ Java有什么区别⭐️"></a>python C++ Java有什么区别⭐️</h3><p>1.c++、java和python都是面向对象的编程语言，但是c++和java都是强类型静态语言，而python是一种<strong>强类型动态语言</strong></p>
<blockquote>
<p>静态：它的数据类型是在编译其间检查的；动态：运行时检查</p>
</blockquote>
<p>2.垃圾回收机制：c++需要程序员收到回收，而java和python都有自己的垃圾回收机制GC。具体两者又有不同，python的垃圾收集机制主要是用的是引用计数方式，Java还有可达性分析算法。</p>
<p>3.c++和java中<strong>变量</strong>的存储是<strong>真实值</strong>，而python总存储的是<strong>引用</strong>，所以python不用声明类型名称，它的输入均<strong>默认为字符串</strong>。</p>
<p>4.python参数传递是引用传递，Java只有值传递，C++都有</p>
<p>5.c++中用<strong>const来声明常量</strong>，java中使用<strong>final</strong>来声明，python中<strong>没有常量</strong>。</p>
<p>6.C++ ,python支持<strong>多重继承</strong>，Java 的类是<strong>单继承</strong>的；虽然 Java 的类<strong>不可以多继承</strong>，但是接口可以多继承。(类继承推荐使用单继承，这样可以保证编程思路更清晰。)</p>
<p>（1.如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体继承哪一个，会产生歧义。</p>
<p>2.如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。</p>
<p>总结：子类只能有一个亲身父亲，但是一个父类可以有多个孩子。</p>
<p>1.接口里定义的都是静态常量，方法都是抽象方法，没有逻辑实现，具体的方法必须由实现接口的类覆盖实现，只会调用实现类（子类覆盖的方法）的方法，不会产生歧义。</p>
<p>2.接口中的变量都是静态成员常量（public static final），会在编译期就感知到错误。</p>
<p>总结：接口可以继承<strong>多个父接口的相同的方法，不同的属性</strong>，不能继承多个父接口中相同的属性。）</p>
<p>7.C ++,python同时支持<strong>方法重载和操作符重载</strong>，但是 Java 只支持<strong>方法重载</strong>（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p>
<p>8.Java，python有<strong>反射机制</strong>，允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。C++没有提供这样的特性。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？⭐️"><a href="#为什么说-Java-语言“编译与解释并存”？⭐️" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-java-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%EF%BC%9F">为什么说 Java 语言“编译与解释并存”？</a>⭐️</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。</p>
<p><strong>编译型语言</strong>：通过编译器将<strong>全部代码编译</strong>成机器指令码，然后再让计算机运行。（不需要重新编译）</p>
<p><strong>解释型语言</strong>：通过解释器<strong>一行一行的将代码翻译</strong>成机器指令码，然后再让计算机运行。（每执行一次都要翻译一次）</p>
<p><strong>Java半编译语言</strong>：是将源文件（.java文件）先<strong>编译</strong>成<strong>字节码文件</strong>（.class文件），然后再在Java虚拟机（JVM）中<strong>解释</strong>执行。</p>
<blockquote>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后<strong>通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的<strong>热点代码</strong>)，所以后面<strong>引进了JIT 编译器（能够捕获程序中的热点代码）</strong>。当 JIT 编译器<strong>完成第一次编译后，其会将字节码对应的机器码保存下来</strong>，下次可以直接使用。</p>
</blockquote>
<h3 id="JVM-vs-JDK-vs-JRE⭐️"><a href="#JVM-vs-JDK-vs-JRE⭐️" class="headerlink" title="JVM vs JDK vs JRE⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=jvm-vs-jdk-vs-jre">JVM vs JDK vs JRE⭐️</a></h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220530095956933.png" alt="image-20220530095956933"></p>
<p><strong>JDK</strong> 是 Java Development Kit 缩写，它是<strong>功能齐全的 Java SDK</strong>。它<strong>拥有 JRE 所拥有的一切</strong>，还有<strong>编译器（javac）</strong>和工具（如 javadoc 和 jdb）。<strong>它能够创建和编译程序</strong>。</p>
<p><strong>JRE</strong> 是 <strong>Java 运行时环境</strong>。它是<strong>运行已编译</strong> <strong>Java 程序所需的所有内容的集合</strong>，包括 Java 虚拟机<strong>（JVM），Java 类库</strong>，java 命令和其他的一些基础构件。但是，<strong>它不能用于创建新程序</strong>。</p>
<p>应用程序服务器会将 JSP 转换为  Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<p><strong>JVM</strong></p>
<p>Java 虚拟机（JVM）是<strong>运行 Java 字节码的虚拟机</strong>。<strong>不同系统的JVM是不同的</strong>（Windows，Linux，macOS），<strong>目的是使用相同的字节码，它们都会给出相同的结果。</strong></p>
<h3 id="什么是字节码-采用字节码的好处是什么-⭐️"><a href="#什么是字节码-采用字节码的好处是什么-⭐️" class="headerlink" title="什么是字节码?采用字节码的好处是什么?⭐️"></a><strong>什么是字节码?采用字节码的好处是什么?⭐️</strong></h3><blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。<br>Java 语言通过字节码的方式，在一定程度上<strong>解决了</strong>传统解释型语言<strong>执行效率低的问题</strong>，同时又保留了解释型语言<strong>可移植</strong>的特点。所以   Java   程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，   Java程序无须重新编译便可在多种不同的计算机上运行。  </p>
</blockquote>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=oracle-jdk-%E5%92%8C-openjdk-%E7%9A%84%E5%AF%B9%E6%AF%94">Oracle JDK 和 OpenJDK 的对比</a></h3><ul>
<li><p>OpenJDK 是一个参考模型并且是完全开源的，而 <strong>Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的</strong>；</p>
</li>
<li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。</p>
</li>
</ul>
<h3 id="import-java-和-javax-有什么区别？"><a href="#import-java-和-javax-有什么区别？" class="headerlink" title="import java 和 javax 有什么区别？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">import java 和 javax 有什么区别？</a></h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，<strong>javax 当时只是扩展 API 包来使用</strong>。然而随着时间的推移，javax  逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java  包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<blockquote>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></h2><h3 id="可选参数和固定参数"><a href="#可选参数和固定参数" class="headerlink" title="可选参数和固定参数"></a>可选参数和固定参数</h3><blockquote>
<p>jdk1.5以后支持可选参数,…；固定参数：就是普通的参数</p>
</blockquote>
<p>可选参数：个数从0到无穷；只能有一个；放在参数列表最后；可选参数可以组成方法重载，但可选参数的调用优先级最低。</p>
<p>重载函数调用优先级：一摸一样的 &gt; 基本类型转换的 &gt; 自动拆箱／装箱 &gt; 继承优先父类方法 &gt; 可选参数的方法</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/da66634efe7a48409f3fc002af881eca.png" alt="img"></p>
<h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别?</a></h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符：**’0’<strong>，字符串常量是双引号引起的 0 个或若干个字符：</strong>“0”**</p>
<p><strong>含义</strong> : 字符常量相当于<strong>一个整型值</strong>( ASCII 值),可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong>(该字符串在内存中存放位置)</p>
<p><strong>占内存大小</strong> ： 字符常量<strong>只占 2 个字节</strong>; 字符串常量占<strong>若干个字节</strong> </p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/86735519.jpg" alt="img"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%B3%A8%E9%87%8A">注释</a></h3><p>Java 中的注释有三种：</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释。</li>
</ol>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
</blockquote>
<h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">标识符和关键字的区别是什么？</a></h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种<strong>特殊的标识符就是关键字</strong>。</p>
<h3 id="Java-中有哪些常见的关键字？"><a href="#Java-中有哪些常见的关键字？" class="headerlink" title="Java 中有哪些常见的关键字？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F">Java 中有哪些常见的关键字？</a></h3><p><strong>final</strong>：用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</p>
<p><strong>instanceof</strong>：用来确定对象所属的类</p>
<p><strong>interface</strong>：接口</p>
<p><strong>implements</strong>：指定的接口中所声明的所有方法的实现</p>
<p><strong>native</strong>：指示该方法是用Java以外的语言实现的</p>
<p><strong>strictfp</strong>：用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</p>
<p><strong>super</strong>：表明当前对象的父类型的引用或者父类型的构造方法</p>
<p><strong>synchronized</strong>：表明一段代码需要同步执行</p>
<p><strong>throw</strong>：抛出一个异常</p>
<p><strong>throws</strong>：声明在当前定义的成员方法中所有需要抛出的异常</p>
<p><strong>transient</strong>：声明不用序列化的成员域</p>
<p><strong>volatile</strong>：表明两个或者多个变量必须同步地发生变化；可以被多个线程异步修改的成员变量</p>
<p><strong>abstract</strong></p>
<blockquote>
<p>abstract关键字可以修饰类或方法。</p>
<p>abstract类可以扩展（增加子类），但不能直接实例化。</p>
<p>abstract方法不在声明它的类中实现，但必须在某个子类中重写。</p>
</blockquote>
<h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</a>⭐️</h3><p><strong>Java 泛型</strong>（generics）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是<strong>伪泛型</strong>，这是因为 Java <strong>在编译期间</strong>，所有的<strong>泛型信息都会被擦掉</strong>，这也就是通常所说<strong>类型擦除</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果为</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管ArrayList<String>和ArrayList<Integer>看上去是不同的类型，但是上面的程序会认为它们是相同的类型。ArrayList<String>和ArrayList<Integer>在运行时事实上是相同的类型。这两种类型都<strong>被擦除成它们的“原生”类型，即ArrayList。</strong></Integer></String></Integer></String></p>
<p>问题：怎么知道对象属于哪个类型</p>
<p><strong>instanceof</strong></p>
</blockquote>
<p><strong>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法</strong></p>
<blockquote>
<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>T (type) 表示具体的一个 java 类型</li>
<li>E (element) 代表 Element</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>？ 表示不确定的 java 类型</li>
</ul>
</blockquote>
<p><strong>解决擦除的问题</strong></p>
<ul>
<li><strong>引入类型标签，使用动态的isInstance()代替instanceof</strong></li>
<li><strong>用工厂方法或模版方法创建类型实例</strong></li>
</ul>
<p><strong>真的完全擦除了吗</strong></p>
<blockquote>
<p>并不完全正确，<strong>Singature属性</strong>会为它记录泛型签名信息。Signature属性就是为了弥补擦除法的缺陷而增设的，<strong>Java可以通过反射获得泛型类</strong>型，这部分信息基本能够满足我们日常开发中的大多数场景。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>在Java里面可以<strong>通过反射获取泛型信息</strong>的场景有三个，分别是：</p>
<p>(1)<strong>成员变量</strong>的泛型</p>
<p>(2)<strong>方法参数</strong>的泛型</p>
<p>(3)<strong>方法返回值</strong>的泛型</p>
<blockquote>
<p>注意，通过<strong>对象本身也是没法获取的</strong>。</p>
<p>不能通过发射获取泛型类型信息的场景有二个，分别是：</p>
<p>(1)<strong>类或接口</strong>声明的泛型信息</p>
<p>(2)<strong>局部变量</strong>的泛型信息</p>
</blockquote>
<h3 id="和-equals-的区别⭐️"><a href="#和-equals-的区别⭐️" class="headerlink" title="==和 equals 的区别⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">==和 equals 的区别</a>⭐️</h3><p><strong>==<strong>对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，</strong>其本质比较的都是值</strong>，只是引用类型变量存的值是<strong>对象的地址</strong>。</p>
<p><strong>equals()</strong> 作用不能用于判断基本数据类型的变量，<strong>只能用来判断两个对象是否相等</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<blockquote>
<p>String类重写Object类的equals方法判断两个字符串的内容是否相等</p>
</blockquote>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 equals()方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，<strong>等价于通过“==”比较这两个对象</strong>，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 equals()方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来<strong>比较两个对象中的属性是否相等</strong>；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// String类覆盖了 equals()方法  true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;	<span class="comment">//先比较长度</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;					<span class="comment">//从头开始遍历，比较</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>Object的equals方法容易抛空指针异常</strong>，应使用常量或确定有值的对象来调用 equals。 不过更推荐使用 <code>java.util.Objects#equals</code>(<strong>JDK7 引入的工具类</strong>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">str.equals(<span class="string">&quot;SnailClimb&quot;</span>)；	<span class="comment">//空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;SnailClimb&quot;</span>.equals(str);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="hashCode-与-equals-⭐️"><a href="#hashCode-与-equals-⭐️" class="headerlink" title="hashCode()与 equals() ⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=hashcode%E4%B8%8E-equals">hashCode()与 equals()</a> ⭐️</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>
<p><strong>1)hashCode()介绍:</strong></p>
<p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>，也称为散列码；散列表存储的是键值对(key-value)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode：是一个<span class="keyword">native</span>方法，返回的是对象的内存地址.能根据“键”快速的检索出对应的“值”</span><br></pre></td></tr></table></figure>

<p><strong>2)为什么要有 hashCode？</strong></p>
<p>我们以<strong>“<code>HashSet</code> 如何检查重复”为例子</strong>来说明为什么要有 hashCode。</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相等的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是<strong>如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同（比较属性值）</strong>。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就<strong>会重新散列到其他位置</strong>。这样我们就<strong>大大减少了 equals 的次数</strong>。</p>
<p><strong>3)为什么重写 equals 时必须重写 hashCode 方法？</strong></p>
<blockquote>
<p>hashCode()<code>的默认行为是对堆上的对象产生独特值。</code>如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<blockquote>
<p>我们希望只要id是一样的，就认定为是一个对象，集合中同一个对象只存一个</p>
</blockquote>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>因为 <strong><code>hashCode()</code> 会产生哈希冲突，产生相同的hashcode值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Product product = (Product) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id, product.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product1 = <span class="keyword">new</span> Product(<span class="number">1</span>, <span class="string">&quot;包子&quot;</span>);</span><br><span class="line">        Product product2 = <span class="keyword">new</span> Product(<span class="number">1</span>, <span class="string">&quot;馒头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Product&gt; products = <span class="keyword">new</span> HashSet&lt;Product&gt;();</span><br><span class="line">        products.add(product1);</span><br><span class="line">        products.add(product2);</span><br><span class="line">        <span class="comment">// 使用equals判断是否相等</span></span><br><span class="line">        System.out.println(product1.equals(product2));</span><br><span class="line">        <span class="comment">// 查看HashSet中元素个数</span></span><br><span class="line">        System.out.println(products.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【测试结果】</span><br><span class="line"><span class="keyword">true</span> <span class="comment">// 可以看到判断是相等的</span></span><br><span class="line"><span class="number">2</span> 	 <span class="comment">// 但是还是存到了HashSet中，不重写hashcode，会将同个对象判定为2个对象⚠️</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写hashCode,再次测试</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(id);</span><br><span class="line">&#125;</span><br><span class="line">【测试结果】</span><br><span class="line"><span class="keyword">true</span> <span class="comment">// 可以看到判断是相等的</span></span><br><span class="line"><span class="number">1</span> <span class="comment">// 并且第二个值并没有存到HashSet中</span></span><br></pre></td></tr></table></figure>



<h3 id="Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F">Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</a></h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210702215318688.png" alt="image-20210702215318688"></p>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p><strong>（2）包装类型 VS 基本类型</strong>⭐️</p>
<p>1）包装类型不赋值就是 <code>Null</code> ，而<strong>基本类型有默认</strong>值且不是 <code>Null</code>。</p>
<p>2）基本数据类型直接存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于<strong>堆</strong>中。</p>
<h3 id="自动装箱与拆箱⭐️"><a href="#自动装箱与拆箱⭐️" class="headerlink" title="自动装箱与拆箱⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1">自动装箱与拆箱</a>⭐️</h3><ul>
<li><strong>装箱</strong>：将基本类型<strong>用它们对应的引用类型</strong>包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<blockquote>
<p>1）包装类型可以为 null，而基本类型不可以</p>
<p>2）包装类型可用于泛型，而基本类型不可以</p>
<p>3）基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用</p>
<p>当需要进行自动装箱时，如果<strong>数字在 -128 至 127 之间时，会直接使用缓存中的对象</strong>，而不是重新创建一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span> 等价于 Integer i = Integer.valueOf(<span class="number">10</span>)	<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i 等价于 <span class="keyword">int</span> n = i.intValue();									<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h3 id="int和Integer有什么区别？为什么要有包装类？⭐️"><a href="#int和Integer有什么区别？为什么要有包装类？⭐️" class="headerlink" title="int和Integer有什么区别？为什么要有包装类？⭐️"></a>int和Integer有什么区别？为什么要有包装类？⭐️</h3><ul>
<li>数据类型不同：int 是基础数据类型，而 Integer 是包装数据类型；</li>
<li>默认值不同：int 的默认值是 0，而 Integer 的默认值是 null；</li>
<li>内存中存储的方式不同：int 在<strong>栈中直接存储的具体数值</strong>，而 Integer 存储的是<strong>堆中的引用</strong>，当 new 一个 Integer 时实际上是生成一个指针指向此对象；</li>
<li>实例化方式不同：Integer 必须实例化才可以使用，而 int 不需要；</li>
<li>变量的比较方式不同：int 可以使用 == 来对比两个变量是否相等，而 Integer 一定要使用 equals 来比较两个变量是否相等。</li>
</ul>
<p>万物皆对象。在很多情况下，需要以对象的形式操作，比如 hashCode() 获取哈希值，或者 getClass() 获取类等。</p>
<p>Java 中每个基本数据类型都对应了一个包装类，而 int 对应的包装类就是 Integer，包装类的存在解决了基本数据类型无法做到的事情：<strong>泛型类型参数（T，E，K，V，？）、序列化、类型转换、高频区间数据缓存（-128，127）</strong>等问题。</p>
<h3 id="8-种基本类型的包装类和常量池-⭐️"><a href="#8-种基本类型的包装类和常量池-⭐️" class="headerlink" title="8 种基本类型的包装类和常量池 ⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0">8 种基本类型的包装类和常量池</a> ⭐️</h3><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p>
<p><code>Character</code> 创建了数值在[0,127]范围的缓存数据，</p>
<p><code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>⚠️：如果超出对应范围仍然会去创建新的对象。</p>
<blockquote>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
</blockquote>
<p>⚠️：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;										<span class="comment">//常量池中的对象</span></span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);	</span><br><span class="line">System.out.println(i1==i2);					<span class="comment">//比较地址，false</span></span><br><span class="line">System.out.println(i1.equals(i2));	<span class="comment">//true，比较属性值</span></span><br></pre></td></tr></table></figure>

<h4 id="荐使用valueOf-方法，少使用-parseLong-方法"><a href="#荐使用valueOf-方法，少使用-parseLong-方法" class="headerlink" title="荐使用valueOf 方法，少使用 parseLong 方法"></a>荐使用<em>valueOf</em> <em>方法，少使用</em> <em>parseLong</em> <em>方法</em></h4><p>valueOf 方法会从缓存中去 拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84">在一个静态方法内调用一个非静态成员为什么是非法的?</a></h3><p><strong>静态方法是属于类</strong>的，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。<br>而<strong>非静态成员属于实例对象</strong>，只有<strong>在对象实例化之后才存在</strong>，然后通过类的实例对象去访问。<br><strong>在类的非静态成员不存在的时候静态成员就已经存在</strong>了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F">静态方法和实例方法有何不同？</a></h3><p>1.在外部<strong>调用静态方法</strong>时，可以使用**”类名.方法名**”的方式，也可以使用”<strong>对象名.方法名</strong>“的方式。实例方法只能用”<strong>对象名.方法名</strong>“的方式。</p>
<p>2.静态方法在<strong>访问本类的成员</strong>时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法）；实例方法则无此限制。</p>
<h3 id="为什么-Java-中只有值传递？⭐️"><a href="#为什么-Java-中只有值传递？⭐️" class="headerlink" title="为什么 Java 中只有值传递？⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F">为什么 Java 中只有值传递？</a>⭐️</h3><p><strong>按值调用(call by value)</strong> 表示方法接收的是参数的值(<strong>不能修改值对应的变量</strong>)，<strong>按引用调用（call by reference)</strong> 表示方法接收的是实参的实际地址（可以修改值对应的变量）。</p>
<p>实参：方法被调用时传入的实际值。</p>
<p>形参：在定义方法时括号内定义的参数列表即为形参</p>
<p><strong>Java 程序设计语言总是采用按值调用。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）不能修改一个基本数据类型的参数</span><br><span class="line">C++里面的swap(<span class="keyword">int</span> a, <span class="keyword">int</span> b)，Java不行</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">2</span>）改变一个对象参数的状态</span><br><span class="line">swap（arr）</span><br><span class="line">swap(<span class="keyword">int</span>[] array)		对象引用作为参数就可以,arr array 指向同一个数组对象</span><br><span class="line">方法得到的是对象引用的拷贝array</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">3</span>）不能交换<span class="number">2</span>个对象（只交换了拷贝的<span class="number">2</span>个对象）</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>交换之前：</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/88729818.jpg" alt="img"></p>
<p>交换之后：</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/34384414.jpg" alt="img"></p>
<p>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，<strong>这个方法交换的是这两个拷贝</strong></p>
<blockquote>
<p>封装类可以解决这个问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Wrapper over class that is used for swapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWrapper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   Car c;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor</span></span><br><span class="line">   CarWrapper(Car c)   &#123;<span class="keyword">this</span>.c = c;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Class that use Car and swaps objects of Car</span></span><br><span class="line"><span class="comment">// using CarWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This method swaps car objects in wrappers</span></span><br><span class="line">    <span class="comment">// cw1 and cw2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(CarWrapper cw1, </span></span></span><br><span class="line"><span class="params"><span class="function">                            CarWrapper cw2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car temp = cw1.c;</span><br><span class="line">        cw1.c = cw2.c;</span><br><span class="line">        cw2.c = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="number">101</span>, <span class="number">1</span>);</span><br><span class="line">        Car c2 = <span class="keyword">new</span> Car(<span class="number">202</span>, <span class="number">2</span>);</span><br><span class="line">        CarWrapper cw1 = <span class="keyword">new</span> CarWrapper(c1);</span><br><span class="line">        CarWrapper cw2 = <span class="keyword">new</span> CarWrapper(c2);</span><br><span class="line">        swap(cw1, cw2);</span><br><span class="line">        cw1.c.print();</span><br><span class="line">        cw2.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-与super"><a href="#this-与super" class="headerlink" title="this 与super"></a>this 与super</h3><p>this 和 super 都是 Java 中的关键字，都起指代作用，当显示使用它们时，都需要将它们放<strong>在方法的首行</strong>（否则编译器会报错）。 super 是用来访问父类实例属性和方法的。this 是用来访问本类实例属性和方法的，它会先从本类中找，如果本类中找不到则在父类中找。</p>
<p>它们有四点不同：<strong>指代对象、查找访问、本类属性赋值和 synchronized 的使用不同</strong>。<br>super 指代的是父类，是用来访问父类的；而 this 指代的是当前类。</p>
<p>super 只能查找父类，而 this 会先从本类中找，如果找不到则会去父类中找。</p>
<p>this 可以用来为本类的实例属性赋值，而 super 则不能实现此功能。</p>
<p>因为 this 表示当前对象，所以this 可用于 synchronized(this){….} 加锁，而 super 则不能实现此功能。</p>
<h3 id="重载和重写的区别⭐️"><a href="#重载和重写的区别⭐️" class="headerlink" title="重载和重写的区别⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB">重载和重写的区别⭐️</a></h3><p>重载就是<strong>同一个类</strong>中的<strong>多个同名方法</strong>能够根据<strong>输入数据的不同</strong>，做出不同的处理</p>
<p>重写就是当<strong>子类继承自父类的相同方法</strong>，输入数据一样，但要做出有别于父类的处理</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220211120633893.png" alt="image-20220211120633893"></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210705103857095.png" alt="image-20210705103857095"></p>
<blockquote>
<p>方法名称+参数类型+参数个数=<strong>方法签名</strong>，JVM通过这个签名来调用哪个重载方法。</p>
<p><strong>重载为什么不加返回类型？</strong>加了之后，调用重载函数（不会写返回类型），JVM就不能判断调用哪个重载函数</p>
</blockquote>
<blockquote>
<p><strong>不能重写的情况？</strong></p>
<ol>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> <strong>则子类就不能重写该方法</strong>，但是被 static 修饰的方法能够被再次声明。</li>
<li><strong>构造方法无法被重写</strong></li>
</ol>
</blockquote>
<h3 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%B7%B1%E6%8B%B7%E8%B4%9D-vs-%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝 vs 浅拷贝</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝：一个指针指向已存在的内存地址</span><br><span class="line">深拷贝：申请了一个新的内存，指针再指向</span><br></pre></td></tr></table></figure>

<h3 id="成员变量与局部变量的区别有哪些？⭐️"><a href="#成员变量与局部变量的区别有哪些？⭐️" class="headerlink" title="成员变量与局部变量的区别有哪些？⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">成员变量与局部变量的区别有哪些？</a>⭐️</h3><ol>
<li>从<strong>语法</strong>形式上看，<strong>成员变量是属于类</strong>的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，<strong>成员变量和局部变量都能被 <code>final</code> 所修饰</strong>。</li>
<li>从变量在<strong>内存中的存储方式</strong>来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是<strong>属于类</strong>的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</li>
<li>从变量在<strong>内存中的生存时间</strong>上看，静态变量的生命周期取决于类的生命周期；非静态成员变量是对象的一部分，它<strong>随着对象</strong>的创建而存在，而局部变量<strong>随着方法</strong>的调用结束而自动消失。</li>
<li>从变量<strong>是否有默认值</strong>来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而<strong>局部变量则不会自动赋值</strong>。</li>
</ol>
<blockquote>
<p>一个局部变量，如果不赋值，那么这个变量也不会进入到内存中，可以认为不存在。</p>
</blockquote>
<p>类的生命周期</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/7af40ad162d9f2d3e1256ea3d1b8f31b6327cc27.png" alt="img"></p>
<h3 id="内存分区⭐️"><a href="#内存分区⭐️" class="headerlink" title="内存分区⭐️"></a>内存分区⭐️</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈区：存放函数的局部变量，返回值以及形参</span><br><span class="line">堆区：调用malloc函数主动申请，如果不调用free函数就不会自动释放</span><br><span class="line">全局／静态区／数据段：存放静态变量和全局变量的地方</span><br><span class="line">常量区：存放常量的地方</span><br><span class="line">代码区：存放代码的地方</span><br></pre></td></tr></table></figure>

<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></h3><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存</strong>中），对象引用：指向对象实例（<strong>对象引用存放在栈</strong>内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。    </p>
<h3 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">对象的相等与指向他们的引用相等,两者有什么不同?</a></h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88">一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</a></h3><p>构造方法主要作用是<strong>完成对类对象的初始化工作</strong>。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会<strong>有默认的不带参数的构造方法</strong>。如果我们<strong>自己添加了</strong>类的构造方法（无论是否有参），Java就不<strong>会再添加默认的无参数的构造方法</strong>了。</p>
<h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法有哪些特点？是否可被 override?</a></h3><p><strong>特点：</strong></p>
<ol>
<li><strong>名字与类名相同</strong>。</li>
<li><strong>没有返回值，但不能用 void 声明构造函数</strong>。</li>
<li>生成类的对象时<strong>自动执行</strong>，无需调用。</li>
</ol>
<p><strong>构造方法不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p>
<blockquote>
<p>构造方法不可以被重写,因为重写发生在父类和子类之间,要求方法名称相同,而构造方法的名称是和类名相同的,而子类类名不会和父类类名相同,所以不可以被重写。</p>
</blockquote>
<h3 id="final、finally、finalize有什么区别？⭐️"><a href="#final、finally、finalize有什么区别？⭐️" class="headerlink" title="final、finally、finalize有什么区别？⭐️"></a>final、finally、finalize有什么区别？⭐️</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>java中的关键字</p>
<ul>
<li>修饰类：表示类不可被继承 </li>
<li>修饰方法：表示方法不可重写，但是可以重载 </li>
<li><strong>修饰变量</strong>：表示变量一旦被赋值就不可以更改它的值。  </li>
<li>修饰参数：此参数在整个方法不允许被修改</li>
</ul>
<h5 id="赋值时机"><a href="#赋值时机" class="headerlink" title="赋值时机"></a>赋值时机</h5><p>（1）<strong>类(静态)变量</strong>VS成员变量 </p>
<p>如果final修饰的是<strong>类变量</strong>，<strong>只能在静态初始化块</strong>中指定初始值或者构造函数里面指定初始值，等号赋值。(final static修饰：则有2种：等号赋值，静态初始化块赋值)</p>
<p>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</p>
<p>（2）修饰局部变量 </p>
<p>系统不会为局部变量进行初始化，<strong>局部变量必须由程序员显示初始化</strong>。不规定赋值时机，只需要在使用前赋值就可以。</p>
<p>（3）修饰基本类型数据和引用类型数据 </p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； </li>
<li>如果是引用类型的变量，则在对其初始化之后便<strong>不能再让其指向另一个对象</strong>。<strong>但是引用的值是可变的</strong>。 </li>
</ul>
<h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>用final修饰不一定具有不变性。</p>
<ul>
<li><p>修饰基本类型，具有不变性</p>
</li>
<li><p>修改对象，里面的属性也都被final修饰不一定具有不变性</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426104758235.png" alt="image-20220426104758235"></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105203573.png" alt="image-20220426105203573"></p>
</li>
<li><p>在方法里面新建的局部变量，是线程安全的，栈封闭，每个线程都有独自的栈</p>
</li>
</ul>
<p><strong>面试</strong></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105733852.png" alt="image-20220426105733852"></p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>是一种一定被执行的机制。无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。比如：try  finally或者try catch finally来进行关闭JDBC连接，保证释放锁等动作。</p>
<p><strong>在以下 3 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><strong>Object类的基础方法</strong>，设计目的是保证在被垃圾收集前完成特定资源的回收，JDK9之后弃用了。</p>
<ul>
<li>finalize不一定被执行，不稳定</li>
</ul>
<blockquote>
<p>当对象变成(GC Roots)<strong>不可达时</strong>，GC会判断该对象是否覆盖了finalize方法，<strong>若未覆盖，则直接将其回收</strong>。否则，若对象未执行过finalize方法，将其<strong>放入F-Queue队列</strong>，由一<strong>低优先级线程</strong>执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会<strong>再次判断该对象是否可达</strong>，若不可达，则进行回收，否则，对象“复活” 。</p>
</blockquote>
<ul>
<li>阻碍JVM垃圾回收，性能差。GC本就因为内存不足引起，finalize调用又很慢，不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多就会容易Full GC，Full GC释放速度如果仍跟不上创建新对象的速度，就会OOM。</li>
</ul>
<h3 id="Static⭐️"><a href="#Static⭐️" class="headerlink" title="Static⭐️"></a>Static⭐️</h3><h4 id="修饰的对象"><a href="#修饰的对象" class="headerlink" title="修饰的对象"></a><em>修饰的对象</em></h4><p>static 只能修饰类变量、代码块和方法。补充：还有 class。</p>
<blockquote>
<p>修饰类变量、代码块和方法都与类无关</p>
<ul>
<li>我们<strong>不需要初始化类</strong>就可直接使用静态变量；</li>
<li>静态变量<strong>只会初始化一次</strong>，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。</li>
</ul>
</blockquote>
<p><strong>(1)当static</strong> <strong>修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且 无需初始化类，直接使用 <strong>类名.static</strong> <strong>变量</strong> 这种形式访问即可。</p>
<p>需要注意线程安全的问题了，因为当多个线程同时对共享变量进行读 写时，很有可能会出现并发问题。</p>
<p>两个解决办法：</p>
<ul>
<li>把线程不安全的 ArrayList 换成线程安全的 CopyOnWriteArrayList；</li>
<li>每次访问时，手动加锁。</li>
</ul>
<p>(2)<strong>当</strong> <strong>static</strong> <strong>修饰方法时</strong>，代表<strong>该方法和当前类是无关的</strong>，任意类都可以直接访问（如果权限是 public 的话）。 </p>
<p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们 常用的 <strong>util 类里面的各种方法，我们比较喜欢用 static 修饰方法</strong>，好处就是调用特别方便。</p>
<blockquote>
<p><strong>static 方法内部的变量在执行时是没有线程安全问题的</strong>。方法执行时，数据运行在栈里面，栈的 数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p>
</blockquote>
<p>(3)<strong>当</strong> <strong>static</strong> <strong>修饰方法块时</strong>，我们叫做静态块，静态块常常用于<strong>在类启动之前，初始化一些值</strong>，比如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">	list.add(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 <strong>static 的变量需要写在静态块的前面</strong>，不然编译也会报错。</p>
</blockquote>
<p>(4)static关键字还可以修饰类，<strong>普通类是不允许声明为静态的，只有内部类才可以</strong>。</p>
<p>被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。</p>
<h4 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a><em>初始化时机</em></h4><p>\1. 父类的静态变量和静态块比子类优先初始化； </p>
<p>\2. 静态变量和静态块<strong>比类构造器优先初始化</strong>。 </p>
<ol start="3">
<li>被 static 修饰的<strong>方法</strong>，在类初始化的时候并不会初始化，<strong>只有当自己被调用时，才会被执行。</strong></li>
</ol>
<h3 id="volatile⭐️"><a href="#volatile⭐️" class="headerlink" title="volatile⭐️"></a>volatile⭐️</h3><p>  <strong>概念</strong>：volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。 </p>
<p><strong>前提：</strong>在多核 CPU 下，为了提高效率，<strong>线程在拿值时，是 直接和 CPU 缓存打交道的</strong>，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 时，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以<strong>线程读的操作永远都是拿CPU 缓存的值</strong>。<br>这时候会产生一个问题，<strong>CPU 缓存中的值和内存中的值可能并不是时刻都同步</strong>，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值， <strong>CPU 缓存的值还是旧的</strong>，导致计算会出现问题。</p>
<p><strong>原理</strong>：这时候有个机制，就是<strong>内存会主动通知 CPU 缓存</strong>。当前共享变量的值已经失效了，你需要重新来拉取一份，<strong>CPU 缓存就会重新从内存中拿取一份最新的值</strong>。</p>
<p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存 中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而<strong>保证线程从 CPU 缓存中拿取出来的值是最新的</strong>。</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a><strong>transient</strong></h3><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时， 就会忽略该变量。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>default 关键字一般会用在接口的方法上，意思是<strong>对于该接口，子类是无需强制实现的</strong>，但接口自己 必须有默认实现。</p>
<h3 id="工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️"><a href="#工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️" class="headerlink" title="工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️"></a><em>工作中有没有遇到特别好用的工具类，如何写好一个工具类</em>⭐️</h3><p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空，相等判断等等工具类，好的工具类肯定很好用，比如说<strong>使用 static final 关键字对方法进行修饰， 工具类构造器必须是私有</strong>等等手段来写好工具类。</p>
<blockquote>
<p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。</p>
<p>Collections 是为了方便使用集合而产生的工具类，求集合中最大、小值，</p>
<p>线程安全集合synchronized；不可变集合unmodifiable （Map）</p>
<p>Objects 提供了equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的</p>
<p>Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值， requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常</p>
</blockquote>
<h3 id="为什么局部内部类和匿名内部类只能访问局部final变量？⭐️"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量？⭐️" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量？⭐️"></a><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong>⭐️</h3><p>首先需要知道的一点是: <strong>内部类和外部类是处于同一个级别的</strong>，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 </p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有 没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解 决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期。</p>
<p><strong>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修 改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</strong> </p>
<p><strong>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量</strong>，就保证了内部类的成员变量 和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p>
<h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-⭐️"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-⭐️" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?⭐️</a></h3><p><strong>（1）可不可变</strong></p>
<p><code>String</code> 类被 final 修饰；并且String中使用 <strong>final</strong> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<strong>String 对象是不可变的</strong>。</p>
<p>String每次操作都会返回一个新的String</p>
<blockquote>
<p>str =  str.replace(“l”,”dd”);//正确</p>
<p>str.replace(“l”,”dd”);//错误</p>
</blockquote>
<blockquote>
<p>在 <strong>Java 9</strong> 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用<strong>字符数组保存字符串</strong><code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以<strong>这两种对象都是可变的</strong>。</p>
<p><strong>（2）线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量</strong>，线程安全。</p>
<p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了<strong>同步锁</strong>，所以是<strong>线程安全</strong>的。</p>
<p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<blockquote>
<p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p>
</blockquote>
<p><strong>（3）性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会<strong>生成一个新的</strong> <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> <strong>对象本身进行操作</strong>，而不是生成新的对象。</p>
<p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 <strong>10%~15% 左右的性能提升</strong>，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作<strong>少量的数据</strong>: 适用 <code>String</code></li>
<li><strong>单线程</strong>操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li><strong>多线程</strong>操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="抽象类VS接口⭐️"><a href="#抽象类VS接口⭐️" class="headerlink" title="抽象类VS接口⭐️"></a>抽象类VS接口⭐️</h3><p>（1）区别：</p>
<ul>
<li>抽象类的设计目的，是<strong>代码复用</strong>（当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时。）；接口的设计目的，是<strong>对类的行为进行约束</strong>（对行为的抽象，它只约束了行为的有无，不对如何实现行为进行限制。）。</li>
<li>抽象类可以存在普通<strong>成员函数</strong>，而接口中只能存在<strong>public abstract</strong> 方法。 </li>
<li>抽象类中的<strong>成员变量</strong>可以是各种类型的，而接口中的成员变量只能是<strong>public static final</strong>类型的。 </li>
<li>抽象类只能继承一个（extend），<strong>接口可以实现多个（implement）</strong>。</li>
</ul>
<p>（2）场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">eat和sleep都是狗本身所应该具有的一种行为,而钻火圈这种行为则是后天训练出来的,只能算是对狗类的一种附加或者延伸, 两者不应该在同一个范畴内</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义接口，含有钻火圈方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> interface <span class="title">DrillFireCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drillFireCircle</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">//定义抽象类狗类:包括eat() 、sleep() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//一个SpecialDog即可继承Dog类并且实现DrillFireCircle()接口</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SpecialDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">drillFireCircle</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drillFireCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（3）总结：</p>
<blockquote>
<p>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>概念：反射之所以被称为<strong>框架的灵魂</strong>，主要是因为它赋予了我们在<strong>运行时</strong>分析类以及执行类中方法的能力。通过反射你可以<strong>获取和调用任意一个类的所有属性和方法</strong>。</p>
<h4 id="反射机制优缺点-⭐️"><a href="#反射机制优缺点-⭐️" class="headerlink" title="反射机制优缺点 ⭐️"></a>反射机制优缺点 ⭐️</h4><p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了<strong>安全问题</strong>。比如可以<strong>无视泛型参数的安全检查</strong>（泛型参数的安全检查发生在编译时）。另外，反射的<strong>性能也要稍差点</strong>，不过，对于框架来说实际是影响不大的。</p>
<p><strong>为什么比较慢？</strong></p>
<p>反射它其实是一个<strong>解释过程</strong>，在运行期时，需要告诉JVM想要什么；（所有被调用/创建的都必须<strong>被发现</strong>；<strong>参数</strong>需要通过装箱/拆箱、打包到数组中<strong>进行修饰</strong>。）</p>
<p><strong>使用反射的一般步骤</strong></p>
<p>获取Class对象，然后调用对象的属性及方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取Class对象有三种方式：</span><br><span class="line">第一种是对象调用getClass方法。</span><br><span class="line">第二种方式：知道类名，直接用类名.class方式获取。此种方式性能最优。</span><br><span class="line">第三种方式：知道类的全限定名，使用Class对象的静态方法forName方法获取</span><br></pre></td></tr></table></figure>

<h4 id="反射的应用场景-⭐️"><a href="#反射的应用场景-⭐️" class="headerlink" title="反射的应用场景 ⭐️"></a>反射的应用场景 ⭐️</h4><p>例子：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33613491/article/details/106711513">https://blog.csdn.net/qq_33613491/article/details/106711513</a></p>
<p>1）<strong>动态代理</strong>的实现也依赖反射。</p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了<strong>反射类</strong> <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);	<span class="comment">//调用指定方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于<strong>反射分析类</strong>，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h3 id="Java中的异常体系⭐️"><a href="#Java中的异常体系⭐️" class="headerlink" title="Java中的异常体系⭐️"></a>Java中的异常体系⭐️</h3><p>Java中的所有异常都来自顶级父类Throwable。Throwable下有两个子类Exception和Error。</p>
<ul>
<li><p>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。比如：OOM，</p>
</li>
<li><p>Exception：不会导致程序停止。</p>
</li>
</ul>
<p>1）非受检查异常：RunTimeException<strong>运行时</strong>异常（比如：空指针，数组越界）</p>
<p>2）受检查异常：CheckedException发生在<strong>编译</strong>过程（如：IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需处理，否则程序就不能编译通过，它有两种处理方法，通过 try catch 捕获或者通过 throw 把异常抛出去。）。</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210723084524957.png" alt="image-20210723084524957"></p>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=try-catch-finally">try-catch-finally</a></h3><ul>
<li><p><strong>try块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
</li>
<li><p><strong>catch块：</strong> 用于处理 try 捕获到的异常。</p>
</li>
<li><p><strong>finally 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。并且 finally 语句的返回值将会覆盖原始的返回值。</p>
</li>
<li><p>```java<br>public class Test {</p>
<pre><code>public static int f(int value) &#123;
    try &#123;
        return value * value;
    &#125; finally &#123;
        if (value == 2) &#123;
            return 0;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>//如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**在以下 3 种特殊情况下，finally 块不会被执行：**</span><br><span class="line"></span><br><span class="line">1. 在 `try` 或 `finally`块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行</span><br><span class="line">2. 程序所在的线程死亡。</span><br><span class="line">3. 关闭 CPU。</span><br><span class="line"></span><br><span class="line">### 使用 `try-with-resources` 来代替`try-catch-finally`⭐️</span><br><span class="line"></span><br><span class="line">1. **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象</span><br><span class="line">2. **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</span><br><span class="line"></span><br><span class="line">&gt; 面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        //读取文本文件的内容</span><br><span class="line">        Scanner scanner = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            scanner = new Scanner(new File(&quot;D://read.txt&quot;));</span><br><span class="line">            while (scanner.hasNext()) &#123;</span><br><span class="line">                System.out.println(scanner.nextLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (scanner != null) &#123;</span><br><span class="line">                scanner.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素排序Comparable和Comparator有什么区别？⭐️"><a href="#元素排序Comparable和Comparator有什么区别？⭐️" class="headerlink" title="元素排序Comparable和Comparator有什么区别？⭐️"></a>元素排序Comparable和Comparator有什么区别？⭐️</h3><ul>
<li><p>（1）Comparable有比较的能力，Comparator比较器，都是顶级接口</p>
</li>
<li><p>（2）实现Comparable接口，并重写compareTo方法，支持Collections.sort和Arrays.sort。compareTo方法<strong>接收要对比的对象</strong>，将当前对象和要对比对象进行比较，返回int值，对比对象-当前对象，降序，（默认升序）</p>
</li>
</ul>
<p>Comparator的排序方法是compare</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105536011.png" alt="image-20220424105536011"></p>
<p>​    Comparator匿名类</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105658461.png" alt="image-20220424105658461"></p>
<ul>
<li>（3）使用场景不同，<strong>使用Comparable必须修改原有类</strong>，在排序的那个类实现Comparable接口，并重写compareTo方法。<strong>Comparator可以实现原有类的解耦</strong>，可以把它看成是一个对外提供排序的接口。</li>
</ul>
<h3 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">Object 类的常见方法总结</a></h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以子类不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=io-%E6%B5%81">I/O 流</a></h2><h3 id="什么是序列化-什么是反序列化-⭐️"><a href="#什么是序列化-什么是反序列化-⭐️" class="headerlink" title="什么是序列化?什么是反序列化? ⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">什么是序列化?什么是反序列化?</a> ⭐️</h3><p><strong>场景：</strong>如果我们需要<strong>持久化 Java 对象</strong>比如将 <strong>Java 对象保存在文件</strong>中，或者在<strong>网络传输 Java 对象</strong>，这些场景都需要用到序列化。</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象<strong>转换成二进制字节流</strong>的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">Java 序列化中如果有些字段不想进行序列化，怎么办？</a></h3><p>对于不想进行序列化的变量，使用<code>transient</code>关键字修饰。`</p>
<p><code>transient</code> <strong>只能修饰变量</strong>，不能修饰类和方法。</p>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">获取用键盘输入常用的两种方法</a></h3><p>方法 1：通过 <code>Scanner</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 <code>BufferedReader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D">Java 中 IO 流分为几种?</a></h3><ul>
<li>按照<strong>流的流向分</strong>，可以分为输入流和输出流；</li>
<li>按照<strong>操作单元</strong>划分，可以划分为字节流和字符流；</li>
<li>按照<strong>流的角色</strong>划分为节点流和处理流。</li>
</ul>
<p>Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="既然有了字节流-为什么还要有字符流-⭐️"><a href="#既然有了字节流-为什么还要有字符流-⭐️" class="headerlink" title="既然有了字节流,为什么还要有字符流? ⭐️"></a><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81">既然有了字节流,为什么还要有字符流?</a> ⭐️</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：<strong>字符流是由 Java 虚拟机将字节流转换得到的，问题就出在这个过程还算是非常耗时</strong>，并且，如果我们不知道编码类型就<strong>很容易出现乱码</strong>问题。所以， <strong>I/O 流就干脆提供了一个直接操作字符的接口</strong>，方便我们平时对<strong>字符进行流操作</strong>。如果<strong>音频文件、图片</strong>等媒体文件用字节流比较好，<strong>如果涉及到字符</strong>的话使用字符流比较好。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p><strong>1.2.1. BigDecimal 类的用处</strong>⭐️</p>
<p><strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断（由于equals会比较值）。</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); <span class="comment">//1-b</span></span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><strong>1.2.2. BigDecimal 的大小比较</strong></p>
<p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p>
<p> <strong>1.2.3. BigDecimal 保留几位小数</strong></p>
<p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则</p>
<p><strong>1.2.4. BigDecimal 的使用注意事项</strong></p>
<p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<blockquote>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
</blockquote>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>1)以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line">public enum PizzaStatus &#123;</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY, </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2)使用 == 比较枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pizza.PizzaStatus pizza = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));<span class="comment">//空指针异常</span></span><br><span class="line">System.out.println(pizza == Pizza.PizzaStatus.DELIVERED);<span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="comment">// 编译正常</span></span><br><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      <span class="comment">// 编译失败，类型不匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>3)在 switch 语句中使用枚举类型</strong></p>
<p><strong>4)枚举类型的属性,方法和构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaStatus</span> </span>&#123;</span><br><span class="line">       ORDERED (<span class="number">5</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       READY (<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       DELIVERED (<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> timeToDelivery;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimeToDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       PizzaStatus (<span class="keyword">int</span> timeToDelivery) &#123;</span><br><span class="line">           <span class="keyword">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>5）EnumSet，EnumMap</strong></p>
<ul>
<li><code>EnumSet</code> 是一种专门为枚举类型所设计的 <code>Set</code> 类型。</li>
</ul>
<p>EnumSet在内部<strong>以位向量的形式存储</strong>，这种存储形式<strong>非常紧凑、高效</strong>，</p>
<p>在很多场景中的枚举常量集合操作（如：<strong>取子集、增加、删除</strong>、<code>containsAll</code>和<code>removeAll</code>批操作）使用<code>EnumSet</code>非常合适；如果需要迭代所有可能的常量则使用<code>Enum.values()</code>。</p>
<ul>
<li><code>EnumMap</code>是一个专门化的映射实现，用于<strong>将枚举常量用作键</strong>。</li>
</ul>
<p><strong>6）枚举实现单例模式，策略模式</strong></p>
<ul>
<li>单例模式</li>
</ul>
<blockquote>
<p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
</blockquote>
<p>下面的代码段显示了如何使用枚举实现单例模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaDeliverySystemConfiguration</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class="line">        <span class="comment">// Initialization configuration which involves</span></span><br><span class="line">        <span class="comment">// overriding defaults like delivery strategy</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PizzaDeliverySystemConfiguration <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> PizzaDeliveryStrategy <span class="title">getDeliveryStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deliveryStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();</span><br></pre></td></tr></table></figure>

<ul>
<li>策略模式</li>
</ul>
<p>策略模式由<strong>不同类实现同一个接口</strong>来实现的。这也就意味着添加新策略意味着<strong>添加新的实现类</strong>。</p>
<p>使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaDeliveryStrategy</span> </span>&#123;</span><br><span class="line">    EXPRESS &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pizza will be delivered in express mode&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pizza will be delivered in normal mode&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 <code>Pizza </code>增加下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDeliverable()) &#123;</span><br><span class="line">        PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">          .deliver(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.setStatus(PizzaStatus.DELIVERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza pz = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    pz.deliver();</span><br><span class="line">    assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关枚举类型的JSON序列化/反序列化</strong></p>
<p>（包括自定义）的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.baeldung.com/jackson-serialize-enums">Jackson-将枚举序列化为JSON对象。</a></p>
<p>我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>
<p>下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PinType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>, <span class="string">&quot;注册使用&quot;</span>),</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>, <span class="string">&quot;忘记密码使用&quot;</span>),</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>, <span class="string">&quot;更新手机号码使用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="keyword">int</span> code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>, message=<span class="string">&#x27;忘记密码使用&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，在实际使用起来就会非常灵活方便！</p>
<h2 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h2><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div>
            
              <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

            
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/02/1.5.2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SSM%EF%BC%8CSpringBoot/" rel="prev" title="1.5.2开发框架SSM，SpringBoot">
      <i class="fa fa-chevron-left"></i> 1.5.2开发框架SSM，SpringBoot
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="next" title="1.4数据结构">
      1.4数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80"><span class="nav-text">（1）基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8BVS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%AD%90%EF%B8%8F"><span class="nav-text">面向过程VS面向对象⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-text">面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81-%E2%AD%90%EF%B8%8F"><span class="nav-text">多态 ⭐️</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-C-Java%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E2%AD%90%EF%B8%8F"><span class="nav-text">python C++ Java有什么区别⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">为什么说 Java 语言“编译与解释并存”？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-vs-JDK-vs-JRE%E2%AD%90%EF%B8%8F"><span class="nav-text">JVM vs JDK vs JRE⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88-%E2%AD%90%EF%B8%8F"><span class="nav-text">什么是字节码?采用字节码的好处是什么?⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle-JDK-%E5%92%8C-OpenJDK-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">Oracle JDK 和 OpenJDK 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">import java 和 javax 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E5%9B%BA%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="nav-text">可选参数和固定参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">字符型常量和字符串常量的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">标识符和关键字的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="nav-text">Java 中有哪些常见的关键字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90%EF%B8%8F"><span class="nav-text">&#x3D;&#x3D;和 equals 的区别⭐️</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-%E4%B8%8E-equals-%E2%AD%90%EF%B8%8F"><span class="nav-text">hashCode()与 equals() ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F"><span class="nav-text">Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E2%AD%90%EF%B8%8F"><span class="nav-text">自动装箱与拆箱⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">int和Integer有什么区别？为什么要有包装类？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0-%E2%AD%90%EF%B8%8F"><span class="nav-text">8 种基本类型的包装类和常量池 ⭐️</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8D%90%E4%BD%BF%E7%94%A8valueOf-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%91%E4%BD%BF%E7%94%A8-parseLong-%E6%96%B9%E6%B3%95"><span class="nav-text">荐使用valueOf 方法，少使用 parseLong 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84"><span class="nav-text">在一个静态方法内调用一个非静态成员为什么是非法的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">静态方法和实例方法有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">为什么 Java 中只有值传递？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-%E4%B8%8Esuper"><span class="nav-text">this 与super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90%EF%B8%8F"><span class="nav-text">重载和重写的区别⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-vs-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">深拷贝 vs 浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">成员变量与局部变量的区别有哪些？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E2%AD%90%EF%B8%8F"><span class="nav-text">内存分区⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-text">创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89-%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-text">对象的相等与指向他们的引用相等,两者有什么不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text">一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="nav-text">构造方法有哪些特点？是否可被 override?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">final、finally、finalize有什么区别？⭐️</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E6%97%B6%E6%9C%BA"><span class="nav-text">赋值时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9-1"><span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally"><span class="nav-text">finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize"><span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Static%E2%AD%90%EF%B8%8F"><span class="nav-text">Static⭐️</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">修饰的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="nav-text">初始化时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E2%AD%90%EF%B8%8F"><span class="nav-text">volatile⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transient"><span class="nav-text">transient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default"><span class="nav-text">default</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E7%89%B9%E5%88%AB%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%AD%90%EF%B8%8F"><span class="nav-text">工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8final%E5%8F%98%E9%87%8F%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">为什么局部内部类和匿名内部类只能访问局部final变量？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84-%E2%AD%90%EF%B8%8F"><span class="nav-text">String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBVS%E6%8E%A5%E5%8F%A3%E2%AD%90%EF%B8%8F"><span class="nav-text">抽象类VS接口⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9-%E2%AD%90%EF%B8%8F"><span class="nav-text">反射机制优缺点 ⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E2%AD%90%EF%B8%8F"><span class="nav-text">反射的应用场景 ⭐️</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E2%AD%90%EF%B8%8F"><span class="nav-text">Java中的异常体系⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch-finally"><span class="nav-text">try-catch-finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8FComparable%E5%92%8CComparator%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%EF%B8%8F"><span class="nav-text">元素排序Comparable和Comparator有什么区别？⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">Object 类的常见方法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E6%B5%81"><span class="nav-text">I&#x2F;O 流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E2%AD%90%EF%B8%8F"><span class="nav-text">什么是序列化?什么是反序列化? ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">Java 序列化中如果有些字段不想进行序列化，怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">获取用键盘输入常用的两种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="nav-text">Java 中 IO 流分为几种?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81-%E2%AD%90%EF%B8%8F"><span class="nav-text">既然有了字节流,为什么还要有字符流? ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal"><span class="nav-text">BigDecimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">JDK1.8新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stream"><span class="nav-text">stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda"><span class="nav-text">lambda</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChaoZhong Zhang"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">ChaoZhong Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/ZhangXiaoyu_sy" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;ZhangXiaoyu_sy" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangChaoZhong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangChaoZhong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zczindex@gmail.com" title="E-Mail → zczindex@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChaoZhong Zhang
  </span>
  <span class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LitCJHzcYDrw3V694F5ykefU-9Nh9j0Va',
      appKey     : 'xrhUoMdaVndszRNhqsBy6jni',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
