<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="d4_pdYcNwIYae3EhA8wFzZvB6zxWe5KWfSnaliXR-Rc" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangchaozhong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.二叉树 二叉树：">
<meta property="og:type" content="article">
<meta property="og:title" content="1.二叉树">
<meta property="og:url" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="生于九六年晚冬">
<meta property="og:description" content="1.二叉树 二叉树：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/116_sample.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20220428104511190.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/26e9f631ec22f42f50099cf4fd9a55510ad0e7b0a4a836c772b6850591ddb737-image.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/fde85797d0aa3cee9f8a84f39e820aed269f6c45b8eaf4d0672489c08f98090b-4.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20211119191906437.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20220227172451571.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306160658602.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306161232086.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095058804.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095241593.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20210306175110221.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306175018888.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306194848625.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095648125.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210722224510100.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20211125195244554.png">
<meta property="article:published_time" content="2021-01-02T14:00:00.000Z">
<meta property="article:modified_time" content="2022-04-29T13:48:32.000Z">
<meta property="article:author" content="ChaoZhong Zhang">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/116_sample.png">

<link rel="canonical" href="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>1.二叉树 | 生于九六年晚冬</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生于九六年晚冬</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangchaozhong.github.io/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="ChaoZhong Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生于九六年晚冬">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          1.二叉树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 22:00:00" itemprop="dateCreated datePublished" datetime="2021-01-02T22:00:00+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 21:48:32" itemprop="dateModified" datetime="2022-04-29T21:48:32+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h1><blockquote>
<p>二叉树：</p>
</blockquote>
<span id="more"></span>

<h3 id="遍历系列"><a href="#遍历系列" class="headerlink" title="遍历系列"></a>遍历系列</h3><h4 id="二叉树遍历：迭代统一版本"><a href="#二叉树遍历：迭代统一版本" class="headerlink" title="二叉树遍历：迭代统一版本"></a>二叉树遍历：迭代统一版本</h4><p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈：访问逆序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 添加根节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 根节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br></pre></td></tr></table></figure>

<p><strong>前序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<p><strong>后序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;left);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;right);   </span><br></pre></td></tr></table></figure>

<h4 id="144-二叉树的前序遍历-🀄️"><a href="#144-二叉树的前序遍历-🀄️" class="headerlink" title="144. 二叉树的前序遍历 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*前，中，后，主要看根在哪。</span></span><br><span class="line"><span class="comment">根左右</span></span><br><span class="line"><span class="comment">⚠️：当然有些可能是根右左</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左根右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LRN</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LRN</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BST用中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root) &#123;</span><br><span class="line">         <span class="built_in">LNR</span>(root,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= res.<span class="built_in">size</span>() ? <span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="102-二叉树的层序遍历-🀄️"><a href="#102-二叉树的层序遍历-🀄️" class="headerlink" title="102. 二叉树的层序遍历 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树的层序遍历--广度优先搜索</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    首先根元素入队</span></span><br><span class="line"><span class="comment">    当队列不为空的时候</span></span><br><span class="line"><span class="comment">        求当前队列的长度 si</span></span><br><span class="line"><span class="comment">        依次从队列中取 si个元素进行拓展，然后进入下一次迭代</span></span><br><span class="line"><span class="comment">它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 si个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si 个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;        <span class="comment">//存储每一层的结点值</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;	<span class="comment">//注意🈳️树</span></span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">//树的队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);       <span class="comment">//根先进入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;  <span class="comment">//不为空</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());   <span class="comment">//先放入一个vector&lt;int&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();            <span class="comment">//取出队头，并删除队头</span></span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);        <span class="comment">//根结点值存入vector&lt;int&gt;</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)  q.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左结点不空,进入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)  q.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右结点不空,进入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根结点的插入顺序不一样。</span></span><br><span class="line"><span class="comment">    如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。</span></span><br><span class="line"><span class="comment">    如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">//从左到右</span></span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(flag) res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);               <span class="comment">//插入到最后面</span></span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">back</span>().<span class="built_in">insert</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),node-&gt;val);   <span class="comment">//插入到最前面</span></span><br><span class="line">                   </span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：返回其节点值自底向上的层序遍历</span></span><br><span class="line"><span class="comment">思路：只需要将每次层序遍历的结点的容器插入到结果最前面就可以了，这样后面遍历的就变成前面的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">       queue&lt;TreeNode *&gt; q;</span><br><span class="line">       q.<span class="built_in">push</span>(root);</span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">           <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">           vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">               <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">               t.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">           &#125;</span><br><span class="line">           res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),t);   <span class="comment">//插入到最前面</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树的深度遍历和先根遍历基本上是一样的,只是先根遍历有左右之分,而深度遍历没有左右之分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路1:层序遍历，记录下每层的最后一个元素。</span></span><br><span class="line"><span class="comment">思路2:先序遍历(这里是根右左)，记录下每层的第一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == s - <span class="number">1</span>) res.<span class="built_in">push_back</span>(node-&gt;val);    <span class="comment">//⚠️保存最后一个</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/116_sample.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度O(n)</span></span><br><span class="line"><span class="comment">思路：用层序遍历，这样我们可以在遍历每一层的时候修改这一层节点的 next 指针，这样就可以把每一层都组织成链表。</span></span><br><span class="line"><span class="comment">（初始状态下，所有 next 指针都被设置为 NULL。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;      <span class="comment">//层序遍历</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; s - <span class="number">1</span>) node-&gt;next = q.<span class="built_in">front</span>();  <span class="comment">//⚠️前面的指向后面，front()查询队头元素</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II-⭐️"><a href="#117-填充每个节点的下一个右侧节点指针-II-⭐️" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II ⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> ⭐️</h4><p><img src="/Users/zcz/Desktop/images/image-20220428104511190.png" alt="image-20220428104511190"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：使用已建立的 next 指针，cur 指针利用 next 不停的遍历当前层。</span></span><br><span class="line"><span class="comment">	1）如果 cur 的左右孩子不为 null 就将它接到 tail 后边，然后更新tail。</span></span><br><span class="line"><span class="comment">	2）当 cur 为 null 的时候，再利用 dummy 指针得到下一层的开始节点。</span></span><br><span class="line"><span class="comment">	遍历完每一层。就要将dummy-&gt;next赋值给cur</span></span><br><span class="line"><span class="comment">dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            Node* tail = dummy;  <span class="comment">//赋值给tail</span></span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) &#123;tail-&gt;next = cur-&gt;left;tail = tail-&gt;next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) &#123;tail-&gt;next = cur-&gt;right;tail= tail-&gt;next;&#125;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同103</span><br></pre></td></tr></table></figure>



<h3 id="BST-中序遍历"><a href="#BST-中序遍历" class="headerlink" title="BST+中序遍历"></a>BST+中序遍历</h3><h4 id="98-验证二叉搜索树-⭐️"><a href="#98-验证二叉搜索树-⭐️" class="headerlink" title="98. 验证二叉搜索树 ⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉搜索树</span></span><br><span class="line"><span class="comment">1.左子树上所有结点的值均&lt;它的根结点的值。</span></span><br><span class="line"><span class="comment">2.右子树上所有结点的值均&gt;它的根结点的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">先序遍历</span></span><br><span class="line"><span class="comment">遍历时，不仅左结点小于根结点，根结点大于右结点。而是要整个左子树&lt;根&lt;右子树。此时需要保存子树的上界和下界。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。</span></span><br><span class="line"><span class="comment">同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> low,<span class="keyword">long</span> <span class="keyword">long</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">//本身空或者遍历完</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断根结点值(是否越界)，再遍历左子树，右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,low,root-&gt;val) &amp;&amp; <span class="built_in">check</span>(root-&gt;right,root-&gt;val,high); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root,LONG_MIN,LONG_MAX);<span class="comment">//要long long(32,64都是8字节) </span></span><br><span class="line">      																			 <span class="comment">//或者long(32位 4字节，64位8子节)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="99-恢复二叉搜索树-⭐️难"><a href="#99-恢复二叉搜索树-⭐️难" class="headerlink" title="99. 恢复二叉搜索树 ⭐️难"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a> ⭐️难</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/26e9f631ec22f42f50099cf4fd9a55510ad0e7b0a4a836c772b6850591ddb737-image.png" alt="image.png"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/fde85797d0aa3cee9f8a84f39e820aed269f6c45b8eaf4d0672489c08f98090b-4.png" alt="4.jpg"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20211119191906437.png" alt="image-20211119191906437"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3种解法：</span></span><br><span class="line"><span class="comment">1.先弄个vector容器。 再摘下“树”上的数据（中序遍历）。 然后vector排序。 再把vector容器里的数据挂在“树上”（中序遍历）。 </span></span><br><span class="line"><span class="comment">时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">2.只用比较前后访问的节点值，prev 保存上一个访问的节点，当前访问的是 root 节点。</span></span><br><span class="line"><span class="comment">每访问一个节点，如果prev.val&gt;=root.val，就找到了一对“错误对”。</span></span><br><span class="line"><span class="comment">检查一下它是第一对错误对，还是第二对错误对。</span></span><br><span class="line"><span class="comment">遍历结束，就确定了待交换的两个错误点，进行交换。</span></span><br><span class="line"><span class="comment">时间复杂度O(N)，N是节点个数</span></span><br><span class="line"><span class="comment">空间复杂度O(H)，递归栈的深度</span></span><br><span class="line"><span class="comment">3. Morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，Morris遍历可以将非递归遍历中的空间复杂度降为O(1)</span></span><br><span class="line"><span class="comment">Morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      TreeNode* err1=<span class="literal">nullptr</span>;</span><br><span class="line">      TreeNode* err2=<span class="literal">nullptr</span>;</span><br><span class="line">      TreeNode* prev=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);	</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">LNR</span>(root-&gt;left);</span><br><span class="line">          <span class="comment">// 记录第一个错误点</span></span><br><span class="line">          <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 == <span class="literal">nullptr</span>) err1 = prev;</span><br><span class="line">          <span class="comment">// 第一个错误点已确定,记录第二个错误点</span></span><br><span class="line">          <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 != <span class="literal">nullptr</span>) err2 = root;</span><br><span class="line">          prev = root;    <span class="comment">//更新prev</span></span><br><span class="line">          <span class="built_in">LNR</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LNR</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(err1-&gt;val,err2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *x = <span class="literal">nullptr</span>, *y = <span class="literal">nullptr</span>, *pred = <span class="literal">nullptr</span>, *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// (1)predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// (2)让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    predecessor-&gt;right = root; </span><br><span class="line">                    root = root-&gt;left;          <span class="comment">//访问左孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (3)说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//记录错误结点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                        x = root;</span><br><span class="line">                        <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                            y = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pred = root; <span class="comment">//更新pred</span></span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>; <span class="comment">//置为空</span></span><br><span class="line">                    root = root-&gt;right;           <span class="comment">//访问右孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录错误结点</span></span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                    x = root;</span><br><span class="line">                    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        y = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pred = root;<span class="comment">//更新pred</span></span><br><span class="line">                root = root-&gt;right; <span class="comment">//直接访问右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val, y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思路：中序遍历完就是一个递增的序列，取出第k个元素就是第k小的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历(⚠️这里是右根左，由于是递归)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RNL</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RNL</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉树的下一个结点-⭐️"><a href="#8-二叉树的下一个结点-⭐️" class="headerlink" title="8.二叉树的下一个结点 ⭐️"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">8.二叉树的下一个结点</a> ⭐️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前驱节点：当前节点左子树的最右节点</span></span><br><span class="line"><span class="comment">后继节点：当前节点右子树的最左节点</span></span><br><span class="line"><span class="comment">（最左节点是中序遍历（左根右）的第一个节点。）</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）当前节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</span></span><br><span class="line"><span class="comment">2）否则，向上找第一个左指针指向的树包含该节点的祖先节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode right = pNode.right;	<span class="comment">//1）右子树</span></span><br><span class="line">            <span class="keyword">while</span>(right.left != <span class="keyword">null</span>)					<span class="comment">//最左节点</span></span><br><span class="line">                right = right.left;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123; <span class="comment">//2）⚠️找出其父结点</span></span><br><span class="line">                TreeLinkNode root = pNode.next;<span class="comment">//pNode是root的子结点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == pNode)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                pNode  = pNode.next;<span class="comment">//继续向上找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="285-二叉搜索树的后续结点⭐️"><a href="#285-二叉搜索树的后续结点⭐️" class="headerlink" title="285.二叉搜索树的后续结点⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/inorder-successor-in-bst/">285.二叉搜索树的后续结点</a>⭐️</h4><p>给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。</p>
<p>结点 p 的后继是值<strong>比 p.val 大</strong>的结点中<strong>键值最小</strong>的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果p比当前节点小，说明在左子树，res=root；否则去右子树搜索。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val) &#123;	<span class="comment">//root 右子树的最左</span></span><br><span class="line">                res = root;	<span class="comment">//root 键值最小，最左边⚠️</span></span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;			<span class="comment">//root 左子树的最右</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="272-最接近的二叉搜索树值2"><a href="#272-最接近的二叉搜索树值2" class="headerlink" title="272.最接近的二叉搜索树值2"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/">272.最接近的二叉搜索树值2</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-36-二叉搜索树与双向链表⭐️"><a href="#剑指-Offer-36-二叉搜索树与双向链表⭐️" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a>⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">题意：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span></span><br><span class="line"><span class="comment">排序的双向链表=&gt;中序遍历：</span></span><br><span class="line"><span class="comment">思路：中序遍历</span></span><br><span class="line"><span class="comment">1）递归左子树</span></span><br><span class="line"><span class="comment">2）cur.left = pre ，也构建 pre.right = cur </span></span><br><span class="line"><span class="comment">3）更新pre</span></span><br><span class="line"><span class="comment">4）head指向当前节点cur</span></span><br><span class="line"><span class="comment">5）递归右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *pre, *head; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = pre; </span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) </span><br><span class="line">            pre-&gt;right = root;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;	<span class="comment">//循环双向链表</span></span><br><span class="line">        pre-&gt;right = head; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T,S:O(n^2) 根左右</span></span><br><span class="line"><span class="comment">思路：先序遍历，发现叶子结点就加入结果集中；没有就继续递归左右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode* root,string path,vector&lt;string&gt; &amp;res)</span></span>&#123; <span class="comment">//⚠️string类不加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">//叶子结点，加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//不是叶子结点，递归左右子树</span></span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;left,path,res);</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;right,path,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">getPath</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270.最接近的二叉搜索树值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">270.最接近的二叉搜索树值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="255-验证前序遍历序列二叉搜索树"><a href="#255-验证前序遍历序列二叉搜索树" class="headerlink" title="255.验证前序遍历序列二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/">255.验证前序遍历序列二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序遍历将二叉树取下来，再遍历一遍变成链表</span></span><br><span class="line"><span class="comment">⚠️：前一个节点的左孩子为空，当前结点赋值给前一个节点的右孩子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">int</span> s =res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s;i++)&#123;</span><br><span class="line">            TreeNode* prev = res[i<span class="number">-1</span>],*cur = res[i];</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;   <span class="comment">//前驱结点为空</span></span><br><span class="line">            prev-&gt;right = cur;      <span class="comment">//前驱结点的右结点为当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode* root,vector&lt;TreeNode*&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156.上下翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-upside-down/">156.上下翻转二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4><h4 id="297-二叉树的序列化与反序列化-💣"><a href="#297-二叉树的序列化与反序列化-💣" class="headerlink" title="297. 二叉树的序列化与反序列化 💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a> 💣</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*序列化：二叉树转换为&quot;&#123;1,2,3,#,#,6,7&#125;&quot;；</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">反序列化：&quot;&#123;1,2,3,#,#,6,7&#125;&quot;转换为二叉树</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）取出空格的下标</span></span><br><span class="line"><span class="comment">2）取出deserializeStr空格前的字符串（当前节点），没有空格则是最后一个节点</span></span><br><span class="line"><span class="comment">3）更新deserializeStr（空格后的字符串）</span></span><br><span class="line"><span class="comment">4）创建根节点</span></span><br><span class="line"><span class="comment">5）递归创建左右子树</span></span><br><span class="line"><span class="comment">6）返回根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string deserializeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot; &quot;</span>+<span class="built_in">serialize</span>(root-&gt;left)+<span class="string">&quot; &quot;</span>+<span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">my_deserialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deserializeStr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> index = deserializeStr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        string node =  index == <span class="number">-1</span> ? deserializeStr:deserializeStr.<span class="built_in">substr</span>(<span class="number">0</span>,index);<span class="comment">//空格前的字符串,不包括index</span></span><br><span class="line">        deserializeStr = index == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span>:deserializeStr.<span class="built_in">substr</span>(index+<span class="number">1</span>);<span class="comment">//空格后的字符串，更新deserializeStr</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">atoi</span>(node.<span class="built_in">c_str</span>());</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        cur-&gt;left = <span class="built_in">my_deserialize</span>();</span><br><span class="line">        cur-&gt;right = <span class="built_in">my_deserialize</span>();</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        deserializeStr = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">my_deserialize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列💣"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列💣" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>💣</h4><p><img src="/Users/zcz/Desktop/images/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png" alt="Picture10.png"></p>
<p><img src="/Users/zcz/Desktop/images/image-20220227172451571.png" alt="image-20220227172451571"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历倒序==先序遍历的镜像， 左右根</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调栈 存储值递增</span></span><br><span class="line"><span class="comment">倒序遍历序列</span></span><br><span class="line"><span class="comment">1）左子树大于root，直接false</span></span><br><span class="line"><span class="comment">2）保证左子树&lt;右子树，更新root</span></span><br><span class="line"><span class="comment">3）将当前数据进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;		<span class="comment">//先赋值最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//倒序</span></span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="keyword">false</span>;	<span class="comment">//保证左子树&lt;root</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;postorder[i] &lt; stack.peek()  ) <span class="comment">//保证 左子树 &lt; 右子树</span></span><br><span class="line">                root = stack.pop();	<span class="comment">//更新root</span></span><br><span class="line">            stack.add(postorder[i]);<span class="comment">//单调递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="计算个数，通过界定-1-n-求解"><a href="#计算个数，通过界定-1-n-求解" class="headerlink" title="计算个数，通过界定(1,n)求解"></a>计算个数，通过界定(1,n)求解</h3><h4 id="95-不同的二叉搜索树-II-⭐️"><a href="#95-不同的二叉搜索树-II-⭐️" class="headerlink" title="95. 不同的二叉搜索树 II ⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">如果我们枚举根节点的值为 i，</span></span><br><span class="line"><span class="comment">那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]</span></span><br><span class="line"><span class="comment">再枚举左，右子树，挂到根结点上，将根结点加入到结果集中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st &gt; ed) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;<span class="comment">//&#123;nullptr&#125; 长度为1，&#123;&#125;长度为0</span></span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=st;i &lt;= ed; i++)&#123;</span><br><span class="line">            <span class="comment">//获得所有可行的左子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; lTrees = <span class="built_in">generateTrees</span>(st,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//获得所有可行的右子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rTrees = <span class="built_in">generateTrees</span>(i+<span class="number">1</span>,ed);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; l:lTrees)&#123;    <span class="comment">//枚举左，右子树，挂到根结点上</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; r:rTrees)&#123;</span><br><span class="line">                    TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);  <span class="comment">//根结点</span></span><br><span class="line">                    allTrees.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    cur-&gt;left = l;</span><br><span class="line">                    cur-&gt;right = r;         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="先左右后自己"><a href="#先左右后自己" class="headerlink" title="先左右后自己"></a>先左右后自己</h3><h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306160658602.png" alt="image-20210306160658602"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306161232086.png" alt="image-20210306161232086"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</span></span><br><span class="line"><span class="comment">卡特兰数G(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:,</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += <span class="built_in">numTrees</span>(i - <span class="number">1</span>) * <span class="built_in">numTrees</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和-🀄️⭐️"><a href="#124-二叉树中的最大路径和-🀄️⭐️" class="headerlink" title="124. 二叉树中的最大路径和 🀄️⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 🀄️⭐️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095058804.png" alt="image-20210308095058804"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">题意：给你一个二叉树的根节点 root ，返回其最大路径和</span></span><br><span class="line"><span class="comment">思路：考虑一个二叉树单元：有3种情况：a+b+c,a+b,a+c</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  b   c</span></span><br><span class="line"><span class="comment">递归左右子树，更新3种情况的最大和，返回较大值a+max(b,+c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;left),<span class="number">0</span>); <span class="comment">//子问题:取max，如果结点负数就取0</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;right),<span class="number">0</span>);<span class="comment">//子问题</span></span><br><span class="line">        res = <span class="built_in">max</span>(res,l + r + root-&gt;val);	<span class="comment">//额外：人字形答案</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l,r);	<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果root等于q或者p，或者NULL，直接返回root</span></span><br><span class="line"><span class="comment">递归左子树</span></span><br><span class="line"><span class="comment">递归右子树</span></span><br><span class="line"><span class="comment">左结点，右结点都不为空，返回root（最终答案）</span></span><br><span class="line"><span class="comment">返回 左结点或者右结点，哪个不空返回哪个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span> &amp;&amp; r != <span class="literal">NULL</span>) <span class="keyword">return</span> root;	<span class="comment">//左右子树不空</span></span><br><span class="line">        <span class="keyword">return</span> l!=<span class="literal">NULL</span>?l:r;	<span class="comment">//哪个不空，返回哪个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="250-统计同值子树"><a href="#250-统计同值子树" class="headerlink" title="250.统计同值子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-univalue-subtrees/">250.统计同值子树</a></h4><p>给定一个二叉树，统计该二叉树数值相同的子树个数。</p>
<p>同值子树是指该子树的所有节点都拥有相同的数值。</p>
<p>示例：</p>
<p>输入: root = [5,1,5,5,5,null,5]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   5</span><br><span class="line"> / \   \</span><br><span class="line">5   5   5</span><br></pre></td></tr></table></figure>

<p>输出: 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="333-最大BST子树"><a href="#333-最大BST子树" class="headerlink" title="333.最大BST子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-bst-subtree/">333.最大BST子树</a></h4><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="先自己后左右"><a href="#先自己后左右" class="headerlink" title="先自己后左右"></a>先自己后左右</h3><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.如果两个二叉树都为空，则两个二叉树相同。</span></span><br><span class="line"><span class="comment">2.如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，</span></span><br><span class="line"><span class="comment">4.若不相同则两个二叉树一定不同，若相同，</span></span><br><span class="line"><span class="comment">  再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</span></span><br><span class="line"><span class="comment">  这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;      <span class="comment">//都为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//1个为空，1个不空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p-&gt;val != q-&gt;val)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//值不相等</span></span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);&#125; <span class="comment">//值相等，递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h4 id="剑指-Offer-55-I-二叉树的深度-同上"><a href="#剑指-Offer-55-I-二叉树的深度-同上" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度 同上"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a> 同上</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095241593.png" alt="image-20210308095241593"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">思路：如果为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+max（左子树的深度，右子树的深度）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));	<span class="comment">//根结点+左右子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的结点数"><a href="#获取二叉树的结点数" class="headerlink" title="获取二叉树的结点数"></a>获取二叉树的结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAllNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">getAllNode</span>(root-&gt;left)+<span class="built_in">getAllNode</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的叶子结点数"><a href="#获取二叉树的叶子结点数" class="headerlink" title="获取二叉树的叶子结点数"></a>获取二叉树的叶子结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果根结点为空，直接返回0</span></span><br><span class="line"><span class="comment">如果左结点和右结点同时为空，直接返回1</span></span><br><span class="line"><span class="comment">返回 递归左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leafCount</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">leafCount</span>(root-&gt;left)+<span class="built_in">leafCount</span>(root-&gt;right);<span class="comment">//不包含根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="某结点是否在二叉树中"><a href="#某结点是否在二叉树中" class="headerlink" title="某结点是否在二叉树中"></a>某结点是否在二叉树中</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isExist</span><span class="params">(TreeNode* root,TreeNode* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val == p-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//根</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isExist</span>(root-&gt;left,p)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//左</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isExist</span>(root-&gt;right,p);			<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><h4 id="105-从前序与中序遍历序列构造二叉树-🀄️"><a href="#105-从前序与中序遍历序列构造二叉树-🀄️" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210306175110221.png" alt="image-20210306175110221"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306175018888.png" alt="image-20210306175018888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序的第一个就是根结点，取出来；</span></span><br><span class="line"><span class="comment">再查找根结点在中序中的位置；</span></span><br><span class="line"><span class="comment">然后递归寻找前序和中序的左区间，右区间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;    <span class="comment">//超出范围</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preL];           <span class="comment">//先序遍历的第一个是根，取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];              <span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);  <span class="comment">//new根结点</span></span><br><span class="line">        <span class="comment">//前序，中序的左区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(preorder,preL+<span class="number">1</span>,pIndex-inL+preL,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//前序，中序的右区间</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(preorder,pIndex-inL+preL+<span class="number">1</span>,preR,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = preorder.<span class="built_in">size</span>();   <span class="comment">//前序结点数</span></span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();     <span class="comment">//中序结点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; inLen; i++) map.<span class="built_in">insert</span>(&#123;inorder[i],i&#125;);   <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(preorder,<span class="number">0</span>,preLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306194848625.png" alt="image-20210306194848625"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同105相同的思路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> postL,<span class="keyword">int</span> postR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postL &gt; postR || inL &gt;inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postR];	<span class="comment">//取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];	<span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">      	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);	<span class="comment">//new根结点</span></span><br><span class="line">				<span class="comment">//前序，后序的左区间  以及 //前序，后序的右区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(postorder,postL,postL+pIndex-inL<span class="number">-1</span>,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(postorder,postL+pIndex-inL,postR<span class="number">-1</span>,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();		<span class="comment">//后序结点数</span></span><br><span class="line">        <span class="keyword">int</span> postLen = postorder.<span class="built_in">size</span>();		<span class="comment">//前序结点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++) map[inorder[i]]=i;; <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(postorder,<span class="number">0</span>,postLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h4><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：同109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(nums,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="109-有序链表转换二叉搜索树-🀄️"><a href="#109-有序链表转换二叉搜索树-🀄️" class="headerlink" title="109. 有序链表转换二叉搜索树 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将有序数组转换为二叉搜索树,并且高度平衡</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">构造出的二叉搜索树的中序遍历结果就是链表本身，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。</span></span><br><span class="line"><span class="comment">	中位数节点对应的编号为 mid=left+(right-left)/2+1；</span></span><br><span class="line"><span class="comment">	左右子树对应的编号范围分别为 [left,mid−1] 和 [mid+1,right]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组下标0,1,2,3,4 区别 </span></span><br><span class="line"><span class="comment">(r+l+1)/2			(1)	2 1 0 4 3	区间右边优先</span></span><br><span class="line"><span class="comment">l+(r-l)/2			(2)	2 0 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">while</span>(head)&#123;head = head-&gt;next;len++;&#125;</span><br><span class="line">        	<span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode*  <span class="title">buildTree</span><span class="params">(ListNode* &amp;head,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//⚠️记得head加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (r+l)&gt;&gt;<span class="number">1</span>;                    <span class="comment">//⚠️中间结点为根结点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();        <span class="comment">//根结点</span></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(head,l,mid<span class="number">-1</span>);   <span class="comment">//递归左子树</span></span><br><span class="line">        root-&gt;val = head-&gt;val;                  <span class="comment">//⚠️中序必须这里赋值给根结点</span></span><br><span class="line">        head = head-&gt;next;                      <span class="comment">//⚠️注意更新head</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(head,mid+<span class="number">1</span>,r);  <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">getLength</span>(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//获取左右子树的高度，如果abs(right-left) &gt; 1，则不是平衡树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l= <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>) res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">找出2个原始状态：为空直接返回0；左右结点为空，返回1；</span></span><br><span class="line"><span class="comment">再递归左子树，右子树的最小深度，取较小的+1就是答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right),res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(H) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4><h4 id="剑指-Offer-34-二叉树中和为某一值的路径💣"><a href="#剑指-Offer-34-二叉树中和为某一值的路径💣" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径💣</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减去root.val，递归左右子树</span></span><br><span class="line"><span class="comment">/*T,S:O(N)</span></span><br><span class="line"><span class="comment">思路：1）根左右遍历；选择当前值，更新目标值</span></span><br><span class="line"><span class="comment">2）路径记录（判断是否符合，符合就加入结果集）</span></span><br><span class="line"><span class="comment">3）递归左右子树</span></span><br><span class="line"><span class="comment">4）撤销选择（回溯）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum,vector&lt;<span class="keyword">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum,path);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum,path);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum,vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="437-路径总和-III🀄️"><a href="#437-路径总和-III🀄️" class="headerlink" title="437. 路径总和 III🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="comment">2.前缀和：T,S:O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">路径数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetSum == root-&gt;val) res++;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum);    <span class="comment">//先递归根结点到叶子结点的路径；再递归子树的路径</span></span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1110-删点成林-🀄️"><a href="#1110-删点成林-🀄️" class="headerlink" title="1110. 删点成林 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(n) S:O(H+N)</span></span><br><span class="line"><span class="comment">思路：先序遍历：如果 node 是root 而且没有被删除，则加入答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; to_delete_set;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : to_delete) <span class="comment">//1.存入set</span></span><br><span class="line">            to_delete_set.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="built_in">helper</span>(root, result, to_delete_set, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, vector&lt;TreeNode*&gt;&amp; result, set&lt;<span class="keyword">int</span>&gt;&amp; to_delete_set, <span class="keyword">bool</span> is_root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> deleted = to_delete_set.<span class="built_in">count</span>(node-&gt;val);    <span class="comment">//2.判断是否删除</span></span><br><span class="line">        <span class="keyword">if</span> (is_root &amp;&amp; !deleted) result.<span class="built_in">push_back</span>(node);    <span class="comment">//是根结点且不删除</span></span><br><span class="line">        node-&gt;left = <span class="built_in">helper</span>(node-&gt;left, result, to_delete_set, deleted);</span><br><span class="line">        node-&gt;right =  <span class="built_in">helper</span>(node-&gt;right, result, to_delete_set, deleted);</span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="literal">NULL</span> : node;  <span class="comment">//3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="129-求根到叶子节点数字之和-🀄️⭐️"><a href="#129-求根到叶子节点数字之和-🀄️⭐️" class="headerlink" title="129. 求根到叶子节点数字之和 🀄️⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a> 🀄️⭐️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095648125.png" alt="image-20210308095648125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*从上到下:先序遍历</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_sum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;<span class="comment">//base case 根结点</span></span><br><span class="line">        num = root-&gt;val+num*<span class="number">10</span>;     </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) res += num; <span class="comment">//base case 叶结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">get_sum</span>(root-&gt;left,num);     <span class="comment">//子问题</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">get_sum</span>(root-&gt;right,num);   <span class="comment">//子问题</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">get_sum</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(log⁡2n) S:O(1)</span></span><br><span class="line"><span class="comment">思路：二分查找 + 位运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><blockquote>
<p>Q： 为何需要暂存 root的左子节点？<br>A： 在递归右子节点 “root.left=mirrorTree(root.right);” 执行完毕后， root.left的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T，S：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210722224510100.png" alt="image-20210722224510100"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="298-二叉树最长连续序列🀄️⭐️"><a href="#298-二叉树最长连续序列🀄️⭐️" class="headerlink" title="298.二叉树最长连续序列🀄️⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence/">298.二叉树最长连续序列</a>🀄️⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历：自顶向下：T,S:O(n)</span></span><br><span class="line"><span class="comment">//先递归根结点length =(parent != null &amp;&amp; p.val == parent.val + 1)? length + 1 : 1;再递归左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root, null, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode p, TreeNode parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == null) <span class="keyword">return</span> length;</span><br><span class="line">    length = (parent != null &amp;&amp; p.val == parent.val + <span class="number">1</span>) ? length + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(length, Math.<span class="built_in">max</span>(<span class="built_in">dfs</span>(p.left, p, length),</span><br><span class="line">                                     <span class="built_in">dfs</span>(p.right, p, length)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="366-寻找二叉树的叶子结点🀄️"><a href="#366-寻找二叉树的叶子结点🀄️" class="headerlink" title="366.寻找二叉树的叶子结点🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">366.寻找二叉树的叶子结点</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">//思路：后序遍历，深度从底向上算,叶子结点的深度为0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//depth从0开始</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//返回-1,从0开始</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= res.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findLeaves</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(s*t) S:O(max&#123;s,t&#125;)  树的深度s，t</span></span><br><span class="line"><span class="comment">//思路：转化为检查根结点，左右子树是否相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(!root &amp;&amp; !subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;left,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：先序遍历：res+=左子树的左叶子结点的val</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">NLR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* l = <span class="built_in">NLR</span>(root-&gt;left);</span><br><span class="line">        TreeNode* r = <span class="built_in">NLR</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; l-&gt;left == <span class="literal">nullptr</span> &amp;&amp; l-&gt;right ==<span class="literal">nullptr</span>) res+=l-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">NLR</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">层次遍历：每次保存第一个值 res=cur</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="538-把二叉搜索树转换为累加树-https-leetcode-cn-com-problems-find-bottom-left-tree-value"><a href="#538-把二叉搜索树转换为累加树-https-leetcode-cn-com-problems-find-bottom-left-tree-value" class="headerlink" title="538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a>)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*思路：反序中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">RNL</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RNL</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：中序遍历，pre，res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;res,<span class="keyword">int</span> &amp;pre)</span></span>&#123;<span class="comment">//⚠️引用</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res,pre);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="number">-1</span>)&#123;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,root-&gt;val-pre);</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX,pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res,pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="897-递增顺序查找树-🀄️"><a href="#897-递增顺序查找树-🀄️" class="headerlink" title="897. 递增顺序查找树 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*中序遍历：dummyNode，中间改变指向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *resNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;left);</span><br><span class="line">        resNode-&gt;right = node;</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        resNode = node;     <span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">increasingBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        TreeNode *dummyNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        resNode = dummyNode;    <span class="comment">//dummyNode暂存头指针</span></span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="653-两数之和-IV-输入-BST🀄️"><a href="#653-两数之和-IV-输入-BST🀄️" class="headerlink" title="653. 两数之和 IV - 输入 BST🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈希表 set.count(target-root-&gt;val)</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; my_set;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(TreeNode* root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(my_set.<span class="built_in">count</span>(k-root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        my_set.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root-&gt;left,k) || <span class="built_in">find</span>(root-&gt;right,k);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点🀄️"><a href="#450-删除二叉搜索树中的节点🀄️" class="headerlink" title="450. 删除二叉搜索树中的节点🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a>🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20211125195244554.png" alt="image-20211125195244554"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：1.key&gt;root.val，删除右子树2.&lt;删除左子树 3.相等，root为叶子结点，有右结点，只有左结点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//中序遍历序列的下一个节点。即比当前节点大的最小节点（后续结点）</span></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left != <span class="literal">nullptr</span>) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//中序遍历序列的前一个节点。即比当前节点小的最大节点（前续结点）</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;right != <span class="literal">nullptr</span>) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">successor</span>(root);</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">predecessor</span>(root);</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*转化为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(subRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || subRoot == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;left,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：逻辑&amp;&amp;   T,S:O(n)</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));<span class="comment">//A &amp;&amp; B,A为false时，则不执行B</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees">617.合并二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(min⁡(m,n))</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        merged-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        merged-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="654-最大二叉树-🀄️"><a href="#654-最大二叉树-🀄️" class="headerlink" title="654.最大二叉树 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree">654.最大二叉树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先序遍历：每次取最大值作为根结点</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 寻找最大值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), mid)</span></span>;           <span class="comment">// 构建左/右部分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(mid + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(*mid);        <span class="comment">// 递归的优美</span></span><br><span class="line">        root -&gt; left = <span class="built_in">constructMaximumBinaryTree</span>(l);</span><br><span class="line">        root -&gt; right = <span class="built_in">constructMaximumBinaryTree</span>(r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="655-输出二叉树-🀄️"><a href="#655-输出二叉树-🀄️" class="headerlink" title="655.输出二叉树 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/print-binary-tree">655.输出二叉树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(h∗2^h)  h树的高度</span></span><br><span class="line"><span class="comment">思路：先序遍历+二分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">printTree</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">2</span>, m) <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 二维vector一致填充好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fill</span>(root, <span class="number">0</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        res[depth][mid] = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;left, depth+<span class="number">1</span>, begin, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;right, depth+<span class="number">1</span>, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div>
            
              <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

            
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/" rel="prev" title="2.DFS/BFS+回溯">
      <i class="fa fa-chevron-left"></i> 2.DFS/BFS+回溯
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="1.5.1设计模式">
      1.5.1设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1.二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%B3%BB%E5%88%97"><span class="nav-text">遍历系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%EF%BC%9A%E8%BF%AD%E4%BB%A3%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC"><span class="nav-text">二叉树遍历：迭代统一版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">144. 二叉树的前序遍历 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">145. 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">173. 二叉搜索树迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">102. 二叉树的层序遍历 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-text">543. 二叉树的直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">103. 二叉树的锯齿形层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="nav-text">107. 二叉树的层序遍历 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-text">116. 填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II-%E2%AD%90%EF%B8%8F"><span class="nav-text">117. 填充每个节点的下一个右侧节点指针 II ⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 32 - I. 从上到下打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II"><span class="nav-text">剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="nav-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BST-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">BST+中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E2%AD%90%EF%B8%8F"><span class="nav-text">98. 验证二叉搜索树 ⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E2%AD%90%EF%B8%8F%E9%9A%BE"><span class="nav-text">99. 恢复二叉搜索树 ⭐️难</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9-%E2%AD%90%EF%B8%8F"><span class="nav-text">8.二叉树的下一个结点 ⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#285-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E7%BB%93%E7%82%B9%E2%AD%90%EF%B8%8F"><span class="nav-text">285.二叉搜索树的后续结点⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#272-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%80%BC2"><span class="nav-text">272.最接近的二叉搜索树值2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E2%AD%90%EF%B8%8F"><span class="nav-text">剑指 Offer 36. 二叉搜索树与双向链表⭐️</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88"><span class="nav-text">混合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-text">257. 二叉树的所有路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#270-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%80%BC"><span class="nav-text">270.最接近的二叉搜索树值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#255-%E9%AA%8C%E8%AF%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">255.验证前序遍历序列二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-text">114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">156.上下翻转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 37. 序列化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%F0%9F%92%A3"><span class="nav-text">297. 二叉树的序列化与反序列化 💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%F0%9F%92%A3"><span class="nav-text">剑指 Offer 33. 二叉搜索树的后序遍历序列💣</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%AA%E6%95%B0%EF%BC%8C%E9%80%9A%E8%BF%87%E7%95%8C%E5%AE%9A-1-n-%E6%B1%82%E8%A7%A3"><span class="nav-text">计算个数，通过界定(1,n)求解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II-%E2%AD%90%EF%B8%8F"><span class="nav-text">95. 不同的二叉搜索树 II ⭐️</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%B7%A6%E5%8F%B3%E5%90%8E%E8%87%AA%E5%B7%B1"><span class="nav-text">先左右后自己</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">96. 不同的二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-%F0%9F%80%84%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="nav-text">124. 二叉树中的最大路径和 🀄️⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#250-%E7%BB%9F%E8%AE%A1%E5%90%8C%E5%80%BC%E5%AD%90%E6%A0%91"><span class="nav-text">250.统计同值子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#333-%E6%9C%80%E5%A4%A7BST%E5%AD%90%E6%A0%91"><span class="nav-text">333.最大BST子树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%87%AA%E5%B7%B1%E5%90%8E%E5%B7%A6%E5%8F%B3"><span class="nav-text">先自己后左右</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-text">100. 相同的树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6-%E5%90%8C%E4%B8%8A"><span class="nav-text">剑指 Offer 55 - I. 二叉树的深度 同上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0"><span class="nav-text">获取二叉树的结点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0"><span class="nav-text">获取二叉树的叶子结点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%90%E7%BB%93%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD"><span class="nav-text">某结点是否在二叉树中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 07. 重建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">105. 从前序与中序遍历序列构造二叉树 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">889. 根据前序和后序遍历构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">109. 有序链表转换二叉搜索树 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">110. 平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 55 - II. 平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-text">111. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">669. 修剪二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-text">112. 路径总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-text">113. 路径总和 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%F0%9F%92%A3"><span class="nav-text">剑指 Offer 34. 二叉树中和为某一值的路径💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III%F0%9F%80%84%EF%B8%8F"><span class="nav-text">437. 路径总和 III🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">1110. 删点成林 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-%F0%9F%80%84%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="nav-text">129. 求根到叶子节点数字之和 🀄️⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-text">222. 完全二叉树的节点个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">剑指 Offer 27. 二叉树的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 28. 对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#298-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%F0%9F%80%84%EF%B8%8F%E2%AD%90%EF%B8%8F"><span class="nav-text">298.二叉树最长连续序列🀄️⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#366-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%F0%9F%80%84%EF%B8%8F"><span class="nav-text">366.寻找二叉树的叶子结点🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-text">572. 另一个树的子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-text">404. 左叶子之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-text">513. 找树左下角的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-https-leetcode-cn-com-problems-find-bottom-left-tree-value"><span class="nav-text">538. 把二叉搜索树转换为累加树](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;find-bottom-left-tree-value&#x2F;)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-text">530. 二叉搜索树的最小绝对差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">897. 递增顺序查找树 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST%F0%9F%80%84%EF%B8%8F"><span class="nav-text">653. 两数之和 IV - 输入 BST🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%F0%9F%80%84%EF%B8%8F"><span class="nav-text">450. 删除二叉搜索树中的节点🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">剑指 Offer 26. 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n"><span class="nav-text">剑指 Offer 64. 求1+2+…+n</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">617.合并二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">654.最大二叉树 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#655-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">655.输出二叉树 🀄️</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChaoZhong Zhang"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">ChaoZhong Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/ZhangXiaoyu_sy" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;ZhangXiaoyu_sy" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangChaoZhong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangChaoZhong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zczindex@gmail.com" title="E-Mail → zczindex@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChaoZhong Zhang
  </span>
  <span class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LitCJHzcYDrw3V694F5ykefU-9Nh9j0Va',
      appKey     : 'xrhUoMdaVndszRNhqsBy6jni',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
