<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="d4_pdYcNwIYae3EhA8wFzZvB6zxWe5KWfSnaliXR-Rc" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangchaozhong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="剑指offer，TOP100优先；最后类型题总  #剑指offer （1）二叉树剑指 Offer 07. 重建二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="1.1Java刷题">
<meta property="og:url" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="生于九六年晚冬">
<meta property="og:description" content="剑指offer，TOP100优先；最后类型题总  #剑指offer （1）二叉树剑指 Offer 07. 重建二叉树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210306175018888.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210722224510100.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227172451571.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30356130386632652d393931342d346137372d393265662d6165626561656366346636362e6a7067.jpeg">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210629195210802.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303863366535322d396639332d343465642d623662392d6536393035306531343830372e6a7067.jpeg">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162608191.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162640327.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812100300618.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101125269.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403222407023.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101713646.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812102323894.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210701155141042.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220310102655370.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403224922110.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162930157.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220404204345098.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210630225352435.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/df03847e2d04a3fcb5649541d4b6733fb2cb0d9293c3433823e04935826c33ef-Picture1.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227133912093.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/1614836837-oygHyk-Picture2.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830112644359.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210912114146128.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162901260.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162843069.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160011746.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160104838.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830173325392.png">
<meta property="article:published_time" content="2021-01-02T14:10:00.000Z">
<meta property="article:modified_time" content="2022-06-12T09:12:41.000Z">
<meta property="article:author" content="ChaoZhong Zhang">
<meta property="article:tag" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210306175018888.png">

<link rel="canonical" href="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>1.1Java刷题 | 生于九六年晚冬</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生于九六年晚冬</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangchaozhong.github.io/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="ChaoZhong Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生于九六年晚冬">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          1.1Java刷题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 22:10:00" itemprop="dateCreated datePublished" datetime="2021-01-02T22:10:00+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-12 17:12:41" itemprop="dateModified" datetime="2022-06-12T17:12:41+08:00">2022-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" itemprop="url" rel="index"><span itemprop="name">学习路线</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>剑指offer，TOP100优先；最后类型题总</p>
</blockquote>
<p>#剑指offer</p>
<h2 id="（1）二叉树"><a href="#（1）二叉树" class="headerlink" title="（1）二叉树"></a>（1）二叉树</h2><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 07. 重建二叉树</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210306175018888.png" alt="image-20210306175018888"></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n) 中序遍历</span></span><br><span class="line"><span class="comment">思路：先序的第一个就是根结点，取出来；</span></span><br><span class="line"><span class="comment">再查找根结点在中序中的位置（hashmap）；</span></span><br><span class="line"><span class="comment">然后递归前序和中序的左区间，右区间来重建树的左子树和右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[preL];</span><br><span class="line">        <span class="keyword">int</span> pIndex = map.get(rootVal);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(pre,preL+<span class="number">1</span>,pIndex-inL+preL,inL,pIndex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(pre,pIndex-inL+preL+<span class="number">1</span>,preR,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen=pre.length,inLen=in.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++) map.put(in[i],i); <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(pre,<span class="number">0</span>,preLen-<span class="number">1</span>,<span class="number">0</span>,inLen-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8.二叉树的下一个结点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">8.二叉树的下一个结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前驱节点：当前节点左子树的最右节点</span></span><br><span class="line"><span class="comment">后继节点：当前节点右子树的最左节点</span></span><br><span class="line"><span class="comment">（最左节点是中序遍历（左根右）的第一个节点。）</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）当前节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</span></span><br><span class="line"><span class="comment">2）否则，向上找第一个左指针指向的树包含该节点的祖先节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode right = pNode.right;	<span class="comment">//1）右子树</span></span><br><span class="line">            <span class="keyword">while</span>(right.left != <span class="keyword">null</span>)					<span class="comment">//最左节点</span></span><br><span class="line">                right = right.left;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123; <span class="comment">//2）⚠️找出其父结点</span></span><br><span class="line">                TreeLinkNode root = pNode.next;<span class="comment">//pNode是root的子结点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == pNode)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                pNode  = pNode.next;<span class="comment">//继续向上找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN) S:O(M)	M,N 分别为树 A 和 树 B 的节点数量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）只要有一个为空就不是</span></span><br><span class="line"><span class="comment">2）判断B是否为 A的总结构；递归A的左子树和B；A的右子树和B</span></span><br><span class="line"><span class="comment">3）B为空；A为空或者值不等；递归 A的左子树，B的左子树 &amp;&amp; A的右子树，B的右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || HasSubtree(A.left, B) || HasSubtree(A.right, B));	<span class="comment">//⚠️树B 是 树 A 左／右子树 的子结构 ||</span></span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;	<span class="comment">//O(N)   以 节点 A 为根节点的子树 包含树 B</span></span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;				<span class="comment">//1.B为空</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//2.A为空 或者A！=B</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);	<span class="comment">//⚠️AB的左右子树相同才是相同  &amp;&amp;</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="comment">//镜像，递归交换左右子树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210722224510100.png" alt="image-20210722224510100"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归判断左子树是否等于右子树</span></span><br><span class="line"><span class="comment">1）同为空</span></span><br><span class="line"><span class="comment">2）其中一个为空，或者值不同</span></span><br><span class="line"><span class="comment">3）递归左节点的左子树，右节点右子树；</span></span><br><span class="line"><span class="comment">	 递归左节点的右子树，右节点的左子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">true</span> : recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode l,TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;	<span class="comment">//先判断都为空</span></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || r == <span class="keyword">null</span> || r.val != l.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(l.left,r.right) &amp;&amp; recur(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//T：O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先将根节点放入队列中</span></span><br><span class="line"><span class="comment">while（队列不为空）&#123;</span></span><br><span class="line"><span class="comment">  取出对头，删除对头</span></span><br><span class="line"><span class="comment">  将值放入结果集中</span></span><br><span class="line"><span class="comment">  判断该节点的左节点是否空，不为空，放入队列中；</span></span><br><span class="line"><span class="comment">  判断该节点的右节点是否空，不为空，放入队列中；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按层放入结果集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> s = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=s;i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历 + 双端队列</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">奇数层，插入对头（从左到右）</span></span><br><span class="line"><span class="comment">偶数层，放入队尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> s = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.add(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.add(<span class="number">0</span>,node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-💣"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-💣" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列 💣"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 33. 二叉搜索树的后序遍历序列</a> 💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png" alt="Picture10.png"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227172451571.png" alt="image-20220227172451571"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历倒序==先序遍历的镜像， 左右根</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调栈 存储值递增</span></span><br><span class="line"><span class="comment">倒序遍历序列</span></span><br><span class="line"><span class="comment">1）左子树大于root，直接false</span></span><br><span class="line"><span class="comment">2）保证左子树&lt;右子树，更新root</span></span><br><span class="line"><span class="comment">3）将当前数据进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;		<span class="comment">//先赋值最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//倒序</span></span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="keyword">false</span>;	<span class="comment">//保证左子树&lt;root</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;postorder[i] &lt; stack.peek()  ) <span class="comment">//保证 左子树 &lt; 右子树</span></span><br><span class="line">                root = stack.pop();	<span class="comment">//更新root</span></span><br><span class="line">            stack.add(postorder[i]);<span class="comment">//单调递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-34-二叉树中和为某一值的路径💣"><a href="#剑指-Offer-34-二叉树中和为某一值的路径💣" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径💣"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 34. 二叉树中和为某一值的路径💣</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减去root.val，递归左右子树</span></span><br><span class="line"><span class="comment">/*T,S:O(N)</span></span><br><span class="line"><span class="comment">思路：1）根左右遍历；选择当前值，更新目标值</span></span><br><span class="line"><span class="comment">2）路径记录（判断是否符合，符合就加入结果集）</span></span><br><span class="line"><span class="comment">3）递归左右子树</span></span><br><span class="line"><span class="comment">4）撤销选择（回溯）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,ArrayList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);	<span class="comment">//(1)选择</span></span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));<span class="comment">//深拷贝⚠️不用return</span></span><br><span class="line">        dfs(root.left,sum,path);</span><br><span class="line">        dfs(root.right,sum,path);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);	<span class="comment">//(2)回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        dfs(root,sum,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-36-二叉搜索树与双向链表💣"><a href="#剑指-Offer-36-二叉搜索树与双向链表💣" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30356130386632652d393931342d346137372d393265662d6165626561656366346636362e6a7067.jpeg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span></span><br><span class="line"><span class="comment">排序的双向链表=&gt;中序遍历：</span></span><br><span class="line"><span class="comment">思路：中序遍历</span></span><br><span class="line"><span class="comment">1）递归左子树</span></span><br><span class="line"><span class="comment">2）cur.left = pre ，也构建 pre.right = cur </span></span><br><span class="line"><span class="comment">3）更新pre</span></span><br><span class="line"><span class="comment">4）head指向当前节点cur</span></span><br><span class="line"><span class="comment">5）递归右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(cur.left);</span><br><span class="line">  </span><br><span class="line">    cur.left = pre;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        pre.right = cur;</span><br><span class="line">    pre = cur; 				<span class="comment">//更新pre</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)		<span class="comment">//head记录1次</span></span><br><span class="line">        head = cur;		</span><br><span class="line">  </span><br><span class="line">    inOrder(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-37-序列化二叉树💣"><a href="#剑指-Offer-37-序列化二叉树💣" class="headerlink" title="剑指 Offer 37. 序列化二叉树💣"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 37. 序列化二叉树</a>💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*序列化：二叉树转换为&quot;&#123;1,2,3,#,#,6,7&#125;&quot;；</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">反序列化：&quot;&#123;1,2,3,#,#,6,7&#125;&quot;转换为二叉树</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）取出空格的下标</span></span><br><span class="line"><span class="comment">2）取出deserializeStr空格前的字符串（当前节点），没有空格则是最后一个节点</span></span><br><span class="line"><span class="comment">3）更新deserializeStr（空格后的字符串）</span></span><br><span class="line"><span class="comment">4）创建根节点</span></span><br><span class="line"><span class="comment">5）递归创建左右子树</span></span><br><span class="line"><span class="comment">6）返回根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String deserializeStr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> root.val + <span class="string">&quot; &quot;</span> + Serialize(root.left) + <span class="string">&quot; &quot;</span> + Serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    deserializeStr = str;</span><br><span class="line">    <span class="keyword">return</span> Deserialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">Deserialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deserializeStr.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = deserializeStr.indexOf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    String node = index == -<span class="number">1</span> ? deserializeStr : deserializeStr.substring(<span class="number">0</span>, index);<span class="comment">//空格前的字符串,不包括index</span></span><br><span class="line">    deserializeStr = index == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : deserializeStr.substring(index + <span class="number">1</span>);<span class="comment">//空格后的字符串，更新deserializeStr</span></span><br><span class="line">    <span class="keyword">if</span> (node.equals(<span class="string">&quot;#&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> val = Integer.valueOf(node); <span class="comment">//String转int</span></span><br><span class="line">    TreeNode t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    t.left = Deserialize();</span><br><span class="line">    t.right = Deserialize();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=196&tqId=37117&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=196&page=1&search=%25E7%25AC%25ACk&difficulty=undefined&judgeStatus=undefined&tags=&title=%E7%AC%ACk">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历(⚠️这里是右根左，由于是递归)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>,cnt; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KthNode</span> <span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left,k);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k) res=root.val;</span><br><span class="line">        inOrder(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="comment">//T：O(N) S:O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(TreeDepth(root.left),TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取左右子树的高度，如果abs(right-left) &gt; 1，则不是平衡树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        height(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(right-left) &gt; <span class="number">1</span>) res =<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）root == null，或者q或者p一个等于root，则当前root为最近公共祖先</span></span><br><span class="line"><span class="comment">2）如果 p 和 q 分别在root两个子树l,r中，那么就说明根节点就是最低公共祖先。</span></span><br><span class="line"><span class="comment">3）否则在l或者r</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q== root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l!=<span class="keyword">null</span>?l:r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-20-表示数值的字符串-中等"><a href="#剑指-Offer-20-表示数值的字符串-中等" class="headerlink" title="剑指 Offer 20. 表示数值的字符串  中等"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串 </a> 中等</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[]  ： 字符集合</span></span><br><span class="line"><span class="comment">()  ： 分组</span></span><br><span class="line"><span class="comment">?   ： 重复 0 ~ 1 次</span></span><br><span class="line"><span class="comment">+   ： 重复 1 ~ n 次</span></span><br><span class="line"><span class="comment">*   ： 重复 0 ~ n 次</span></span><br><span class="line"><span class="comment">.   ： 任意字符</span></span><br><span class="line"><span class="comment">\\. ： 转义后的 .</span></span><br><span class="line"><span class="comment">\\d ： 数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\\d?  0-1个数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">&quot;[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）回溯-amp-DFS-BFS"><a href="#（2）回溯-amp-DFS-BFS" class="headerlink" title="（2）回溯&amp;DFS_BFS"></a>（2）回溯&amp;DFS_BFS</h2><p>//DFS+回溯</p>
<h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/69fe7a584f0a445da1b6652978de5c38?tpId=13&tqId=11218&tab=answerKey&from=cyc_github">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span></span><br><span class="line"><span class="comment">//T:O(M*N*3^K)不包含往上方向 S:O(M*N) K为word的长度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）遍历整个矩阵，从0开始递归</span></span><br><span class="line"><span class="comment">2）剪枝（越界，是否访问过，是否相等）</span></span><br><span class="line"><span class="comment">3）标志范访问过</span></span><br><span class="line"><span class="comment">4）遍历4个方向</span></span><br><span class="line"><span class="comment">5）回溯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] dirs=&#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] visted, <span class="keyword">char</span>[] word,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length == k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || i &lt;<span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || visted[i][j] || matrix[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        visted[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,dir[<span class="number">0</span>]+i,dir[<span class="number">1</span>]+j,visted,word,k+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        visted[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, idx = <span class="number">0</span>; r &lt; rows; r++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++)</span><br><span class="line">                matrix[r][c] = array[idx++];</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span> <span class="params">(String array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span> || cols ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">        <span class="keyword">this</span>.cols = cols;</span><br><span class="line">        <span class="keyword">char</span>[][] matrix = buildMatrix(array.toCharArray());</span><br><span class="line">        <span class="keyword">boolean</span>[][] visted = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">char</span>[] word = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix,i,j,visted,word,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>//dfs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="comment">//例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始递归</span></span><br><span class="line"><span class="comment">2）剪枝（越界，是否访问过，当前和是否大于k）</span></span><br><span class="line"><span class="comment">3）标志访问过</span></span><br><span class="line"><span class="comment">4）递归4个方向，累加4个方向和当前格子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//所有位数之和</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">boolean</span>[][] vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || getSum(i) + getSum(j) &gt; k || vis[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vis[i][j] = <span class="keyword">true</span>;   <span class="comment">//标志访问过,不回头</span></span><br><span class="line">        <span class="keyword">return</span> dfs(i-<span class="number">1</span>,j,m,n,k,vis)+dfs(i+<span class="number">1</span>,j,m,n,k,vis)+dfs(i,j-<span class="number">1</span>,m,n,k,vis)+dfs(i,j+<span class="number">1</span>,m,n,k,vis)+<span class="number">1</span>;<span class="comment">//4个方向+当前格子(⚠️别忘了当前格子)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">       <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><p>//回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归全排列</span></span><br><span class="line"><span class="comment">//T：O(10^n) S:O(10^n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</span></span><br><span class="line"><span class="comment">1）循环n次</span></span><br><span class="line"><span class="comment">2）当前长度x == len，加入结果集</span></span><br><span class="line"><span class="comment">3）start，最高位不能为0，遍历1-9；其他位遍历0-9</span></span><br><span class="line"><span class="comment">	确定本位数字</span></span><br><span class="line"><span class="comment">	递归下一位数数字</span></span><br><span class="line"><span class="comment">	撤销当前选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">char</span> NUM[<span class="number">10</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成长度为 len 的数字，正在确定第x位（从左往右）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len) &#123;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = x==<span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// ⚠️X=0表示左边第一位数字，不能为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            cur.push_back(NUM[i]); <span class="comment">// 确定本位数字</span></span><br><span class="line">            backtrack(x+<span class="number">1</span>, len); <span class="comment">// 确定下一位数字</span></span><br><span class="line">            cur.pop_back(); <span class="comment">// 删除本位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 数字长度：1~n</span></span><br><span class="line">            backtrack(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_int;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)</span><br><span class="line">            res_int.push_back(stoi(res[i]));</span><br><span class="line">        <span class="keyword">return</span> res_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-38-字符串的排列💣"><a href="#剑指-Offer-38-字符串的排列💣" class="headerlink" title="剑指 Offer 38. 字符串的排列💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列💣</a></h4><p>//回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N!N) S:O(N^2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始递归</span></span><br><span class="line"><span class="comment">2）当前x等于字符串长度 加入结果集</span></span><br><span class="line"><span class="comment">循环&#123;</span></span><br><span class="line"><span class="comment">	剪枝：重复继续</span></span><br><span class="line"><span class="comment">	将当前元素放入hashset</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	选择，交换c[i]，固定x位</span></span><br><span class="line"><span class="comment">	递归x+1</span></span><br><span class="line"><span class="comment">	撤销选择</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c));      <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//存放字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);                      <span class="comment">// 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);                      <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x);                      <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（3）贪心"><a href="#（3）贪心" class="headerlink" title="（3）贪心"></a>（3）贪心</h2><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b b=0,1,2。推导=&gt;最优：把绳子尽可能切为多个长度为3的片段，次优2，最差1</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a=n/<span class="number">3</span>;	<span class="comment">//n=3*a+b</span></span><br><span class="line">        <span class="keyword">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a);    <span class="comment">//n=6,a=2 b=0 3^2</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;    <span class="comment">//n=7  a=2 b=1 3^1*4</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;    <span class="comment">//n=8 a=2 b=2 3^2*2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-14-II-剪绳子-II-💣"><a href="#剑指-Offer-14-II-剪绳子-II-💣" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II 💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a> 💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，结果取模 1e9+7，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b  快速幂求余</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>,p=<span class="number">1000000007</span>; <span class="comment">//n =3a+b b=0,1,2</span></span><br><span class="line">        <span class="keyword">int</span> a = n/<span class="number">3</span>-<span class="number">1</span>;	<span class="comment">//少一个</span></span><br><span class="line">        <span class="comment">//base,a,p，求 base^a mod p。</span></span><br><span class="line">        <span class="keyword">long</span> base=<span class="number">3</span>,rem=<span class="number">1</span>;     <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;     <span class="comment">//n=9 rem=9</span></span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">1</span>) rem=rem*base%p;	<span class="comment">//有余数</span></span><br><span class="line">            base= base*base%p; <span class="comment">//注意</span></span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//举例子n=6,7,8</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>%p);<span class="comment">//rem^(a+1)%p   </span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">4</span>%p);  <span class="comment">//rem^(a)*4%p</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>*<span class="number">2</span>%p);    <span class="comment">//rem^(a+1)*2%p          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="（4）双指针"><a href="#（4）双指针" class="headerlink" title="（4）双指针"></a>（4）双指针</h2><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 04. 二维数组中的查找</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键思想：从二维数组的右上角开始查找。</span></span><br><span class="line"><span class="comment">//T:O(n+m) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span> || M == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows=M.length, cols = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,c=cols-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= rows -<span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = M[r][c];</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; target) c--;</span><br><span class="line">            <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tqId=11155&tab=answerKey&from=cyc_github">剑指 Offer 05. 替换空格</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组扩展为原来3倍</span></span><br><span class="line"><span class="comment">遇到空格，替换为%20</span></span><br><span class="line"><span class="comment">没有直接放入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;  <span class="comment">//String是个对象</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>*len]; <span class="comment">//1个字符替换为3个字符，长度变为原来3倍</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);  </span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[size++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = <span class="keyword">new</span> String(arr,<span class="number">0</span>,size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，搜索  T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*定义头指针 left ，尾指针 right .</span></span><br><span class="line"><span class="comment">left 一直往右移，直到它指向的值为偶数</span></span><br><span class="line"><span class="comment">right 一直往左移， 直到它指向的值为奇数</span></span><br><span class="line"><span class="comment">交换 nums[left] 和 nums[right] .</span></span><br><span class="line"><span class="comment">重复上述操作，直到 left==right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r= nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;r &amp;&amp; nums[l]%<span class="number">2</span>!=<span class="number">0</span>) l++;    <span class="comment">//往右寻找偶数(最左的偶数)</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;r &amp;&amp; nums[r]%<span class="number">2</span>==<span class="number">0</span>) r--;    <span class="comment">//往左寻找奇数</span></span><br><span class="line">            <span class="keyword">int</span> t=nums[l];</span><br><span class="line">            nums[l]=nums[r];</span><br><span class="line">            nums[r]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  ListNode l=pHead,r=pHead;</span><br><span class="line">  <span class="keyword">while</span>(r!=<span class="keyword">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) r=r.next;	<span class="comment">//顺序不能换</span></span><br><span class="line">  <span class="keyword">if</span>(k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//链表长度 &lt; k</span></span><br><span class="line">  <span class="keyword">while</span>(r!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    l=l.next;</span><br><span class="line">    r=r.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23.链表中环的入口结点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">23.链表中环的入口结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//【快慢指针，同步指针】2次相遇：第1次相遇不清楚位置，第二次相遇为入口结点。重合时 fast 比 slow 多走 环的长度整数倍</span></span><br><span class="line"><span class="comment">//设快慢指针走了f,s步,</span></span><br><span class="line"><span class="comment">//第1次相遇：fast：f=2s(fast 每轮走 2 步) f=s+nb(比slow多走环的长度整数倍) ==&gt; slow:s = nb		a：环外的长度，b：环的长度</span></span><br><span class="line"><span class="comment">//此时：　slow:nb，只要让slow多走a步，就是环的入口。</span></span><br><span class="line"><span class="comment">//而我们只要令fast=head，跟slow同步走，第2次相遇时就是环的入口</span></span><br><span class="line"><span class="comment">//第2次相遇：让slow在a步停下来，让slow和fast在a处相遇，</span></span><br><span class="line"><span class="comment">//slow不变，fast=head，同步移动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode fast=pHead,slow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//无环⚠️</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;	<span class="comment">//第1次相遇 有环</span></span><br><span class="line">        &#125;</span><br><span class="line">  		<span class="comment">//第2次相遇</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = head;<span class="comment">//⚠️头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;             <span class="comment">//⚠️更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> head.next;       <span class="comment">//⚠️头结点没有存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对💣💣"><a href="#剑指-Offer-51-数组中的逆序对💣💣" class="headerlink" title="剑指 Offer 51. 数组中的逆序对💣💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对💣💣</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(nlogn),S:O(n)</span></span><br><span class="line"><span class="comment">//归并排序，加了个计数器</span></span><br><span class="line"><span class="comment">//在第2个数组元素归并上去时，计数，计数后的元素不再计算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//1.计数器</span></span><br><span class="line">    <span class="keyword">int</span>[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        </span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = nums[k];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = lo;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid || j &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)                 nums[index++] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)             nums[index++] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &lt;= aux[j])   nums[index++] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[index++] = aux[j++];  </span><br><span class="line">                count += mid - i + <span class="number">1</span>; <span class="comment">//2.累计逆序对</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 57. 和为s的两个数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针：搜索</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：sum = l +r;</span></span><br><span class="line"><span class="comment">sum&gt;target，r--;</span></span><br><span class="line"><span class="comment">else l++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="comment">//数组是递增排序好的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[l]+nums[r];</span><br><span class="line">            <span class="keyword">if</span>(t == sum) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[l],nums[r]));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; sum) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210629195210802.png" alt="image-20210629195210802"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针：滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(target)	S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：sum = (l+r)*(r-l+1)/2</span></span><br><span class="line"><span class="comment">sum == target，[l,r]</span></span><br><span class="line"><span class="comment">sum &gt; target,l++</span></span><br><span class="line"><span class="comment">sum &lt; target,r++</span></span><br><span class="line"><span class="comment">返回多个区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">       <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;	<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> sum = (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">//区间[l,r]的和</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)   tmp.add(i);   <span class="comment">//i-l从0开始放</span></span><br><span class="line">                res.add(tmp);</span><br><span class="line">                l++;                       <span class="comment">//开启新的区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) l++;    <span class="comment">//⚠️大了，l右移，减数</span></span><br><span class="line">            <span class="keyword">else</span> r++;                      <span class="comment">//小了，r右移，加数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）二分"><a href="#（5）二分" class="headerlink" title="（5）二分"></a>（5）二分</h3><h4 id="剑指-Offer-11-旋转数组的最小数字-同154-寻找旋转排序数组中的最小值-II"><a href="#剑指-Offer-11-旋转数组的最小数字-同154-寻找旋转排序数组中的最小值-II" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字 同154.寻找旋转排序数组中的最小值 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a> 同154.寻找旋转排序数组中的最小值 II</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分法：</span></span><br><span class="line"><span class="comment">//与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：与右端元素比较</span></span><br><span class="line"><span class="comment">大于右端,则r =mid，最小值在左边</span></span><br><span class="line"><span class="comment">小于右端，则l = mid+1，最小值在右边</span></span><br><span class="line"><span class="comment">等于右端r--;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;        <span class="comment">//最小值在左边[l,mid]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l=mid+<span class="number">1</span>;   <span class="comment">//最小值在右边[mid+1,r]</span></span><br><span class="line">            <span class="keyword">else</span> r--;                               <span class="comment">//⚠️加这里，去除r边界,最小值在[l,r)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-16-数值的整数次方-快速幂"><a href="#剑指-Offer-16-数值的整数次方-快速幂" class="headerlink" title="剑指 Offer 16. 数值的整数次方 快速幂"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 16. 数值的整数次方</a> 快速幂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">//base^a</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//处理0</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>)&#123;	<span class="comment">//处理负数</span></span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">            a = -a;a</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">1</span>) res=res*base;</span><br><span class="line">            base*=base;</span><br><span class="line">            a/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I⭐️"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I⭐️" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>⭐️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="comment">//时间复杂度 O(logN) ： 二分法为对数级别复杂度。</span></span><br><span class="line"><span class="comment">//空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">与target比，</span></span><br><span class="line"><span class="comment">l &lt; = r;</span></span><br><span class="line"><span class="comment">hleper(nums,target)-hleper(nums,target-1);</span></span><br><span class="line"><span class="comment">寻找多个nums[mid] &lt;= target</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hleper(nums,target)-hleper(nums,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hleper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//target的右边界（边界不包括target）</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123; <span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l=mid+<span class="number">1</span>;    <span class="comment">//在[mid+1,r]	⚠️</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;                   <span class="comment">//在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字⭐️"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字⭐️" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字⭐️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字⭐️</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logN) S:O(1)</span></span><br><span class="line"><span class="comment">//与中间下标比较</span></span><br><span class="line"><span class="comment">//相等，缺失值表明在右边；不等，表明在左边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;		<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)    l=mid+<span class="number">1</span>;<span class="comment">//相等，在[mid+1,r]</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;   <span class="comment">//不等，在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（6）DP"><a href="#（6）DP" class="headerlink" title="（6）DP"></a>（6）DP</h2><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, sum;	<span class="comment">//sum:f(n+1)   a:f(n-1) b:f(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	<span class="comment">//此时，b赋值给了a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">矩阵覆盖</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303863366535322d396639332d343465642d623662392d6536393035306531343830372e6a7067.jpeg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-10-II-青蛙跳台阶问题🀄️"><a href="#剑指-Offer-10-II-青蛙跳台阶问题🀄️" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🀄️</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162608191.png" alt="image-20210813162608191"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进阶跳台阶"><a href="#进阶跳台阶" class="headerlink" title="进阶跳台阶"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">进阶跳台阶</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.动态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">        <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.数学</span></span><br><span class="line">f(n-<span class="number">1</span>) = f(n-<span class="number">2</span>) + f(n-<span class="number">3</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = <span class="number">2</span>*f(n-<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-19-正则表达式匹配-💣"><a href="#剑指-Offer-19-正则表达式匹配-💣" class="headerlink" title="剑指 Offer 19. 正则表达式匹配  💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>  💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 42. 连续子数组的最大和</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162640327.png" alt="image-20210813162640327"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">pre = max（当前数，上一个数+当前数）</span></span><br><span class="line"><span class="comment">res = max（上一次结果，pre）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,res = nums[<span class="number">0</span>];	<span class="comment">//⚠️初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(x,pre+x);	<span class="comment">//⚠️当前x 或者 x加上之前</span></span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-46-把数字翻译成字符串-🀄️"><a href="#剑指-Offer-46-把数字翻译成字符串-🀄️" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a> 🀄️</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812100300618.png" alt="image-20210812100300618"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101125269.png" alt="image-20210812101125269"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403222407023.png" alt="image-20220403222407023"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T：O(n)</span></span><br><span class="line"><span class="comment">//S：用了滚动数组O(1)，但是这里用了一个临时变量把数字转化成了字符串，故渐进空间复杂度也是 O(log⁡n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意： 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”，有多少种不同的翻译方法。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">滚动数组：</span></span><br><span class="line"><span class="comment">1）单独一个数字q:f(n-1)</span></span><br><span class="line"><span class="comment">2）2个数字p:f(n-2)  r:f(n) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">1</span>; <span class="comment">//p:f(n-2) q:f(n-1) r:f(n) ⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            p =q;</span><br><span class="line">            q =r;</span><br><span class="line">            r =<span class="number">0</span>;	<span class="comment">//复原⚠️</span></span><br><span class="line">            r += q; <span class="comment">//f(i-1)贡献</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String pre = str.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);    <span class="comment">//取i-1到i的子串</span></span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">                r+=p;   <span class="comment">//f(i-2)贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101713646.png" alt="image-20210812101713646"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812102323894.png" alt="image-20210812102323894"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN)</span></span><br><span class="line"><span class="comment">//S:O(1) grid作为dp使用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）i，j都为0，直接跳过</span></span><br><span class="line"><span class="comment">2）从边界从左到右，从上到下，直接加；</span></span><br><span class="line"><span class="comment">3）中间元素，max（左边，上边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length; <span class="comment">//m行，n列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];              <span class="comment">//从左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];           <span class="comment">//从上</span></span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);<span class="comment">//从上或从左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210701155141042.png" alt="image-20210701155141042"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220310102655370.png" alt="image-20220310102655370"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划+哈希</span></span><br><span class="line"><span class="comment">//由于返回值是取 dp列表最大值，因此可借助变量 tmp 存储 dp[j]</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）获取当前j的索引下标（上次存过的），没有返回-1</span></span><br><span class="line"><span class="comment">2）tmp &lt; j-i（表明s[i]在字符串tmp之外） ,则 tmp+1；否则tmp = j-i</span></span><br><span class="line"><span class="comment">3）保存中间结果最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j),-<span class="number">1</span>);   <span class="comment">//获取i的索引,-1位默认值，与s.charAt(j)最左同字符的下标</span></span><br><span class="line">            dic.put(s.charAt(j),j); <span class="comment">//更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j-i ? tmp+<span class="number">1</span>:j-i;<span class="comment">//dp[j-1] &lt; j-i，则最长长度为tmp+1，否则有重复的，j-i</span></span><br><span class="line">            res = Math.max(res,tmp);    <span class="comment">//保存中间结果最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403224922110.png" alt="image-20220403224922110"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</span></span><br><span class="line"><span class="comment">//设动态规划列表dp ，dp[i]代表第 i+1 个丑数；（下标从0开始的）</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）设置指针 a,b,c指向首个丑数（即 1 ）</span></span><br><span class="line"><span class="comment">2）当前dp[i] 赋值(n1,n2,n3)</span></span><br><span class="line"><span class="comment">3）判断当前dp[i]属于哪个，对应a，b，c加1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//首个丑数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=dp[a]*<span class="number">2</span>,n2=dp[b]*<span class="number">3</span>,n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(n1,Math.min(n2,n3));	<span class="comment">//最小因子</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-60-n个骰子的点数💣"><a href="#剑指-Offer-60-n个骰子的点数💣" class="headerlink" title="剑指 Offer 60. n个骰子的点数💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a>💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162930157.png" alt="image-20210813162930157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）所有花费= min(当前价格,历史花费)  低价买入</span></span><br><span class="line"><span class="comment">2）max（当前利润，当前价格-所有花费） 高价卖出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;<span class="comment">//⚠️初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);	<span class="comment">//min(prices[0:i])</span></span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（7）数据结构"><a href="#（7）数据结构" class="headerlink" title="（7）数据结构"></a>（7）数据结构</h2><h3 id="7-1-模拟"><a href="#7-1-模拟" class="headerlink" title="7.1 模拟"></a>7.1 模拟</h3><h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&tqId=11203&tab=answerKey&from=cyc_github">剑指 Offer 03. 数组中重复的数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原地交换</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始遍历到n-1</span></span><br><span class="line"><span class="comment">2）while 发现当前数字不等于当前下标</span></span><br><span class="line"><span class="comment">	再判断当前数字 是否与 以当前数字为下标的数字是否一样，是的话就是重复的数，直接返回；不是就替换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 29. 顺时针打印矩阵</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟、</span></span><br><span class="line"><span class="comment">//先设定边界，再遍历边界并判断边界是否超出</span></span><br><span class="line"><span class="comment">//T:O(mn) S:O(mn)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）设定边界l=0,r=arr[0].length-1,t=0,b=arr.length-1;</span></span><br><span class="line"><span class="comment">2）遍历边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] arr) &#123;</span><br><span class="line">      	ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=arr[<span class="number">0</span>].length-<span class="number">1</span>,t=<span class="number">0</span>,b=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)    res.add(arr[t][i]);   <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=b;i++)    res.add(arr[i][r]);   <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--)    res.add(arr[b][i]);   <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&gt;=t;i--)    res.add(arr[i][l]);   <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改进版：先顺时针再逆时针打印"><a href="#改进版：先顺时针再逆时针打印" class="headerlink" title="改进版：先顺时针再逆时针打印"></a>改进版：先顺时针再逆时针打印</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">node</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.x - b.x != <span class="number">0</span>) <span class="keyword">return</span> a.x - b.x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> a.y - b.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(s,<span class="number">0</span>,n,<span class="keyword">new</span> cmp());  对s数组排序</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="comment">//T:O(NlogN) ，最差为 O(N^2) 	S:O(N)</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">自定义排序</span></span><br><span class="line"><span class="comment">a+b 或者 b+a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];							<span class="comment">//存储成字符串数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">      </span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x)); <span class="comment">//x+y &gt;y+x，则x&gt;y,x放后面</span></span><br><span class="line">      <span class="comment">//Arrays.sort(Integernum, (a, b)-&gt;b - a); 降序</span></span><br><span class="line">       <span class="comment">//quickSort(strs, 0, strs.length - 1);            //排序</span></span><br><span class="line">      </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();							<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    		String tmp = strs[l];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//j + l &gt; l + j，说明j&gt;l</span></span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">//先翻转每个单词，再翻转整个字符串。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt;= n) &#123;<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">if</span> (end == n || chars[end] == <span class="string">&#x27; &#x27;</span>) &#123;	<span class="comment">//j遇到空格或者结尾</span></span><br><span class="line">                reverse(chars, start, end- <span class="number">1</span>);		<span class="comment">//翻转[start,end-1]</span></span><br><span class="line">                start = end + <span class="number">1</span>;  <span class="comment">//更新i</span></span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            swap(c, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="58-2左旋转字符串"><a href="#58-2左旋转字符串" class="headerlink" title="58.2左旋转字符串"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">58.2左旋转字符串</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先将 &quot;abc&quot; 和 &quot;XYZdef&quot; 分别翻转，得到 &quot;cbafedZYX&quot;，然后再把整个字符串翻转得到 &quot;XYZdefabc&quot;。*/</span></span><br><span class="line"><span class="comment">//去重；先翻转前半部分，再翻转后半部分；最后整体翻转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">int</span> k = n%str.length();<span class="comment">//去重</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    reverse(chars, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, k, chars.length - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars); <span class="comment">//String.valueOf(chars);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(chars, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220404204345098.png" alt="image-20220404204345098"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表格分区</span></span><br><span class="line"><span class="comment">//T:O(N)	S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先计算下三角</span></span><br><span class="line"><span class="comment">计算上三角</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;    <span class="comment">//先计算下三角</span></span><br><span class="line">            tmp *= a[i-<span class="number">1</span>];</span><br><span class="line">          	b[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//先计算上三角 ⚠️从倒数第二行开始</span></span><br><span class="line">            tmp *= a[i+<span class="number">1</span>];  <span class="comment">//i+1最后一列开始</span></span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N)	S：O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">去除空格</span></span><br><span class="line"><span class="comment">符号处理</span></span><br><span class="line"><span class="comment">循环</span></span><br><span class="line"><span class="comment">	非字符处理</span></span><br><span class="line"><span class="comment">	越界处理</span></span><br><span class="line"><span class="comment">	结果计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = str.trim().toCharArray();    <span class="comment">//1.去除首尾空格</span></span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>; <span class="comment">//2.符号处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] &lt; <span class="string">&#x27;0&#x27;</span> || c[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//3.非字符处理</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;  <span class="comment">//4.越界处理：最大值与最小值处理</span></span><br><span class="line">            res = res * <span class="number">10</span> + (c[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-栈和队列"><a href="#7-2-栈和队列" class="headerlink" title="7.2 栈和队列"></a>7.2 栈和队列</h3><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 06. 从尾到头打印链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用栈</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*1.递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.addAll(printListFromTailToHead(listNode.next));<span class="comment">//⚠️</span></span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.栈*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode tmp= head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;   <span class="comment">//进栈</span></span><br><span class="line">            stack.push(tmp);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;    <span class="comment">//出栈</span></span><br><span class="line">            res[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2个栈</span></span><br><span class="line"><span class="comment">//栈1：进  栈2：删除(当第2个栈不为空时直接删除，为空时，将第一个栈的所有元素添加到栈2，再删除)</span></span><br><span class="line"><span class="comment">//T:O(1) S:O(N)</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;	<span class="comment">//不为空，直接删除</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;					<span class="comment">//栈2为空，⚠️将栈1的所有元素添加到栈2，再删除</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.isEmpty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 30. 包含min函数的栈</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助栈：存储非严格递减的序列，min就是栈顶</span></span><br><span class="line"><span class="comment">//T:O(1) S:O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();<span class="comment">//最小栈维护最小值  </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || stack2.peek() &gt;= x) <span class="comment">//为空或者栈顶大于等于x，⚠️非严格递减，一定要&gt;=</span></span><br><span class="line">            stack2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;	<span class="comment">//⚠️ 栈1弹出的是跟栈2栈顶一样，栈2才弹出</span></span><br><span class="line">        <span class="keyword">if</span>(stack1.pop().equals(stack2.peek())) stack2.pop();</span><br><span class="line">      <span class="comment">//防止栈1弹出的不是最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 31. 栈的压入、弹出序列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟:T:O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）不断进栈</span></span><br><span class="line"><span class="comment">2）然后循环判断栈顶是否与与出栈序列相同，是的话，出栈</span></span><br><span class="line"><span class="comment">3）直到栈为空，则是符合的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);  <span class="comment">//进栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;   <span class="comment">//循环判断并出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210630225352435.png" alt="image-20210630225352435"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(k)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先用堆维护一个窗口（并把第一个堆顶加入结果）</span></span><br><span class="line"><span class="comment">遍历数组（移动窗口）</span></span><br><span class="line"><span class="comment">	将第一个元素移除</span></span><br><span class="line"><span class="comment">	并把最后一个元素添加进去</span></span><br><span class="line"><span class="comment">	把堆顶加入结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>)	<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  <span class="comment">/* 大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heap.add(num[i]);</span><br><span class="line">    ret.add(heap.peek());	<span class="comment">//第1个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + size; j &lt; num.length; i++, j++) &#123;            <span class="comment">/* heap维护一个大小为 size 的大顶堆 */</span></span><br><span class="line">        heap.remove(num[i]);</span><br><span class="line">        heap.add(num[j]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）A是原始序列；B维护单调递减序列（链头是最大值）</span></span><br><span class="line"><span class="comment">2）插入：一直判断链尾是否 &lt; 当前 x，不是则删除；没有了，则将当前x插入A，B</span></span><br><span class="line"><span class="comment">3）删除：删除A；先判断删除的值是否与B的最大值（链头）相同，是的话，才删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!B.isEmpty() &amp;&amp; B.peekLast() &lt; x) &#123;  <span class="comment">//将B中所有小于x，全部删除，严格递减</span></span><br><span class="line">            B.removeLast(); <span class="comment">//removeLast()返回空，pollLast()返回boolean，</span></span><br><span class="line">        &#125;</span><br><span class="line">        B.addLast(x);     <span class="comment">//插入到B后面</span></span><br><span class="line">        A.addLast(x);     <span class="comment">//插入到A后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = A.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (ans == B.peekFirst()) &#123;</span><br><span class="line">            B.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 41. 数据流中的中位数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="comment">//查找 T:O(1) 插入O(logn) ； S：O(n)</span></span><br><span class="line"><span class="comment">//优先队列,堆</span></span><br><span class="line"><span class="comment">//如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）2个堆，大顶堆，小顶堆</span></span><br><span class="line"><span class="comment">2）插入元素，当前为偶数个则插入右边（小顶堆，插入前先插入到左边，因为不知道插入的数字是多大）；奇数，插入左边（同理先插入右边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">             * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span></span><br><span class="line"><span class="comment">             * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-2字符流中第一个不重复的字符"><a href="#41-2字符流中第一个不重复的字符" class="headerlink" title="41.2字符流中第一个不重复的字符"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">41.2字符流中第一个不重复的字符</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1）使用队列来存储到达的字符，记录次数</span></span><br><span class="line"><span class="comment">2）移除队列头部那些出现次数不再是一次的元素。</span></span><br><span class="line"><span class="comment">因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        cnts[ch]++;</span><br><span class="line">        queue.add(ch);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; <span class="number">1</span>)</span><br><span class="line">            queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? <span class="string">&#x27;#&#x27;</span> : queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-哈希表"><a href="#7-3-哈希表" class="headerlink" title="7.3 哈希表"></a>7.3 哈希表</h3><h4 id="剑指-Offer-50-第一个只出现一次的字符-⚠️"><a href="#剑指-Offer-50-第一个只出现一次的字符-⚠️" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符 ⚠️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a> ⚠️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序哈希表</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）先存储每个字符的次数</span></span><br><span class="line"><span class="comment">2）再遍历一遍，次数为1的就是</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">      cnts[str.charAt(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">      <span class="keyword">if</span> (cnts[str.charAt(i)] == <span class="number">1</span>)	<span class="comment">//传的是str.charAt(i)</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最优</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    BitSet bs1 = <span class="keyword">new</span> BitSet(<span class="number">128</span>);</span><br><span class="line">    BitSet bs2 = <span class="keyword">new</span> BitSet(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs1.set(c);     <span class="comment">// bs1存在  bs2不存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs2.set(c);     <span class="comment">// 存在2次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c)) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/df03847e2d04a3fcb5649541d4b6733fb2cb0d9293c3433823e04935826c33ef-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N)	S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">遍历数组</span></span><br><span class="line"><span class="comment">	跳过大小王</span></span><br><span class="line"><span class="comment">	保存最大值，最小值</span></span><br><span class="line"><span class="comment">	重复，直接返回false</span></span><br><span class="line"><span class="comment">	否则存入哈希</span></span><br><span class="line"><span class="comment">最大值-最小值 &lt; 5  5-1&lt;=4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过大小王</span></span><br><span class="line">            max = Math.max(max, num); <span class="comment">// 最大牌</span></span><br><span class="line">            min = Math.min(min, num); <span class="comment">// 最小牌</span></span><br><span class="line">            <span class="keyword">if</span>(repeat.contains(num)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num); <span class="comment">// 添加此牌至 Set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-链表"><a href="#7-4-链表" class="headerlink" title="7.4 链表"></a>7.4 链表</h3><h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(1) </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2,因此该算法的平均时间复杂度为 O(1)。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）先判断删除的是不是头结点</span></span><br><span class="line"><span class="comment">2）不是的，找到删除的结点</span></span><br><span class="line"><span class="comment">3）找到了，将其删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;   <span class="comment">//删除的是头结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;   <span class="comment">//2个指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) pre.next = cur.next;    <span class="comment">//如果找到了，将当前结点删除</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-2删除链表中重复的结点"><a href="#18-2删除链表中重复的结点" class="headerlink" title="18.2删除链表中重复的结点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">18.2删除链表中重复的结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当前指针和头指针是否相同，是相同删除，直到不同，递归；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode cur =pHead.next;</span><br><span class="line">        <span class="keyword">if</span> (pHead.val == cur.val) &#123;    <span class="comment">//相同</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; pHead.val == cur.val)    <span class="comment">//⚠️直到不相同为止</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pHead.next = deleteDuplication(pre.next); </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 24. 反转链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);	<span class="comment">//新建1个头结点 </span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next; <span class="comment">//保存下一个结点</span></span><br><span class="line">        head.next = newList.next;</span><br><span class="line">        newList.next = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-35-复杂链表的复制💣"><a href="#剑指-Offer-35-复杂链表的复制💣" class="headerlink" title="剑指 Offer 35. 复杂链表的复制💣"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 35. 复杂链表的复制</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227133912093.png" alt="image-20220227133912093"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 插入新节点</span></span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立 random 链接</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = cur.next;	<span class="comment">//clone</span></span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">                clone.random = cur.random.next; <span class="comment">//clone-&gt;cur</span></span><br><span class="line">          </span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （跳1个）拆分</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next; <span class="comment">//1 -&gt;2;1&#x27;-&gt;2&#x27;,2-&gt;3,2&#x27;-&gt;3&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode tmp = cur.next;    <span class="comment">//⚠️中间临时结点tmp</span></span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针  完美偶遇</span></span><br><span class="line"><span class="comment">// T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  	 <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1,node2 =pHead2;</span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="keyword">null</span> ? node1.next:pHead2;<span class="comment">//循环遍历1，到null时，变为head2</span></span><br><span class="line">            node2 = node2 != <span class="keyword">null</span> ? node2.next:pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;<span class="comment">//返回node2也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-位运算"><a href="#7-5-位运算" class="headerlink" title="7.5 位运算"></a>7.5 位运算</h3><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(M):M二进制1的个数 S：O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= （n - <span class="number">1</span>）; <span class="comment">//去除最高位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-I-数组中数字出现的次数💣"><a href="#剑指-Offer-56-I-数组中数字出现的次数💣" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数💣"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/1614836837-oygHyk-Picture2.png" alt="Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组异或：(2,1,3,2)     其他出现2次，找2个出现1次</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//全员异或后得到这个只出现一次的数（本题需要找到2个）</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">//结果,0与任何数异或还是自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//找到ret第一位不是0的 是1</span></span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;	<span class="comment">//判断该位是否为0进行分组 （2，1，2）=&gt;1</span></span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//(3)</span></span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830112644359.png" alt="image-20210830112644359"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。</span></span><br><span class="line"><span class="comment">//因此，统计所有数字的各二进制位中 1 的出现次数，并对3求余，结果则为只出现一次的数字。</span></span><br><span class="line"><span class="comment">//其他3次，找1个   (1,0,1,1)</span></span><br><span class="line"><span class="comment">//有限状态自动机 T:O(n)  S:O(1)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;	<span class="comment">//二进制数的2个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算：x ^ 0 = x， x ^ 1 = ~x</span></span><br><span class="line"><span class="comment">// 与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件与 &amp;&amp; 具有短路原则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">boolean</span> b = (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3+4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">011</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> (a &amp; b) &lt;&lt;  1</span></span><br><span class="line"><span class="comment">^= 111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// &amp;取最高位，c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和 </span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-排序"><a href="#7-6-排序" class="headerlink" title="7.6 排序"></a>7.6 排序</h3><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 40. 最小的k个数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210912114146128.png" alt="image-20210912114146128"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排  T：O(n) S:O(1)</span></span><br><span class="line"><span class="comment">//快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//⚠️ 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt;  <span class="title">quickSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) ret.add(nums[i]);<span class="comment">//0到k</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];	<span class="comment">//基准</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;	<span class="comment">//j为什么+1？</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);	<span class="comment">//注意先++</span></span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大根堆  T:O(nlog⁡k) S:O(k), n为数组的长度，k为大根堆里最多k个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123; <span class="comment">// 排除 0 的情况</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1, Integer num2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num2 - num1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;   <span class="comment">//首先插入k个数</span></span><br><span class="line">            queue.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; ++i) &#123;<span class="comment">//维护前k个数</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peek() &gt; arr[i]) &#123;    <span class="comment">//比堆顶小，插入</span></span><br><span class="line">                queue.poll();           <span class="comment">//堆顶弹出</span></span><br><span class="line">                queue.offer(arr[i]);    <span class="comment">//插入当前数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;   <span class="comment">//将堆的数据赋值给res</span></span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-45-把数组排成最小的数-1"><a href="#剑指-Offer-45-把数组排成最小的数-1" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(NlogN),S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a));<span class="comment">//排序</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（8）数学"><a href="#（8）数学" class="headerlink" title="（8）数学"></a>（8）数学</h2><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摩尔投票法</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,votes=<span class="number">0</span>;		<span class="comment">// 票数统计 votes = 0 ， 众数 x  众数是指一组数据中出现次数最多的那个数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字-约瑟环"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-约瑟环" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> 约瑟环</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162901260.png" alt="image-20210813162901260"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162843069.png" alt="image-20210813162843069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)     <span class="comment">/* 递归返回条件 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160011746.png" alt="image-20220119160011746"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160104838.png" alt="image-20220119160104838"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T：O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">当 cur = 0 时:此位 1 的出现次数:high×digit</span></span><br><span class="line"><span class="comment">当 cur = 1 时:high×digit+low+1</span></span><br><span class="line"><span class="comment">当 cur &gt; 1 时： (high+1)×digit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>, res = <span class="number">0</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;<span class="comment">//当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            low += cur * digit;      <span class="comment">//将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">            cur = high % <span class="number">10</span>;        </span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830173325392.png" alt="image-20210830173325392"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;	<span class="comment">//位数digit</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;		<span class="comment">//数位数量count</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.计算n所在的数位数量count  </span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;	<span class="comment">//（n:11  n=2 count=180 start=10 digit=2 num=10 ）</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.计算n所在的数字num </span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.确定 n 是num 中的哪一数位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TOT100"><a href="#TOT100" class="headerlink" title="TOT100"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">TOT100</a></h2><h2 id="HOP150"><a href="#HOP150" class="headerlink" title="HOP150"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2ckc81c/">HOP150</a></h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div>
            
              <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

            
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/02/1.3JVM/" rel="prev" title="1.3JVM">
      <i class="fa fa-chevron-left"></i> 1.3JVM
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/02/0.%E7%BB%AA%E8%AE%BA/" rel="next" title="0.绪论">
      0.绪论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">（1）二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 07. 重建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">8.二叉树的下一个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">剑指 Offer 26. 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">剑指 Offer 27. 二叉树的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 28. 对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 32 - I. 从上到下打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II"><span class="nav-text">剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="nav-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-%F0%9F%92%A3"><span class="nav-text">剑指 Offer 33. 二叉搜索树的后序遍历序列 💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%F0%9F%92%A3"><span class="nav-text">剑指 Offer 34. 二叉树中和为某一值的路径💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%F0%9F%92%A3"><span class="nav-text">剑指 Offer 36. 二叉搜索树与双向链表💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%F0%9F%92%A3"><span class="nav-text">剑指 Offer 37. 序列化二叉树💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">剑指 Offer 55 - I. 二叉树的深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">剑指 Offer 55 - II. 平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B8%AD%E7%AD%89"><span class="nav-text">剑指 Offer 20. 表示数值的字符串  中等</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%9B%9E%E6%BA%AF-amp-DFS-BFS"><span class="nav-text">（2）回溯&amp;DFS_BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">剑指 Offer 12. 矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">剑指 Offer 13. 机器人的运动范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-text">剑指 Offer 17. 打印从1到最大的n位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%F0%9F%92%A3"><span class="nav-text">剑指 Offer 38. 字符串的排列💣</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%B4%AA%E5%BF%83"><span class="nav-text">（3）贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-14-I-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-text">剑指 Offer 14- I. 剪绳子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-14-II-%E5%89%AA%E7%BB%B3%E5%AD%90-II-%F0%9F%92%A3"><span class="nav-text">剑指 Offer 14- II. 剪绳子 II 💣</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">（4）双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-text">剑指 Offer 05. 替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-text">23.链表中环的入口结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%F0%9F%92%A3%F0%9F%92%A3"><span class="nav-text">剑指 Offer 51. 数组中的逆序对💣💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 57. 和为s的两个数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-text">剑指 Offer 57 - II. 和为s的连续正数序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8C%E5%88%86"><span class="nav-text">（5）二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97-%E5%90%8C154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II"><span class="nav-text">剑指 Offer 11. 旋转数组的最小数字 同154.寻找旋转排序数组中的最小值 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">剑指 Offer 16. 数值的整数次方 快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I%E2%AD%90%EF%B8%8F"><span class="nav-text">剑指 Offer 53 - I. 在排序数组中查找数字 I⭐️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E2%AD%90%EF%B8%8F"><span class="nav-text">剑指 Offer 53 - II. 0～n-1中缺失的数字⭐️</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%886%EF%BC%89DP"><span class="nav-text">（6）DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">剑指 Offer 10- I. 斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96"><span class="nav-text">矩阵覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%F0%9F%80%84%EF%B8%8F"><span class="nav-text">剑指 Offer 10- II. 青蛙跳台阶问题🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">进阶跳台阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%F0%9F%92%A3"><span class="nav-text">剑指 Offer 19. 正则表达式匹配  💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">剑指 Offer 42. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">剑指 Offer 46. 把数字翻译成字符串 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-text">剑指 Offer 47. 礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0"><span class="nav-text">剑指 Offer 49. 丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%F0%9F%92%A3"><span class="nav-text">剑指 Offer 60. n个骰子的点数💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-text">剑指 Offer 63. 股票的最大利润</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">（7）数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%A8%A1%E6%8B%9F"><span class="nav-text">7.1 模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 03. 数组中重复的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">剑指 Offer 29. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E7%89%88%EF%BC%9A%E5%85%88%E9%A1%BA%E6%97%B6%E9%92%88%E5%86%8D%E9%80%86%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0"><span class="nav-text">改进版：先顺时针再逆时针打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-text">剑指 Offer 45. 把数组排成最小的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-text">剑指 Offer 58 - I. 翻转单词顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-2%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">58.2左旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-text">剑指 Offer 66. 构建乘积数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="nav-text">剑指 Offer 67. 把字符串转换成整数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">7.2 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-text">剑指 Offer 06. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">剑指 Offer 09. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-text">剑指 Offer 30. 包含min函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-text">剑指 Offer 31. 栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">剑指 Offer 59 - I. 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">剑指 Offer 59 - II. 队列的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">剑指 Offer 41. 数据流中的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-2%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-text">41.2字符流中第一个不重复的字符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">7.3 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6-%E2%9A%A0%EF%B8%8F"><span class="nav-text">剑指 Offer 50. 第一个只出现一次的字符 ⚠️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-text">剑指 Offer 61. 扑克牌中的顺子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E9%93%BE%E8%A1%A8"><span class="nav-text">7.4 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-text">18.2删除链表中重复的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">剑指 Offer 24. 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%F0%9F%92%A3"><span class="nav-text">剑指 Offer 35. 复杂链表的复制💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">7.5 位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">剑指 Offer 15. 二进制中1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%F0%9F%92%A3"><span class="nav-text">剑指 Offer 56 - I. 数组中数字出现的次数💣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II"><span class="nav-text">剑指 Offer 56 - II. 数组中数字出现的次数 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n"><span class="nav-text">剑指 Offer 64. 求1+2+…+n</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-text">剑指 Offer 65. 不用加减乘除做加法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E6%8E%92%E5%BA%8F"><span class="nav-text">7.6 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-text">剑指 Offer 40. 最小的k个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0-1"><span class="nav-text">剑指 Offer 45. 把数组排成最小的数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E6%95%B0%E5%AD%A6"><span class="nav-text">（8）数学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97-%E7%BA%A6%E7%91%9F%E7%8E%AF"><span class="nav-text">剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-43-1%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">剑指 Offer 43. 1～n 整数中 1 出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 44. 数字序列中某一位的数字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TOT100"><span class="nav-text">TOT100</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HOP150"><span class="nav-text">HOP150</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChaoZhong Zhang"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">ChaoZhong Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/ZhangXiaoyu_sy" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;ZhangXiaoyu_sy" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangChaoZhong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangChaoZhong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zczindex@gmail.com" title="E-Mail → zczindex@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChaoZhong Zhang
  </span>
  <span class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LitCJHzcYDrw3V694F5ykefU-9Nh9j0Va',
      appKey     : 'xrhUoMdaVndszRNhqsBy6jni',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
