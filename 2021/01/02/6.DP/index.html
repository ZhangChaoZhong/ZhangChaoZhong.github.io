<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="d4_pdYcNwIYae3EhA8wFzZvB6zxWe5KWfSnaliXR-Rc" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangchaozhong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="6. DP(一) 1.确定dp数组以及下标的含义2.确定转移方程3.dp数组初始化4.确定遍历顺序5.举例推导">
<meta property="og:type" content="article">
<meta property="og:title" content="6.DP">
<meta property="og:url" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/index.html">
<meta property="og:site_name" content="生于九六年晚冬">
<meta property="og:description" content="6. DP(一) 1.确定dp数组以及下标的含义2.确定转移方程3.dp数组初始化4.确定遍历顺序5.举例推导">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211022223803669.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211008224812645.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20211008225718378.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211006235824952.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210608210105555.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210611230159775.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211019170438187.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211009202901971.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/20210117171307407.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210330110645464.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210330125318496.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211022230148139.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211022221506617.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/006eb5E0gy1g7z0e5ghloj31150fw0ub.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210330214658423.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210330214742786.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210330215834022.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210813162608191.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210813162640327.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20210812100300618.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210812101125269.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/Users/zcz/Desktop/images/image-20210812101713646.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210812102323894.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210813162901260.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210813162843069.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210813162930157.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20210701155141042.png">
<meta property="article:published_time" content="2021-01-02T13:35:00.000Z">
<meta property="article:modified_time" content="2022-01-02T13:51:42.000Z">
<meta property="article:author" content="ChaoZhong Zhang">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangchaozhong.github.io/2021/01/02/6.DP/image-20211022223803669.png">

<link rel="canonical" href="https://zhangchaozhong.github.io/2021/01/02/6.DP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>6.DP | 生于九六年晚冬</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生于九六年晚冬</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangchaozhong.github.io/2021/01/02/6.DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="ChaoZhong Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生于九六年晚冬">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.DP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 21:35:00" itemprop="dateCreated datePublished" datetime="2021-01-02T21:35:00+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-02 21:51:42" itemprop="dateModified" datetime="2022-01-02T21:51:42+08:00">2022-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/02/6.DP/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/02/6.DP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="6-DP-一"><a href="#6-DP-一" class="headerlink" title="6. DP(一)"></a>6. DP(一)</h1><blockquote>
<p>1.确定dp数组以及下标的含义<br>2.确定转移方程<br>3.dp数组初始化<br>4.确定遍历顺序<br>5.举例推导</p>
</blockquote>
<span id="more"></span>

<h3 id="1-滚动数组"><a href="#1-滚动数组" class="headerlink" title="(1)滚动数组"></a>(1)滚动数组</h3><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//sum:f(n) a:f(n-2) b:f(n-1)</span></span><br><span class="line">            sum = (a+b)%<span class="number">100000007</span>;      <span class="comment">//执行n-1次</span></span><br><span class="line">            a = b;</span><br><span class="line">            b =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b =c;</span><br><span class="line">            c =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum=<span class="number">0</span>; <span class="comment">//0阶当作1</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b; </span><br><span class="line">            b = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="746-使用最小花费爬楼梯🀄️"><a href="#746-使用最小花费爬楼梯🀄️" class="headerlink" title="746. 使用最小花费爬楼梯🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211022223803669.png" alt="image-20211022223803669"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;    <span class="comment">//第0，1阶都可以作为起始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">min</span>(a+cost[i<span class="number">-2</span>],b+cost[i<span class="number">-1</span>]);<span class="comment">//向上爬一个阶梯或者爬两个阶梯</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-打家劫舍系列🀄️"><a href="#2-打家劫舍系列🀄️" class="headerlink" title="(2)打家劫舍系列🀄️"></a>(2)打家劫舍系列🀄️</h3><h5 id="198-打家劫舍🀄️"><a href="#198-打家劫舍🀄️" class="headerlink" title="198. 打家劫舍🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="213-打家劫舍-II🀄️"><a href="#213-打家劫舍-II🀄️" class="headerlink" title="213. 打家劫舍 II🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房子围成一圈</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(),nums.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums2</span><span class="params">(nums.begin()+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">work</span>(nums1),<span class="built_in">work</span>(nums2));<span class="comment">//1.抢头，不抢尾 2.不抢头，抢尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="337-打家劫舍-III🀄️"><a href="#337-打家劫舍-III🀄️" class="headerlink" title="337. 打家劫舍 III🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一棵二叉树</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">动态规划：</span></span><br><span class="line"><span class="comment">我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 下标0 代表不偷，1 代表偷</span></span><br><span class="line"><span class="comment">任何一个节点能偷到的最大钱的状态可以定义为</span></span><br><span class="line"><span class="comment">    当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</span></span><br><span class="line"><span class="comment">    当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;   </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; l=<span class="built_in">dp</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; r=<span class="built_in">dp</span>(root-&gt;right);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="built_in">max</span>(l[<span class="number">0</span>],l[<span class="number">1</span>])+<span class="built_in">max</span>(r[<span class="number">0</span>],r[<span class="number">1</span>]);<span class="comment">//不抢</span></span><br><span class="line">        res[<span class="number">1</span>] = l[<span class="number">0</span>]+r[<span class="number">0</span>]+root-&gt;val;<span class="comment">//抢</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res= <span class="built_in">dp</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) maxVal = <span class="built_in">max</span>(val,maxVal);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(maxVal+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) sum[val] += val; <span class="comment">//按顺序存,统计所有相同元素之和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rob</span>(sum);</span><br><span class="line">        <span class="comment">//若选择了x，则可以获取 sum[x] 的点数，且无法再选择 x−1和 x+1，这与打家劫舍一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-股票系列"><a href="#3-股票系列" class="headerlink" title="(3)股票系列"></a>(3)股票系列</h3><h4 id="121-买卖股票的最佳时机🀄️"><a href="#121-买卖股票的最佳时机🀄️" class="headerlink" title="121. 买卖股票的最佳时机🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211008224812645.png" alt="image-20211008224812645"></p>
<p><img src="/Users/zcz/Desktop/images/image-20211008225718378.png" alt="image-20211008225718378"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  - prices[i]);<span class="comment">//今天持股：1.今天什么都不做 2.今天买入（只允许1次，所以是第一次买入）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="122-买卖股票的最佳时机-II🀄️"><a href="#122-买卖股票的最佳时机-II🀄️" class="headerlink" title="122. 买卖股票的最佳时机 II🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以多次交易</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);	<span class="comment">//今天持股：1.昨天持股，今天什么都不做 2.昨天没有持股，今天买入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-最大子数组和系列"><a href="#4-最大子数组和系列" class="headerlink" title="(4)最大子数组和系列"></a>(4)最大子数组和系列</h3><h4 id="53-最大子序和🀄️"><a href="#53-最大子序和🀄️" class="headerlink" title="53. 最大子序和🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            prev = <span class="built_in">max</span>(prev+it,it); <span class="comment">// f(i) = max(f(i-1)+nums[i],nums[i])</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,prev);    <span class="comment">// max&#123;f(n)&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//maxSum最大和 minSum最小和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum=nums[<span class="number">0</span>],minSum=nums[<span class="number">0</span>],pre1=<span class="number">0</span>,pre2=<span class="number">0</span>,arrSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            arrSum+=num;</span><br><span class="line">            pre1=num&gt;pre1+num?num:pre1+num;</span><br><span class="line">            maxSum=maxSum&gt;pre1?maxSum:pre1;</span><br><span class="line">          </span><br><span class="line">            pre2=num&lt;pre2+num?num:pre2+num;</span><br><span class="line">            minSum=minSum&lt;pre2?minSum:pre2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxSum&lt;<span class="number">0</span>)&#123;      <span class="comment">//第三种情况，全部负数</span></span><br><span class="line">            <span class="keyword">return</span> maxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第2种情况，在两端：arrSum-minSum；第一种情况：在中间maxSum,就跟53题一样</span></span><br><span class="line">        <span class="keyword">return</span> arrSum-minSum&gt;maxSum?arrSum-minSum:maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于第 i 个状态只和第 i−1个状态相关，根据「滚动数组」思想</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = maxF, mn = minF;</span><br><span class="line">            maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>(nums[i], mn * nums[i]));<span class="comment">//三种情况</span></span><br><span class="line">            minF = <span class="built_in">min</span>(mx * nums[i], <span class="built_in">min</span>(nums[i], mn * nums[i]));</span><br><span class="line">            res = <span class="built_in">max</span>(maxF, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1567-乘积为正数的最长子数组长度"><a href="#1567-乘积为正数的最长子数组长度" class="headerlink" title="1567. 乘积为正数的最长子数组长度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">1567. 乘积为正数的最长子数组长度</a></h4><p><img src="/2021/01/02/6.DP/image-20211006235824952.png" alt="image-20211006235824952"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> positive = (nums[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> negative = (nums[<span class="number">0</span>] &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLength = positive;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;  <span class="comment">//不变</span></span><br><span class="line">                ++positive;</span><br><span class="line">                negative = (negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">//全部取反</span></span><br><span class="line">                <span class="keyword">int</span> newPositive = negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> newNegative = positive + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">tie</span>(positive, negative) = &#123;newPositive, newNegative&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                positive = negative = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, positive);  <span class="comment">//乘积为正数的最长子数组长度</span></span><br><span class="line">            <span class="comment">//maxLength = max(maxLength, negative);//乘积为负数的最长子数组长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mx = values[<span class="number">0</span>] + <span class="number">0</span>;    <span class="comment">//mx = values[i] + i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; values.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mx + values[j] - j); <span class="comment">//values[j] - j是固定不变的</span></span><br><span class="line">            <span class="comment">// 边遍历边维护</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, values[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-单串-LIS-系列🀄️"><a href="#5-单串-LIS-系列🀄️" class="headerlink" title="(5)单串 LIS 系列🀄️"></a>(5)单串 LIS 系列🀄️</h3><h5 id="300-最长递增子序列🀄️"><a href="#300-最长递增子序列🀄️" class="headerlink" title="300. 最长递增子序列🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210608210105555.png" alt="image-20210608210105555"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);<span class="comment">//没有减，所以下标为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());<span class="comment">//取里面最大的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心+二分</span></span><br><span class="line"><span class="comment">//T:O(nlogn) S:O(n)</span></span><br><span class="line"> <span class="comment">//如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">//d数组单调递增</span></span><br><span class="line">        d[len] = nums[<span class="number">0</span>];           <span class="comment">//d[1] =nums[0]初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;   </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123; <span class="comment">//d数组的数尽可能小</span></span><br><span class="line">                d[++len] = nums[i]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">//所有的数不小于nums[i] ，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123; <span class="comment">//在d数组中寻找比nums[i]小的</span></span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="673-最长递增子序列的个数🀄️"><a href="#673-最长递增子序列的个数🀄️" class="headerlink" title="673. 最长递增子序列的个数🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210611230159775.png" alt="image-20210611230159775"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)  S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">      	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;	</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(dp[j]+<span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                      	dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])<span class="comment">//长度一样的</span></span><br><span class="line">                    	cnt[i] += cnt[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">int</span> max_length = *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">      	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == max_length)</span><br><span class="line">          	    res +=cnt[i]; </span><br><span class="line">        <span class="keyword">return</span> res;	</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//贪心 + 前缀和 + 二分查找   T:O(nlogn) S:O(n)</span></span><br></pre></td></tr></table></figure>

<h5 id="354-俄罗斯套娃信封问题🀄️"><a href="#354-俄罗斯套娃信封问题🀄️" class="headerlink" title="354. 俄罗斯套娃信封问题🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/russian-doll-es/">354. 俄罗斯套娃信封问题</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 因为我们在找第 i 件物品的前一件物品时，会对前面的 i - 1 件物品都遍历一遍，因此第二维（高度）排序与否都不影响</span></span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;	<span class="comment">//找下界</span></span><br><span class="line">                <span class="keyword">if</span> (es[j][<span class="number">1</span>] &lt; es[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法2:二分+动态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;es[<span class="number">0</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> num = es[i][<span class="number">1</span>]; num &gt; dp.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), num);</span><br><span class="line">                *it = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-贪心数组"><a href="#6-贪心数组" class="headerlink" title="(6)贪心数组"></a>(6)贪心数组</h3><h5 id="55-跳跃游戏🀄️"><a href="#55-跳跃游戏🀄️" class="headerlink" title="55. 跳跃游戏🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;  <span class="comment">//实时维护 最远可以到达的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;   <span class="comment">// x+nums[x]≥y, x本身可以到达</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);    </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="45-跳跃游戏-II🀄️"><a href="#45-跳跃游戏-II🀄️" class="headerlink" title="45. 跳跃游戏 II🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</span></span><br><span class="line"><span class="comment">在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123; <span class="comment">//当前i可以到达r</span></span><br><span class="line">                    end = r;	<span class="comment">//更新边界</span></span><br><span class="line">                    ++step;<span class="comment">//每过一个边界+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-带维度单串-dp-i-k"><a href="#7-带维度单串-dp-i-k" class="headerlink" title="(7)带维度单串 dp[i] [k]"></a>(7)带维度单串 dp[i] [k]</h3><h4 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="1478-安排邮筒"><a href="#1478-安排邮筒" class="headerlink" title="1478. 安排邮筒"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/allocate-mailboxes/">1478. 安排邮筒</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数，前缀和维护状态转移时的查询</span><br></pre></td></tr></table></figure>



<h4 id="1230-抛掷硬币"><a href="#1230-抛掷硬币" class="headerlink" title="1230. 抛掷硬币"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toss-strange-coins/">1230. 抛掷硬币</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是份数</span></span><br></pre></td></tr></table></figure>

<h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是次数，k 上有二分</span></span><br></pre></td></tr></table></figure>

<h4 id="975-奇偶跳"><a href="#975-奇偶跳" class="headerlink" title="975. 奇偶跳"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-jump/">975. 奇偶跳</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示当前的奇偶状态</span></span><br></pre></td></tr></table></figure>



<h4 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示上一步的跳的步数</span></span><br></pre></td></tr></table></figure>

<h4 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256. 粉刷房子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paint-house/">256. 粉刷房子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265. 粉刷房子 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paint-house-ii/">265. 粉刷房子 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— 有两个指标 k 颜色；t 街区数</span></span><br></pre></td></tr></table></figure>

<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)</span></span><br><span class="line"><span class="comment">/*暴力 O(n^3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	for(n)</span></span><br><span class="line"><span class="comment">		for(n)&#123;</span></span><br><span class="line"><span class="comment">			isVaild(n)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">//()()相邻匹配，</span></span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">// ()(()) 2:自身   dp[i - dp[i - 1] - 2]：外部  dp[i-1]：内部</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211019170438187.png" alt="image-20211019170438187"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n));  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;       <span class="comment">//每个字符的最大长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-双串"><a href="#8-双串" class="headerlink" title="(8)双串"></a><strong>(8)双串</strong></h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211009202901971.png" alt="image-20211009202901971"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp"><a href="#712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp" class="headerlink" title="712. 两个字符串的最小ASCII删除和 —— LCS，len 和 ascii 各一个 dp"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a> —— LCS，len 和 ascii 各一个 dp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别</p>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1923-最长公共子路径-718题的扩展"><a href="#1923-最长公共子路径-718题的扩展" class="headerlink" title="1923. 最长公共子路径 718题的扩展"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subpath/">1923. 最长公共子路径</a> 718题的扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双串问题：字符串匹配系列"><a href="#双串问题：字符串匹配系列" class="headerlink" title="双串问题：字符串匹配系列"></a>双串问题：字符串匹配系列</h3><h4 id="72"><a href="#72" class="headerlink" title="[72. )"></a>[72. )</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通配符匹配</li>
</ul>
<h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h4><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双串问题：其它双串-dp-i-j-问题"><a href="#双串问题：其它双串-dp-i-j-问题" class="headerlink" title="双串问题：其它双串 dp[i] [j] 问题"></a>双串问题：其它双串 dp[i] [j] 问题</h3><ul>
<li>交错字符串</li>
<li>不同的子序列</li>
</ul>
<h3 id="双串问题：带维度双串-dp-i-j-k"><a href="#双串问题：带维度双串-dp-i-j-k" class="headerlink" title="双串问题：带维度双串 dp[i] [j] [k]"></a>双串问题：带维度双串 dp[i] [j] [k]</h3><ul>
<li>扰乱字符串</li>
</ul>
<h3 id="9-矩阵"><a href="#9-矩阵" class="headerlink" title="(9)矩阵"></a><strong>(9)矩阵</strong></h3><p>矩阵 dp[i] [j]</p>
<ul>
<li>三角形最小路径和</li>
<li>最小路径和</li>
<li>地下城游戏</li>
<li>下降路径最小和</li>
<li>最大正方形</li>
<li>下降路径最小和  II</li>
</ul>
<p>矩阵 dp[i] [j] [k]</p>
<p>最大矩形</p>
<ul>
<li>矩形区域不超过 K 的最大数值和 —— k 为宽度</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移</li>
</ul>
<p>无串线性问题</p>
<ul>
<li>只有两个键的键盘</li>
<li>丑数 II</li>
<li>完全平方数</li>
<li>整数拆分</li>
</ul>
<h3 id="10-前缀和-区间求和、子矩形求和"><a href="#10-前缀和-区间求和、子矩形求和" class="headerlink" title="(10)前缀和(区间求和、子矩形求和)"></a>(10)前缀和(区间求和、子矩形求和)</h3><p><strong>求区间和</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></p>
<p><strong>实现前缀和问题</strong></p>
<ul>
<li>区域和检索 - 数组不可变</li>
<li>二维区域和检索 - 矩阵不可变</li>
</ul>
<p><strong>数据结构维护前缀和</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p>
<p>数据结构维护前缀和问题：HashMap 维护（1）<br>HashMap 维护（1），键是前缀和（状态）的值，值为第一次出现时的索引。</p>
<ul>
<li>和等于 k 的最长子数组长度</li>
<li>连续数组</li>
<li>每个元音包含偶数次的最长子字符串 —— 前缀状态为 a,e,i,o,u 的个数的奇偶</li>
</ul>
<p>HashMap 维护（2），键是前缀和（前缀状态）的值，值为出现次数。</p>
<ul>
<li>和为 K 的子数组</li>
<li>统计优美子数组 —— 前缀状态为奇数的个数</li>
</ul>
<p>HashMap 维护（3），键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）。</p>
<ul>
<li>连续的子数组和 —— 值为第一次出现时的索引</li>
<li>和可被 K 整除的子数组 —— 值为出现次</li>
</ul>
<p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，例如下面这几道题。</p>
<ul>
<li>除自身以外数组的乘积</li>
<li>寻找数组的中心索引</li>
<li>找两个和为目标值且不重叠的子数组 —— 前缀和后缀和分别推一次，推的时候保存信息（DP），枚举分割点</li>
</ul>
<p>二维前缀和</p>
<ul>
<li>元素和为目标值的子矩阵数量</li>
<li>矩阵区域和</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K</li>
</ul>
<p>前缀积</p>
<ul>
<li>乘积最大子数组</li>
<li>乘积小于K的子数组</li>
<li>最后 K 个数的乘积 —— 若乘法的前缀积会溢出，可以用对数的前缀和防溢出，但是结果转回整数需要用四舍五入而不是下取整</li>
</ul>
<p>前缀异或</p>
<ul>
<li>子数组异或查询</li>
<li>形成两个异或相等数组的三元组数目 —— 哈希表维护前缀异或结果，类似 「560. 和为 K 的子数组」</li>
</ul>
<p>差分问题</p>
<ul>
<li>区间加法 —— 用差分维护区间加法模板</li>
</ul>
<h1 id="6-DP-二"><a href="#6-DP-二" class="headerlink" title="6.DP(二)"></a>6.DP(二)</h1><h2 id="1-背包DP"><a href="#1-背包DP" class="headerlink" title="(1)背包DP"></a><strong>(1)背包</strong>DP</h2><blockquote>
<p>背包问题是一种组合优化的 NP 完全问题：有 <em>N</em> 个物品和容量为<em>V</em> 的背包，每个物品都有自己的体积 v 和价值 w，求拿哪些物品可以使得背包所装下物品的总价值最大。<br>如果限定每种物品只能选择 0 个或 1 个，则问题称为 <u>0-1 背包问题</u>；<br>如果不限定每种物品的数量，则问题称为无界背包问题或<u>完全背包问题</u>。<br>如果每种物品的数量不一样，则问题称为<u>多重背包问题</u>。<br>如果每组有多种物品，每组只能选择1种，则问题称为<u>分组背包问题</u>。</p>
</blockquote>
<!--more-->

<p><strong>背包问题的分析步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析是否为背包问题。</span><br><span class="line">1)是背包问题三种问法中的哪一种。</span><br><span class="line">2)0-1 背包问题还是完全背包问题，即求最值。</span><br><span class="line">也就是题目给的 nums 数组中的元素是否可以重复使用。</span><br><span class="line">3)如果是组合问题，即求方案数，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法，需要注意。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html">背包问题总结篇</a></p>
<p><img src="/2021/01/02/6.DP/20210117171307407.png" alt="416.分割等和子集1"></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="/2021/01/02/6.DP/image-20210330110645464.png" alt="image-20210330110645464"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], 前i个物品且体积&lt;=j时的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">             <span class="comment">// 能装，需要决策选与不选第 i 个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];	<span class="comment">// 体积,价值</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//先遍历物品，再遍历背包</span></span><br><span class="line">      <span class="comment">//如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙保证物品i只被放入一次，防止dp[i]加上计算过的dp[i-1]</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么一维情况下枚举背包容量需要逆序？</span></span><br><span class="line"><span class="comment">一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题理论基础二维dp数组</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题理论基础一维dp数组（滚动数组）</a></p>
<h4 id="416-分割等和子集🀄️"><a href="#416-分割等和子集🀄️" class="headerlink" title="416. 分割等和子集🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1)dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123; </span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<span class="comment">//(2)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有两个维度的01背包</span></span><br><span class="line"><span class="comment">//(1)dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// (3)默认初始化0</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// (4)遍历物品</span></span><br><span class="line">            <span class="keyword">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeroNum; i--) &#123; <span class="comment">// 遍历背包容量且从后向前遍历！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>###完全背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:朴素做法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k*v[i]&lt;=j ; k++)	<span class="comment">//体积最大j</span></span><br><span class="line">              f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/6.DP/image-20210330125318496.png" alt="image-20210330125318496"></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:优化</span></span><br><span class="line"><span class="comment">先遍历物品，后遍历背包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i] ; j&lt;=m ;j++) <span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">              f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换🀄️"><a href="#322-零钱兑换🀄️" class="headerlink" title="322. 零钱兑换🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题 T:O(amount*coins)  S:O(amount)   amount:总金额，coins为硬币数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;    <span class="comment">//dp[i]代表金额i所需最少的硬币个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;                          <span class="comment">//金额0所需要的0个硬币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=amount;i++)&#123;	<span class="comment">//⚠️先遍历金额</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;<span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)&#123;  <span class="comment">//当前金额i必须&gt;=j，才可以兑换</span></span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II🀄️"><a href="#518-零钱兑换-II🀄️" class="headerlink" title="518. 零钱兑换 II🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案问题 T:O(amount*coins)  S:O(amount)   amount:总金额(背包)，coins为硬币数</span></span><br><span class="line"><span class="comment">//同原始 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;   <span class="comment">//dp[i]代表金额i的方案数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;                    <span class="comment">//金额0所需要的0个硬币,1个方案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;     <span class="comment">//⚠️先遍历面额，这样内循环遍历的金额都是按顺序的，不会重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin ; i&lt;=amount;i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><p><img src="/2021/01/02/6.DP/image-20211022230148139.png" alt="image-20211022230148139"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题  T:O(n∗sqrt(n))</span></span><br><span class="line"><span class="comment">//(1)dp[i]代表i用最少的平方数的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">// (3)默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;         <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;  <span class="comment">// (4)顺序遍历</span></span><br><span class="line">                dp[i] =<span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// (2)动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><p><img src="/2021/01/02/6.DP/image-20211022221506617.png" alt="image-20211022221506617"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="comment">//拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123; <span class="comment">//哈希表</span></span><br><span class="line">            dict.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i]表示字符串 s 前 i 个字符组成的字符串 s[0..i−1]是否能被空格拆分成若干个字典中出现的单词</span></span><br><span class="line">        vector &lt;<span class="keyword">bool</span>&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 前i个字符串[0..j-1] 子串：[j,i]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案数问题	T:O(targer*n) S:O(targer)</span></span><br><span class="line"><span class="comment">//（1）用 dp[i]表示选取的元素之和等于 i 的方案数</span></span><br><span class="line"><span class="comment">//nums数组就是物品，target就是背包，数字能否组成targer，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="进阶爬楼梯"><a href="#进阶爬楼梯" class="headerlink" title="进阶爬楼梯"></a>进阶爬楼梯</h4><p><strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html">动态规划：关于多重背包，你该了解这些！</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4/">4.多重背包问题 I</a></p>
<blockquote>
<p>一个基本思路是，将此问题转换为01背包求解！</p>
<p>比如物品1有3件，每件价值为2，我们不妨创建3个物品1，存在数组v和数组w中</p>
<p>最终更新一下总物品数n即可，然后套用01背包问题进行求解。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">朴素版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,n,m,dp[<span class="number">10005</span>]=&#123; &#125;,w,v,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s--)</span><br><span class="line">    &#123;a[++t]=v;</span><br><span class="line">    b[t]=w;&#125;<span class="comment">//死拆，把多重背包拆成01背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a[i];j--)</span><br><span class="line">    dp[j]=<span class="built_in">max</span>(dp[j-a[i]]+b[i],dp[j]);<span class="comment">//直接套01背包的板子</span></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优化版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>],n,m,v,w,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v;j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">5. 多重背包问题 II</a></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7z0e5ghloj31150fw0ub.png" alt="image.png"></p>
<p>思路和多重背包问题I一样，但这题的数据范围变成1000了，非优化写法时间复杂度O(n^3) 接近 1e9</p>
<p>必超时。</p>
<p><img src="/2021/01/02/6.DP/image-20210330214658423.png" alt="image-20210330214658423"></p>
<p><img src="/2021/01/02/6.DP/image-20210330214742786.png" alt="image-20210330214742786"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N],n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;good&gt; Good;</span><br><span class="line">    good tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="comment">//坑,k &lt;= s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= s ; k*=<span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            Good.<span class="built_in">push_back</span>(&#123;k*w,k*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) Good.<span class="built_in">push_back</span>(&#123;s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包优化+二进制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : Good)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= t.v ; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j] , dp[j-t.v]+t.w ); <span class="comment">//这里就是dp[j]</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/6/">6. 多重背包问题 III</a></p>
<p><strong>(单调队列优化) O(NV)</strong></p>
<p>一共 n 类物品，背包的容量是 m</p>
<p>每类物品的体积为v, 价值为w，个数为s</p>
<p>我们先来回顾一下传统的dp方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(不放入物品 i，放入<span class="number">1</span>个物品 i，放入<span class="number">2</span>个物品 i, ... , 放入k个物品 i)</span><br><span class="line">这里 k 要满足：k &lt;= s, j - k*v &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">不放物品  i = dp[i<span class="number">-1</span>][j]</span><br><span class="line">放k个物品 i = dp[i<span class="number">-1</span>][j - k*v] + k*w</span><br><span class="line"></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v] + w, dp[i<span class="number">-1</span>][j<span class="number">-2</span>*v] + <span class="number">2</span>*w,..., dp[i<span class="number">-1</span>][j-k*v] + k*w)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">实际上我们并不需要二维的dp数组，适当的调整循环条件，我们可以重复利用dp数组来保存上一轮的信息</span><br><span class="line"></span><br><span class="line">我们令 dp[j] 表示容量为j的情况下，获得的最大价值</span><br><span class="line">那么，针对每一类物品 i ，我们都更新一下 dp[m] --&gt; dp[<span class="number">0</span>] 的值，最后 dp[m] 就是一个全局最优值</span><br><span class="line"></span><br><span class="line">dp[m] = <span class="built_in">max</span>(dp[m], dp[m-v] + w, dp[m<span class="number">-2</span>*v] + <span class="number">2</span>*w, dp[m<span class="number">-3</span>*v] + <span class="number">3</span>*w, ...)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">显而易见，m 一定等于 k*v + j，其中  <span class="number">0</span> &lt;= j &lt; v</span><br><span class="line">所以，我们可以把 dp 数组分成 j 个类，每一类中的值，都是在同类之间转换得到的</span><br><span class="line">也就是说，dp[k*v+j] 只依赖于 &#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125;</span><br><span class="line"></span><br><span class="line">因为我们需要的是&#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125; 中的最大值，</span><br><span class="line">可以通过维护一个单调队列来得到结果。这样的话，问题就变成了 j 个单调队列的问题</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">所以，我们可以得到</span><br><span class="line">dp[j]    =     dp[j]</span><br><span class="line">dp[j+v]  = <span class="built_in">max</span>(dp[j] +  w,  dp[j+v])</span><br><span class="line">dp[j+<span class="number">2</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">2</span>w,  dp[j+v] +  w, dp[j+<span class="number">2</span>v])</span><br><span class="line">dp[j+<span class="number">3</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">3</span>w,  dp[j+v] + <span class="number">2</span>w, dp[j+<span class="number">2</span>v] + w, dp[j+<span class="number">3</span>v])</span><br><span class="line">...</span><br><span class="line">但是，这个队列中前面的数，每次都会增加一个 w ，所以我们需要做一些转换</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">单调队列问题，最重要的两点</span><br><span class="line"><span class="number">1</span>）维护队列元素的个数，如果不能继续入队，弹出队头元素</span><br><span class="line"><span class="number">2</span>）维护队列的单调性，即：尾值 &gt;= dp[j + k*v] - k*w</span><br><span class="line"></span><br><span class="line">本题中，队列中元素的个数应该为 s+<span class="number">1</span> 个，即 <span class="number">0</span> -- s 个物品 i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], pre[N], q[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= m; k += v) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - s*v &gt; q[head])</span><br><span class="line">                    ++head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] - (q[tail] - j)/v * w &lt;= pre[k] - (k - j)/v * w)</span><br><span class="line">                    --tail;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head])/v * w);</span><br><span class="line"></span><br><span class="line">                q[++tail] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/9/">9. 分组背包问题</a></p>
<p><img src="/2021/01/02/6.DP/image-20210330215834022.png" alt="image-20210330215834022"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];  <span class="comment">//只从前i组物品中选，当前体积小于等于j的最大值</span></span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];   <span class="comment">//v为体积，w为价值，s代表第i组物品的个数</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123; <span class="comment">//第i组的第k个物品</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一维优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;    <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最值问题</strong></p>
<ul>
<li>零钱兑换（完全背包）</li>
<li>一和零（二维费用背包）</li>
<li>最后一块石头的重量 II —— 转换为01背包问题，使得背包剩余容量最小</li>
</ul>
<p>这道题是要求<strong>恰好取到背包容量</strong>的背包问题。</p>
<ul>
<li>分割等和子集（01 背包 - 要求恰好取到背包容量）</li>
</ul>
<p><strong>方案数问题</strong></p>
<p>这四道题是背包问题求方案数的题目，涉及到 01背包，完全背包的方案数问题。以及考虑顺序和不考虑顺序的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组合总和 Ⅳ —— 顺序不同的序列被视作不同的组合</span><br><span class="line">目标和 —— 01背包-求方案数</span><br><span class="line">零钱兑换 II —— 完全背包-求方案数</span><br><span class="line">盈利计划 —— 01背包-求方案数总价值有要求：有下限</span><br></pre></td></tr></table></figure>

<h2 id="2-状态压缩DP"><a href="#2-状态压缩DP" class="headerlink" title="(2)状态压缩DP"></a>(2)状态压缩DP</h2><p>安卓系统手势解锁<br>我能赢吗<br>不同路径 III —— 状态压缩 DP + 记忆化<br>划分为 k 个相等的子集 —— 状态压缩 DP + 记忆化<br>访问所有节点的最短路径 —— Floyd + 状态压缩 DP 求最短哈密顿路<br>最短超级串 —— 状态压缩 DP + DP 过程记录路径<br>优美的排列<br>骑士拨号器<br>参加考试的最大学生数<br>大礼包<br>贴纸拼词<br>按位与为零的三元组</p>
<h2 id="3-树形DP"><a href="#3-树形DP" class="headerlink" title="(3)树形DP"></a>(3)树形DP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-区间DP"><a href="#4-区间DP" class="headerlink" title="(4)区间DP"></a>(4)区间DP</h2><p><strong>回文相关问题</strong></p>
<ul>
<li>最长回文子串</li>
<li>回文子串</li>
<li>最长回文子序列</li>
<li>段式回文</li>
<li>统计不同回文子字符串</li>
<li>让字符串成为回文串的最少插入次数 —— 最长回文子序列</li>
</ul>
<p><strong>区间动态规划其它问题</strong></p>
<p>戳气球<br>移除盒子 —— 戳气球升级版，[i][j] 基础上加了一维 k 状态，k 是 j 右侧与 j 相同的元素个数, 记忆化<br>多边形三角剖分的最低得分<br>奇怪的打印机<br>合并石头的最低成本<br>预测赢家<br>编码最短长度的字符串</p>
<h2 id="5-计数DP"><a href="#5-计数DP" class="headerlink" title="(5)计数DP"></a>(5)计数DP</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths">62. 不同路径</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/paint-fence/">276. 栅栏涂色</a></p>
<p><strong>计数问题相关练习题</strong></p>
<ol>
<li>路径问题</li>
<li>卡特兰数</li>
<li>铺砖问题</li>
<li>斐波那契</li>
<li>隐晦的递推关系</li>
</ol>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p>
<h2 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="(6)数位DP"></a>(6)数位DP</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p>
<p>以下 9 道题是力扣上数位 DP 相关的题目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满足某些条件的数字个数</span><br><span class="line">    最大为 N 的数字组合</span><br><span class="line">    中心对称数 III</span><br><span class="line">    计算各个位数不同的数字个数</span><br><span class="line">    不含连续 1 的非负整数</span><br><span class="line">    至少有 1 位重复的数字</span><br><span class="line">    易混淆数 II</span><br><span class="line"></span><br><span class="line">将 x∈[L,R]x \in [L, R]x∈[L,R] 代到一个函数 f(x) 中, 一个数字 x 的 f(x) 值为一次贡献的量, 求总的贡献</span><br><span class="line">    数字 1 的个数</span><br><span class="line">    范围内的数字计数</span><br><span class="line">    2 出现的次数</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-10-II-青蛙跳台阶问题🀄️"><a href="#剑指-Offer-10-II-青蛙跳台阶问题🀄️" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20210813162608191.png" alt="image-20210813162608191"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162640327.png" alt="image-20210813162640327"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(x,pre+x);	<span class="comment">//⚠️当前x 或者 x加上之前</span></span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-46-把数字翻译成字符串-🀄️"><a href="#剑指-Offer-46-把数字翻译成字符串-🀄️" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210812100300618.png" alt="image-20210812100300618"></p>
<p><img src="/2021/01/02/6.DP/image-20210812101125269.png" alt="image-20210812101125269"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T：O(n)</span></span><br><span class="line"><span class="comment">//S：用了滚动数组O(1)，但是这里用了一个临时变量把数字转化成了字符串，故渐进空间复杂度也是 O(log⁡n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            p =q;</span><br><span class="line">            q =r;</span><br><span class="line">            r =<span class="number">0</span>;</span><br><span class="line">            r += q; <span class="comment">//f(i-1)贡献</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String pre = str.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);    <span class="comment">//取i-1到i的子串</span></span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">                r+=p;   <span class="comment">//f(i-2)贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p><img src="/Users/zcz/Desktop/images/image-20210812101713646.png" alt="image-20210812101713646"></p>
<p><img src="/2021/01/02/6.DP/image-20210812102323894.png" alt="image-20210812102323894"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN)</span></span><br><span class="line"><span class="comment">//S:O(1) grid作为dp使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length; <span class="comment">//m行，n列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];              <span class="comment">//从左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];           <span class="comment">//从上</span></span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);<span class="comment">//从上或从左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设动态规划列表dp ，dp[i]代表第 i+1 个丑数；（下标从0开始的）</span></span><br><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="comment">//S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=dp[a]*<span class="number">2</span>,n2=dp[b]*<span class="number">3</span>,n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(n1,Math.min(n2,n3));</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字-约瑟环"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-约瑟环" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> 约瑟环</h4><p><img src="/2021/01/02/6.DP/image-20210813162901260.png" alt="image-20210813162901260"></p>
<p><img src="/2021/01/02/6.DP/image-20210813162843069.png" alt="image-20210813162843069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T:O(N) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;		<span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上往下推</span></span><br><span class="line">        <span class="keyword">return</span> (m + f(n - <span class="number">1</span>, m)) % n;		<span class="comment">//下一个删除的数   等价关系式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态 T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;		<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f = (m + f) % i;	<span class="comment">//⚠️从下往上推，从2开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162930157.png" alt="image-20210813162930157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);	<span class="comment">//min(prices[0:i])</span></span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-19-正则表达式匹配-困难"><a href="#剑指-Offer-19-正则表达式匹配-困难" class="headerlink" title="剑指 Offer 19. 正则表达式匹配  困难"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>  困难</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p><img src="/2021/01/02/6.DP/image-20210701155141042.png" alt="image-20210701155141042"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划+哈希</span></span><br><span class="line"><span class="comment">//由于返回值是取 dp列表最大值，因此可借助变量 tmp 存储 dp[j]</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div>
            
              <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

            
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="7.数据结构">
      <i class="fa fa-chevron-left"></i> 7.数据结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="next" title="5.二分查找">
      5.二分查找 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#6-DP-%E4%B8%80"><span class="nav-text">6. DP(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-text">(1)滚动数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">剑指 Offer 10- I. 斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-text">509. 斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1137-%E7%AC%AC-N-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-text">1137. 第 N 个泰波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%F0%9F%80%84%EF%B8%8F"><span class="nav-text">746. 使用最小花费爬楼梯🀄️</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%F0%9F%80%84%EF%B8%8F"><span class="nav-text">(2)打家劫舍系列🀄️</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%F0%9F%80%84%EF%B8%8F"><span class="nav-text">198. 打家劫舍🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II%F0%9F%80%84%EF%B8%8F"><span class="nav-text">213. 打家劫舍 II🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III%F0%9F%80%84%EF%B8%8F"><span class="nav-text">337. 打家劫舍 III🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#740-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0"><span class="nav-text">740. 删除并获得点数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97"><span class="nav-text">(3)股票系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%F0%9F%80%84%EF%B8%8F"><span class="nav-text">121. 买卖股票的最佳时机🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%F0%9F%80%84%EF%B8%8F"><span class="nav-text">122. 买卖股票的最佳时机 II🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="nav-text">123. 买卖股票的最佳时机 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="nav-text">188. 买卖股票的最佳时机 IV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-text">309. 最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="nav-text">714. 买卖股票的最佳时机含手续费</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%B3%BB%E5%88%97"><span class="nav-text">(4)最大子数组和系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%F0%9F%80%84%EF%B8%8F"><span class="nav-text">53. 最大子序和🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">918. 环形子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1567-%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-text">1567. 乘积为正数的最长子数组长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88"><span class="nav-text">1014. 最佳观光组合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8D%95%E4%B8%B2-LIS-%E7%B3%BB%E5%88%97%F0%9F%80%84%EF%B8%8F"><span class="nav-text">(5)单串 LIS 系列🀄️</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%F0%9F%80%84%EF%B8%8F"><span class="nav-text">300. 最长递增子序列🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0%F0%9F%80%84%EF%B8%8F"><span class="nav-text">673. 最长递增子序列的个数🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%F0%9F%80%84%EF%B8%8F"><span class="nav-text">354. 俄罗斯套娃信封问题🀄️</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%B4%AA%E5%BF%83%E6%95%B0%E7%BB%84"><span class="nav-text">(6)贪心数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%F0%9F%80%84%EF%B8%8F"><span class="nav-text">55. 跳跃游戏🀄️</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II%F0%9F%80%84%EF%B8%8F"><span class="nav-text">45. 跳跃游戏 II🀄️</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2-dp-i-k"><span class="nav-text">(7)带维度单串 dp[i] [k]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84"><span class="nav-text">813. 最大平均值和的分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1478-%E5%AE%89%E6%8E%92%E9%82%AE%E7%AD%92"><span class="nav-text">1478. 安排邮筒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1230-%E6%8A%9B%E6%8E%B7%E7%A1%AC%E5%B8%81"><span class="nav-text">1230. 抛掷硬币</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">410. 分割数组的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="nav-text">887. 鸡蛋掉落</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#975-%E5%A5%87%E5%81%B6%E8%B7%B3"><span class="nav-text">975. 奇偶跳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3"><span class="nav-text">403. 青蛙过河</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#256-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90"><span class="nav-text">256. 粉刷房子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#265-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-II"><span class="nav-text">265. 粉刷房子 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1473-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-III"><span class="nav-text">1473. 粉刷房子 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-text">32. 最长有效括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">647. 回文子串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%8F%8C%E4%B8%B2"><span class="nav-text">(8)双串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C-%E2%80%94%E2%80%94-LCS%EF%BC%8Clen-%E5%92%8C-ascii-%E5%90%84%E4%B8%80%E4%B8%AA-dp"><span class="nav-text">712. 两个字符串的最小ASCII删除和 —— LCS，len 和 ascii 各一个 dp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">718. 最长重复子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1923-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84-718%E9%A2%98%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">1923. 最长公共子路径 718题的扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%B8%B2%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%B3%BB%E5%88%97"><span class="nav-text">双串问题：字符串匹配系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#72"><span class="nav-text">[72. )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">剑指 Offer 19. 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">10. 正则表达式匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%B8%B2%E9%97%AE%E9%A2%98%EF%BC%9A%E5%85%B6%E5%AE%83%E5%8F%8C%E4%B8%B2-dp-i-j-%E9%97%AE%E9%A2%98"><span class="nav-text">双串问题：其它双串 dp[i] [j] 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%B8%B2%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8F%8C%E4%B8%B2-dp-i-j-k"><span class="nav-text">双串问题：带维度双串 dp[i] [j] [k]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%9F%A9%E9%98%B5"><span class="nav-text">(9)矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E3%80%81%E5%AD%90%E7%9F%A9%E5%BD%A2%E6%B1%82%E5%92%8C"><span class="nav-text">(10)前缀和(区间求和、子矩形求和)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-DP-%E4%BA%8C"><span class="nav-text">6.DP(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%83%8C%E5%8C%85DP"><span class="nav-text">(1)背包DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%F0%9F%80%84%EF%B8%8F"><span class="nav-text">416. 分割等和子集🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="nav-text">474. 一和零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-text">494. 目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="nav-text">1049. 最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%F0%9F%80%84%EF%B8%8F"><span class="nav-text">322. 零钱兑换🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II%F0%9F%80%84%EF%B8%8F"><span class="nav-text">518. 零钱兑换 II🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text">279. 完全平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text">进阶爬楼梯</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-text">分组背包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP"><span class="nav-text">(2)状态压缩DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A0%91%E5%BD%A2DP"><span class="nav-text">(3)树形DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8C%BA%E9%97%B4DP"><span class="nav-text">(4)区间DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AE%A1%E6%95%B0DP"><span class="nav-text">(5)计数DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%95%B0%E4%BD%8DDP"><span class="nav-text">(6)数位DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%F0%9F%80%84%EF%B8%8F"><span class="nav-text">剑指 Offer 10- II. 青蛙跳台阶问题🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">剑指 Offer 42. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">剑指 Offer 46. 把数字翻译成字符串 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-text">剑指 Offer 47. 礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0"><span class="nav-text">剑指 Offer 49. 丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97-%E7%BA%A6%E7%91%9F%E7%8E%AF"><span class="nav-text">剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-text">剑指 Offer 63. 股票的最大利润</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%E5%9B%B0%E9%9A%BE"><span class="nav-text">剑指 Offer 19. 正则表达式匹配  困难</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-text">剑指 Offer 60. n个骰子的点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 62. 圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChaoZhong Zhang"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">ChaoZhong Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangChaoZhong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangChaoZhong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zczindex@gmail.com" title="E-Mail → zczindex@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChaoZhong Zhang
  </span>
  <span class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LitCJHzcYDrw3V694F5ykefU-9Nh9j0Va',
      appKey     : 'xrhUoMdaVndszRNhqsBy6jni',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
