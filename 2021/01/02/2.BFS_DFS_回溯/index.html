<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="d4_pdYcNwIYae3EhA8wFzZvB6zxWe5KWfSnaliXR-Rc" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangchaozhong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="2.DFS&#x2F;BFS+回溯">
<meta property="og:type" content="article">
<meta property="og:title" content="2.DFS&#x2F;BFS+回溯">
<meta property="og:url" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/index.html">
<meta property="og:site_name" content="生于九六年晚冬">
<meta property="og:description" content="2.DFS&#x2F;BFS+回溯">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211126202127765.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211212102721764.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929200631155.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929190037482.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211211110937828.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929211741751.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211002001203923.png">
<meta property="og:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/1638328692-YrAjMu-1.png">
<meta property="article:published_time" content="2021-01-02T13:55:00.000Z">
<meta property="article:modified_time" content="2022-01-02T13:35:17.000Z">
<meta property="article:author" content="ChaoZhong Zhang">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211126202127765.png">

<link rel="canonical" href="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2.DFS/BFS+回溯 | 生于九六年晚冬</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生于九六年晚冬</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangchaozhong.github.io/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="ChaoZhong Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生于九六年晚冬">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2.DFS/BFS+回溯
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 21:55:00" itemprop="dateCreated datePublished" datetime="2021-01-02T21:55:00+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-02 21:35:17" itemprop="dateModified" datetime="2022-01-02T21:35:17+08:00">2022-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="2-DFS-BFS-回溯"><a href="#2-DFS-BFS-回溯" class="headerlink" title="2.DFS/BFS+回溯"></a>2.DFS/BFS+回溯</h1><span id="more"></span>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">模板</span><br><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line">def <span class="built_in">backtrack</span>(未探索区域, res, path):</span><br><span class="line">    <span class="keyword">if</span> 未探索区域满足结束条件:</span><br><span class="line">        res.<span class="built_in">add</span>(path) # 深度拷贝</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 未探索区域当前可能的选择:</span><br><span class="line">        <span class="keyword">if</span> 当前选择符合要求:</span><br><span class="line">            path.<span class="built_in">add</span>(作出选择)</span><br><span class="line">            <span class="built_in">backtrack</span>(新的未探索区域, res, path)</span><br><span class="line">            path.<span class="built_in">pop</span>() 撤销选择</span><br></pre></td></tr></table></figure>

<h4 id="131-分割回文串-🀄️"><a href="#131-分割回文串-🀄️" class="headerlink" title="131. 分割回文串 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(N∗2^N)  S:O(2^N)</span></span><br><span class="line"><span class="comment">思路：经典回溯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backTrack</span>(s,res,&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(string s,vector&lt;vector&lt;string&gt;&gt; &amp;res,vector&lt;string&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;              <span class="comment">//空串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);        <span class="comment">//直接加入结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;       <span class="comment">//1.遍历所有可能,从1开始</span></span><br><span class="line">            string pre=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);       <span class="comment">//当前子串  没有取到i</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(pre))&#123;                 <span class="comment">//2.满足</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(pre);        <span class="comment">//3.作出选择 加入</span></span><br><span class="line">                <span class="built_in">backTrack</span>(s.<span class="built_in">substr</span>(i),res,path);    <span class="comment">//4.递归 前面的i-1已经匹配，现从i取到结尾</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();        <span class="comment">//5.回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">0</span>,ed=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st &lt;= ed)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[st] != s[ed]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st++;ed--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">backTrace</span>(candidates, i, len, target - candidates[i]);<span class="comment">//递归,i⚠️当前数可以重复选择</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;x &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;	<span class="comment">//剪枝</span></span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i+<span class="number">1</span>, len, target - candidates[i]);<span class="comment">//递归，i+1</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());	<span class="comment">//为了去重</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211126202127765.png" alt="image-20211126202127765"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> k,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target &amp;&amp; output.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=(<span class="number">9</span> &gt; (target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>)?(target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>):<span class="number">9</span>);i++)&#123; <span class="comment">//剪枝</span></span><br><span class="line">            sum += i;</span><br><span class="line">            output.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,sum,k,target);</span><br><span class="line">            output.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">1</span>,<span class="number">0</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*2^n) S:O(n) </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;len;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,len,nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,len,nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原集合nums包含重复元素</span></span><br><span class="line"><span class="comment">//T:O(n*2^n) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;nums,vector&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//剪枝，去重⚠️</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);<span class="comment">//做出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,path,i+<span class="number">1</span>);<span class="comment">//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());  <span class="comment">//为了去重⚠️</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums不重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;	<span class="comment">//⚠️从0开始固定长度len</span></span><br><span class="line">            <span class="keyword">if</span> (vis[i]) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//⚠️递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums重复数字  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//没有访问过 不重复</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//s有重复 同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(string &amp;s,<span class="keyword">int</span> x,<span class="keyword">int</span> len,string &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(s[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(s,x+<span class="number">1</span>,len,path);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>(),path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A-Z 65-90 a-z 97-122  0-9 48-57</span></span><br><span class="line"><span class="comment">//搜索 T,S:O(N*2^N)   N字符串长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[x]))&#123;	<span class="comment">//数字直接回溯</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[x] = <span class="built_in">tolower</span>(s[x]);	<span class="comment">//回溯小写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">            s[x] = <span class="built_in">toupper</span>(s[x]);<span class="comment">//回溯大写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归全排列</span></span><br><span class="line"><span class="comment">//T：O(10^n) S:O(10^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">char</span> NUM[<span class="number">10</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成长度为 len 的数字，正在确定第x位（从左往右）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = x==<span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// X=0表示左边第一位数字，不能为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(NUM[i]); <span class="comment">// 确定本位数字</span></span><br><span class="line">            <span class="built_in">backtrack</span>(x+<span class="number">1</span>, len); <span class="comment">// 确定下一位数字</span></span><br><span class="line">            cur.<span class="built_in">pop_back</span>(); <span class="comment">// 删除本位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 数字长度：1~n</span></span><br><span class="line">            <span class="built_in">backtrack</span>(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_int;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res_int.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(res[i]));</span><br><span class="line">        <span class="keyword">return</span> res_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="comment">//使用哈希表存储字符串 s 的每个下标和从该下标开始的部分可以组成的句子列表，</span></span><br><span class="line"><span class="comment">//在回溯过程中如果遇到已经访问过的下标，则可以直接从哈希表得到结果，而不需要重复计算。</span></span><br><span class="line"><span class="comment">//T,S:O(n*2^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; res;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;  <span class="comment">//哈希表，加快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        wordSet = <span class="built_in">unordered_set</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">count</span>(x)) &#123;        <span class="comment">//没有存过，进入</span></span><br><span class="line">            <span class="keyword">if</span> (x == s.<span class="built_in">size</span>()) &#123;    </span><br><span class="line">                res[x] = &#123;<span class="string">&quot;&quot;</span>&#125;;      <span class="comment">//字符串末尾</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[x] = &#123;&#125;;</span><br><span class="line">          <span class="comment">//由于substr，因此i &lt;= s.size()⚠️</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(x, i - x);   <span class="comment">//从x开始，截取i-x个</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">count</span>(word)) &#123;  <span class="comment">//当前词是否在词典中</span></span><br><span class="line">                    <span class="built_in">backtrack</span>(s, i);        <span class="comment">//i可重复</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; succ: res[i]) &#123;</span><br><span class="line">                        res[x].<span class="built_in">push_back</span>(succ.<span class="built_in">empty</span>() ? word : word + <span class="string">&quot; &quot;</span> + succ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="267-回文排列-II"><a href="#267-回文排列-II" class="headerlink" title="267.回文排列  II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-permutation-ii/">267.回文排列  II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hours[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  <span class="comment">//从10个选num个</span></span><br><span class="line">    <span class="keyword">int</span> mins[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x,<span class="keyword">int</span> h,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">11</span> | m &gt;<span class="number">59</span>) <span class="keyword">return</span>;  <span class="comment">//不符合</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;   <span class="comment">//没有指示灯了</span></span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">6</span>];    <span class="comment">//注意这里要字符数组，不能是 string</span></span><br><span class="line">            <span class="built_in">sprintf</span>(tmp,<span class="string">&quot;%d:%02d&quot;</span>,h,m);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">backTrace</span>(num<span class="number">-1</span>,i+<span class="number">1</span>,h+hours[i],m+mins[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(num,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="200-岛屿数量-🀄️"><a href="#200-岛屿数量-🀄️" class="headerlink" title="200. 岛屿数量 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">思路：遍历整个地图的1，记得遍历过的1赋值为0，这样就不会重复访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;    <span class="comment">//4个方向</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)  <span class="comment">//遍历所有点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;  <span class="comment">//符合条件：dfs</span></span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= row|| j&lt;<span class="number">0</span> ||j &gt;= col || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;       <span class="comment">//遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;				<span class="comment">//遍历4个方向</span></span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j+ d[<span class="number">1</span>];	</span><br><span class="line">            <span class="built_in">dfs</span>(grid,x,y);			 <span class="comment">//没有越界 dfs</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(ROW*COl)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.<span class="built_in">size</span>() || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() ||grid[i][j] != <span class="number">1</span>)<span class="comment">//提前返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;	<span class="comment">//当前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            res += <span class="built_in">dfs</span>(grid,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(grid,i,j)); <span class="comment">//取最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS. T,S:O(nm)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//遍历过了</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;   </span><br><span class="line">            <span class="keyword">int</span> x=d[<span class="number">0</span>]+i,y=d[<span class="number">1</span>]+j;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid,x,y);   <span class="comment">//不用再判断 grid[i][j] == 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res += <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                  	<span class="comment">//res = max(res, dfs(grid,i,j));最大周长</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211212102721764.png" alt="image-20211212102721764"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*直接深搜：T：O(n^4)，超时</span></span><br><span class="line"><span class="comment">对于每个 0，将它变成 1，然后做一次深度优先搜索计算出连通块的大小。答案就是找到的最大连通块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以通过记录连通块编号来解决这个问题，不同的连通块编号不同。这样，我们就可以累加不同编号的连通块面积和。</span></span><br><span class="line"><span class="comment">T,S：O(n^2)，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图的连通数,T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="keyword">int</span>&gt; &amp;visited,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">      	visited[i] = <span class="literal">true</span>;		<span class="comment">//标记当前结点遍历过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;   <span class="comment">//遍历下一个j</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;<span class="comment">//当前是1，并且没有访问过</span></span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">//遍历i</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;    <span class="comment">//注意没有访问过</span></span><br><span class="line">              	res++;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/keys-and-rooms/">841. 钥匙和房间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n+m) S:O(n)  n 是房间的数量，m 是所有房间中的钥匙数量的总数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">bool</span>&gt; &amp;visited,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[x]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x] = <span class="literal">true</span>;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:rooms[x])&#123; <span class="comment">//遍历当前room[x]的所有钥匙</span></span><br><span class="line">            <span class="built_in">dfs</span>(visited,rooms,it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(visited,rooms,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="comment">//向下，右遍历：si，sj i，j各自的和。</span></span><br><span class="line"><span class="comment">//si等于9时,递归si+1，此时si=10,和为1，因此si-8=1，和也为1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, visited, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj, visited, m, n, k) +</span><br><span class="line">                   <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>, visited, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929200631155.png" alt="image-20210929200631155"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(m*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;	<span class="comment">//遍历过的赋值</span></span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=x+d[<span class="number">0</span>],ty=y+d[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(board,tx,ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">dfs</span>(board,i,<span class="number">0</span>),<span class="built_in">dfs</span>(board, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) <span class="built_in">dfs</span>(board, <span class="number">0</span>, i),<span class="built_in">dfs</span>(board, n - <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">//标志了，恢复了O</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆流而上。T，S：O(m*n)</span></span><br><span class="line"><span class="comment">//对于一个点它能流动两边的大洋，那么反过来，两边大洋的水反着流就能达到这个点。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; P, A, ans;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        n = M.<span class="built_in">size</span>(), m = M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        P = A = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//左右两边加上下两边出发深搜 ⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">dfs</span>(M, P, i, <span class="number">0</span>), <span class="built_in">dfs</span>(M, A, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">dfs</span>(M, P, <span class="number">0</span>, j), <span class="built_in">dfs</span>(M, A, n - <span class="number">1</span>, j);             </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i][j] &amp;&amp; A[i][j]) ans.<span class="built_in">push_back</span>(&#123;i,j&#125;); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt;<span class="number">0</span> || y&gt;=m || M[x][y] &lt; M[i][j]) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(M, visited, x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">欧拉路径：能否不走重复的路而遍历一个图的所有边。</span></span><br><span class="line"><span class="comment">Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</span></span><br><span class="line"><span class="comment">  从起点出发，进行深度优先搜索。</span></span><br><span class="line"><span class="comment">  每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</span></span><br><span class="line"><span class="comment">  如果没有可移动的路径，则将所在节点加入到栈中，并返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,priority_queue&lt;string,vector&lt;string&gt;,greater&lt;string&gt;&gt;&gt; map;    <span class="comment">//哈希表&lt;string,小根堆&gt;</span></span><br><span class="line">    vector&lt;string&gt; res;     <span class="comment">//结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">count</span>(cur) &amp;&amp; map[cur].<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;    <span class="comment">//遍历当前结点的所有下一个结点</span></span><br><span class="line">            string tmp = map[cur].<span class="built_in">top</span>();    <span class="comment">//取出下一个结点</span></span><br><span class="line">            map[cur].<span class="built_in">pop</span>();                 <span class="comment">//删除</span></span><br><span class="line">            <span class="built_in">dfs</span>(tmp);                       <span class="comment">//以下一个结点：dfs</span></span><br><span class="line">        &#125; </span><br><span class="line">        res.<span class="built_in">emplace_back</span>(cur);              <span class="comment">//将当前结点加入结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tk:tickets) map[tk[<span class="number">0</span>]].<span class="built_in">push</span>(tk[<span class="number">1</span>]); <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());	<span class="comment">//由于递归，结果集需要反转</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929190037482.png" alt="image-20210929190037482"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(m+n) S:O(n)</span></span><br><span class="line"><span class="comment">二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。(转化为图着色问题：连接的2点着色不同)</span></span><br><span class="line"><span class="comment">输入：graph = [[1,3],[0,2],[1,3],[0,2]]</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment">解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="keyword">int</span>&gt;&amp; color)</span> </span>&#123;</span><br><span class="line">        color[node] = c;<span class="comment">//u</span></span><br><span class="line">        <span class="keyword">int</span> next = (c == RED ? GREEN : RED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor: graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[neighbor] == UNCOLORED) &#123;  <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(neighbor, next, graph,color);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;   <span class="comment">//提前退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (color[neighbor] != next) &#123; <span class="comment">//当前节点不是设定好next</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(n,UNCOLORED)</span></span>;</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == UNCOLORED) &#123;    <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(i, RED, graph,color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="60-排列序列-第k个排列"><a href="#60-排列序列-第k个排列" class="headerlink" title="60. 排列序列 第k个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a> 第k个排列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N^2) S:O(N) </span></span><br><span class="line"><span class="comment">//思路：剪枝（已访问，k&gt;叶子结点数）+DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = f[n<span class="number">-1</span>-x]; <span class="comment">//叶子结点个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;    <span class="comment">//（1）剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; cnt) &#123; k -= cnt;<span class="keyword">continue</span>;&#125;   <span class="comment">//（2）剪枝</span></span><br><span class="line">            res += <span class="built_in">to_string</span>(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(n,k,x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不回溯，没有回头的过程</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//后面的数没有必要遍历去尝试了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vis = vector&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>);</span><br><span class="line">        f = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i] = f[i<span class="number">-1</span>]*i;</span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="254-因子的组合"><a href="#254-因子的组合" class="headerlink" title="254.因子的组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factor-combinations/">254.因子的组合</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211211110937828.png" alt="image-20211211110937828"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS+剪枝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dfs</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(n));         <span class="comment">//(1)剪枝点，遍历终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;           </span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;i,n/i&#125;);</span><br><span class="line">                vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; next = <span class="built_in">dfs</span>(i,n/i);  <span class="comment">//(2)剪枝点,从i，不从1开始，避免重复</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sub:next)&#123;</span><br><span class="line">                    sub.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">getFactors</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">2</span>,n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="444-序列重建"><a href="#444-序列重建" class="headerlink" title="444. 序列重建"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sequence-reconstruction/">444. 序列重建</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n); <span class="comment">//列表存储边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : relation) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>], dst = edge[<span class="number">1</span>];</span><br><span class="line">            edges[src].<span class="built_in">push_back</span>(dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> index, <span class="keyword">int</span> steps) &#123; <span class="comment">//匿名函数</span></span><br><span class="line">            <span class="keyword">if</span> (steps == k &amp;&amp; index == n - <span class="number">1</span>)) &#123;</span><br><span class="line">                ++ways;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> to : edges[index]) </span><br><span class="line">                <span class="built_in">dfs</span>(to, steps + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> color, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= image.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= image[<span class="number">0</span>].<span class="built_in">size</span>() || image[x][y] != color )<span class="keyword">return</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            <span class="built_in">dfs</span>(image, mx, my, color, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> currColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (currColor != newColor) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>「力扣」第 684 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection">冗余连接</a>（中等）；<br>「力扣」第 1319 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected">连通网络的操作次数</a>（中等）；<br>「力扣」第 1631 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-minimum-effort">最小体力消耗路径</a>（中等）；<br>「力扣」第 959 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regions-cut-by-slashes">由斜杠划分区域</a>（中等）；<br>「力扣」第 1202 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-string-with-swaps">交换字符串中的元素</a>（中等）；<br>「力扣」第 947 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column">移除最多的同行或同列石头</a>（中等）；<br>「力扣」第 721 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/accounts-merge">账户合并</a>（中等）；<br>「力扣」第 803 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bricks-falling-when-hit">打砖块</a>（困难）；<br>「力扣」第 1579 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable">保证图可完全遍历</a>（困难）;<br>「力扣」第 778 题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swim-in-rising-water">水位上升的泳池中游泳</a>（困难）。</p>
<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS+回溯"></a>DFS+回溯</h3><h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929211741751.png" alt="image-20210929211741751"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数独首先行，列，还有 3*3 的方格内数字是 1~9 不能重复。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> line[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> column[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.<span class="built_in">size</span>()) &#123; <span class="comment">//递归出口 </span></span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [i, j] = spaces[pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">              	board[i][j] = digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;  <span class="comment">//x+1 转换为int</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>; <span class="comment">//标志</span></span><br><span class="line">                <span class="built_in">dfs</span>(board, pos + <span class="number">1</span>);	<span class="comment">//递归</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(column, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(column));</span><br><span class="line">        <span class="built_in">memset</span>(block, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(block));</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">      <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;  <span class="comment">//x-1</span></span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后-🀄️"><a href="#51-N-皇后-🀄️" class="headerlink" title="51. N 皇后 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; g;</span><br><span class="line">    <span class="keyword">bool</span> col[N],gd[N*<span class="number">2</span>],rgd[N*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用 </span></span><br><span class="line">  <span class="comment">//N=10,x+y最大为18</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">           res.<span class="built_in">push_back</span>(g);	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// x+y=b 正对角线 -x+y(+n)=b&gt;=0负对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[x+y] &amp;&amp; !rgd[y-x+n])&#123;</span><br><span class="line">                g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                g[x][y] = <span class="string">&#x27;.&#x27;</span>;	<span class="comment">//恢复现场，回溯</span></span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;	<span class="comment">//初始化棋盘</span></span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) tmp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            g.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0行开始 第n列开始</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上一题改一改就可以了</span></span><br><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">10</span>],gd[<span class="number">10</span>*<span class="number">2</span>],rgd[<span class="number">10</span>*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">            res++;	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b =x+y 反对角线 b=y-x (+n) &gt;=0对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[y-x+n] &amp;&amp; !rgd[x+y])&#123;</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">false</span>;<span class="comment">//恢复现场，回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0个位置开始搜索</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(|s|*3^SEG_COUNT) S:O(SEG_COUNT)  ,每一段的位数不会超过 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>; <span class="comment">//ip段数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( segStart == s.<span class="built_in">size</span>())&#123; <span class="comment">//(1)</span></span><br><span class="line">                string ipAddr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                ipAddr += <span class="built_in">to_string</span>(segs[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;   <span class="comment">//不是最后一个都加&#x27;.&#x27;</span></span><br><span class="line">                        ipAddr += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">move</span>(ipAddr));    <span class="comment">//move()只是转移,提高利用效率</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//(2)4 段 IP 地址达到了，但是字符串没有遍历完，直接回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// (3)如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4)由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s[segStart] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segs[segId] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.<span class="built_in">size</span>(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s[segEnd] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转化为int</span></span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;<span class="comment">//在0-255范围内就加入</span></span><br><span class="line">                segs[segId] = addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segs.<span class="built_in">resize</span>(SEG_COUNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h4><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(min(L,MN))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,string &amp;word,<span class="keyword">int</span> k,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//不同</span></span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">length</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;               <span class="comment">//选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir: dirs) &#123;       <span class="comment">//递归搜索</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = <span class="built_in">dfs</span>(board, x, y, word, k + <span class="number">1</span>,visited);</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;	<span class="comment">//有一个符合就返回</span></span><br><span class="line">                        res = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;              <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">visited</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m)); <span class="comment">//二维</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> falg = <span class="built_in">dfs</span>(board,i,j,word,<span class="number">0</span>,visited);</span><br><span class="line">                <span class="keyword">if</span>(falg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211002001203923.png" alt="image-20211002001203923"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀树+DFS+回溯</span></span><br><span class="line"><span class="comment">//用字典树剪枝</span></span><br><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(k×L)，其中 k 是字典 words列表 的长度，L 是最长单词的长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    string word;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,TrieNode *&gt; children;</span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children.<span class="built_in">count</span>(c)) &#123;	<span class="comment">//没有，加入</span></span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];<span class="comment">//当前指向child</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool searchPrefix(TrieNode* root,string prefix) &#123;</span></span><br><span class="line"><span class="comment">  TrieNode* node = root;</span></span><br><span class="line"><span class="comment">  for (char ch : prefix) &#123;</span></span><br><span class="line"><span class="comment">    if (!node-&gt;children.count(ch)) &#123;</span></span><br><span class="line"><span class="comment">      return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    node = node-&gt;children[ch];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = board[i][j];        </span><br><span class="line">      	<span class="comment">//如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">count</span>(ch)) &#123;    <span class="comment">//字典words中没有该ch前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = root-&gt;children[ch];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;word.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;    <span class="comment">//加入当前ch</span></span><br><span class="line">            res.<span class="built_in">insert</span>(root-&gt;word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;      <span class="comment">//选择(标志)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir:dirs) &#123;   <span class="comment">//搜素</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>],y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">dfs</span>(board, x, y, root,res);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = ch;   <span class="comment">//撤销选择</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp; board, vector&lt;string&gt; &amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode * root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        set&lt;string&gt; res;    <span class="comment">//去重</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造字典树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: words)&#123;</span><br><span class="line">            <span class="built_in">insertTrie</span>(root,word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, root, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: res) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h4 id="934-最短的桥-🀄️"><a href="#934-最短的桥-🀄️" class="headerlink" title="934. 最短的桥 🀄️"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a> 🀄️</h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/1638328692-YrAjMu-1.png" alt="1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="126-单词接龙-II-🀄️-BFS-图的构建"><a href="#126-单词接龙-II-🀄️-BFS-图的构建" class="headerlink" title="126. 单词接龙 II 🀄️  BFS+图的构建"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a> 🀄️  BFS+图的构建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="127-单词接龙-BFS-图的构建"><a href="#127-单词接龙-BFS-图的构建" class="headerlink" title="127. 单词接龙  BFS+图的构建"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a>  BFS+图的构建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="286-墙与门-BFS-去重"><a href="#286-墙与门-BFS-去重" class="headerlink" title="286.墙与门 BFS+去重"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/walls-and-gates/">286.墙与门</a> BFS+去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="301-删除无效的括号-不错"><a href="#301-删除无效的括号-不错" class="headerlink" title="301. 删除无效的括号 不错"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a> 不错</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="310-最小高度树-不错"><a href="#310-最小高度树-不错" class="headerlink" title="310. 最小高度树 不错"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a> 不错</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="317-离建筑物最近的距离"><a href="#317-离建筑物最近的距离" class="headerlink" title="317.离建筑物最近的距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/">317.离建筑物最近的距离</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="133-克隆图-BFS-哈希"><a href="#133-克隆图-BFS-哈希" class="headerlink" title="133. 克隆图 BFS+哈希"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a> BFS+哈希</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="261-以图判树-BFS-并查集"><a href="#261-以图判树-BFS-并查集" class="headerlink" title="261.以图判树 BFS+并查集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/graph-valid-tree/">261.以图判树</a> BFS+并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="323-无向图中连通分量的数目-BFS-二维数组"><a href="#323-无向图中连通分量的数目-BFS-二维数组" class="headerlink" title="323.无向图中连通分量的数目 BFS+二维数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/">323.无向图中连通分量的数目</a> BFS+二维数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="490-迷宫"><a href="#490-迷宫" class="headerlink" title="490. 迷宫"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-maze/">490. 迷宫</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="505-迷宫-II"><a href="#505-迷宫-II" class="headerlink" title="505. 迷宫 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-maze-ii/">505. 迷宫 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="499-迷宫-III"><a href="#499-迷宫-III" class="headerlink" title="499. 迷宫 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-maze-iii/">499. 迷宫 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="HJ43-迷宫问题"><a href="#HJ43-迷宫问题" class="headerlink" title="HJ43 迷宫问题"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc">HJ43 迷宫问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(m*n) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//pair 默认对first升序，当first相同时对second升序；</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;PII&gt;&gt; &amp;path,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;              <span class="comment">//用于遍历</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="comment">// d[0][0] = 0;                    //移动次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())        <span class="comment">//队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();   <span class="comment">//出队</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">          <span class="comment">//if(x == n-1 &amp;&amp; y == m-1 &amp;&amp; g[x][y] == 0) cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl; //判断是否到达出口  </span></span><br><span class="line">          <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp;y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//d[x][y] = d[t.first][t.second] + 1;   //之前的距离加上又走的一步</span></span><br><span class="line">                g[x][y] = <span class="number">1</span>;</span><br><span class="line">                path[x][y] = t;        <span class="comment">//从t点到(x,y)</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x,y));   <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    vector&lt;PII&gt;  res;          <span class="comment">//res用于逆序输出</span></span><br><span class="line">    <span class="keyword">int</span> x = n<span class="number">-1</span>,y=m<span class="number">-1</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">    <span class="keyword">while</span>(x || y)&#123;  <span class="comment">//同时为0时退出</span></span><br><span class="line">        <span class="keyword">auto</span> t = path[x][y];</span><br><span class="line">        x = t.first,y=t.second;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,res[i].first,res[i].second); <span class="comment">//(2)路径逆序输出</span></span><br><span class="line">    <span class="comment">//return d[n - 1][m - 1]; //（1）最少移动的次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));   <span class="comment">//g存储的是图  d存储的是移动次数</span></span><br><span class="line">        <span class="comment">//d = vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(m,0));</span></span><br><span class="line">        vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">path</span>(n*m,vector&lt;PII&gt;(n*m));   <span class="comment">//pre保存点映射点 注意这里需要n*m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                cin&gt;&gt;g[i][j];    <span class="comment">//存入地图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(path,g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1926-迷宫中离入口最近的出口"><a href="#1926-迷宫中离入口最近的出口" class="headerlink" title="1926. 迷宫中离入口最近的出口"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestExit</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; entrance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;           <span class="comment">//(x,y,d)   d是相对入口的距离</span></span><br><span class="line">        q.<span class="built_in">emplace</span>(entrance[<span class="number">0</span>],entrance[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        maze[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="string">&#x27;+&#x27;</span>;   <span class="comment">//遍历过了，防止重复访问</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [mx,my,d] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=mx+dir[<span class="number">0</span>],y=my+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt;m &amp;&amp; maze[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">//边界时返回答案</span></span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">0</span> || x == n<span class="number">-1</span> || y== <span class="number">0</span> || y == m <span class="number">-1</span> ) <span class="keyword">return</span> d+<span class="number">1</span>;</span><br><span class="line">                    maze[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(x,y,d+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="PDD4迷宫寻路"><a href="#PDD4迷宫寻路" class="headerlink" title="PDD4迷宫寻路"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e3fc4f8094964a589735d640424b6a47?tpId=182&gioEnter=menu">PDD4迷宫寻路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC代码:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> G[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">105</span>][<span class="number">105</span>][<span class="number">1200</span>],N,M;</span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,k,step;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k,<span class="keyword">int</span> step):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">k</span>(k),<span class="built_in">step</span>(step)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,G[i]);</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(book));</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">                <span class="keyword">if</span>(G[i][j]==<span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    book[i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">bfs</span>(i,j));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX,<span class="keyword">int</span> startY)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">node</span>(startX,startY,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node head=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(G[head.x][head.y]==<span class="string">&#x27;3&#x27;</span>) <span class="keyword">return</span> head.step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=head.x+Next[i][<span class="number">0</span>],ny=head.y+Next[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=N||nx&lt;<span class="number">0</span>||ny&gt;=M||ny&lt;<span class="number">0</span>||G[nx][ny]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> key=head.k;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;z&#x27;</span>) key=key|(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;Z&#x27;</span>&amp;&amp;(key&amp;(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;A&#x27;</span>)))==<span class="number">0</span>) <span class="keyword">continue</span>;	<span class="comment">//没有该钥匙</span></span><br><span class="line">            <span class="keyword">if</span>(!book[nx][ny][key])&#123;</span><br><span class="line">                book[nx][ny][key]=<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx,ny,key,head.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//这题就是普通的bfs多了‘钥匙’这个状态 </span></span><br><span class="line"> <span class="comment">//所以book[x][y][key]的意义就是 横坐标为x,纵坐标为y,钥匙状态为key的点是否访问过 </span></span><br><span class="line"> <span class="comment">//钥匙的状态 就用二进制数表示 最多10 把钥匙 那就是1024</span></span><br><span class="line"> <span class="comment">//比如我现在有第二把钥匙和第四把钥匙  那么我的钥匙状态就是 0101000000 也就是 320</span></span><br></pre></td></tr></table></figure>

<h4 id="机器人走迷宫"><a href="#机器人走迷宫" class="headerlink" title="机器人走迷宫"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/596162?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7CDE02A66517EFFDE8544F0962A4C635-1639577561411">机器人走迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="走迷宫最小消耗"><a href="#走迷宫最小消耗" class="headerlink" title="走迷宫最小消耗"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/discuss/cg0ayO/">走迷宫最小消耗</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1036-逃离大迷宫"><a href="#1036-逃离大迷宫" class="headerlink" title="1036. 逃离大迷宫"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/escape-a-large-maze/">1036. 逃离大迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div>
            
              <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

            
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/02/3.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="prev" title="3.贪心算法">
      <i class="fa fa-chevron-left"></i> 3.贪心算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="next" title="1.二叉树">
      1.二叉树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2-DFS-BFS-%E5%9B%9E%E6%BA%AF"><span class="nav-text">2.DFS&#x2F;BFS+回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">131. 分割回文串 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="nav-text">216. 组合总和 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86"><span class="nav-text">78. 子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="nav-text">90. 子集 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">46. 全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="nav-text">47. 全排列 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">784. 字母大小写全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-text">剑指 Offer 17. 打印从1到最大的n位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II"><span class="nav-text">140. 单词拆分 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#267-%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97-II"><span class="nav-text">267.回文排列  II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8"><span class="nav-text">401. 二进制手表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">491. 递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-text">22. 括号生成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">200. 岛屿数量 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-text">695. 岛屿的最大面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="nav-text">463. 岛屿的周长</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B"><span class="nav-text">827. 最大人工岛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="nav-text">547. 省份数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4"><span class="nav-text">841. 钥匙和房间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">剑指 Offer 13. 机器人的运动范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="nav-text">130. 被围绕的区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="nav-text">417. 太平洋大西洋水流问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="nav-text">332. 重新安排行程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">785. 判断二分图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-text">60. 排列序列 第k个排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#254-%E5%9B%A0%E5%AD%90%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">254.因子的组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-text">207. 课程表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II"><span class="nav-text">210. 课程表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#630-%E8%AF%BE%E7%A8%8B%E8%A1%A8-III"><span class="nav-text">630. 课程表 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-text">329. 矩阵中的最长递增路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#444-%E5%BA%8F%E5%88%97%E9%87%8D%E5%BB%BA"><span class="nav-text">444. 序列重建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="nav-text">399. 除法求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-text">652. 寻找重复的子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF"><span class="nav-text">LCP 07. 传递信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="nav-text">733. 图像渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS-%E5%9B%9E%E6%BA%AF"><span class="nav-text">DFS+回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-text">37. 解数独</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51-N-%E7%9A%87%E5%90%8E-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">51. N 皇后 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-N%E7%9A%87%E5%90%8E-II"><span class="nav-text">52. N皇后 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="nav-text">93. 复原 IP 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-text">79. 单词搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">剑指 Offer 12. 矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-II"><span class="nav-text">212. 单词搜索 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS"><span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5-%F0%9F%80%84%EF%B8%8F"><span class="nav-text">934. 最短的桥 🀄️</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-II-%F0%9F%80%84%EF%B8%8F-BFS-%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">126. 单词接龙 II 🀄️  BFS+图的构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-BFS-%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">127. 单词接龙  BFS+图的构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#286-%E5%A2%99%E4%B8%8E%E9%97%A8-BFS-%E5%8E%BB%E9%87%8D"><span class="nav-text">286.墙与门 BFS+去重</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E4%B8%8D%E9%94%99"><span class="nav-text">301. 删除无效的括号 不错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91-%E4%B8%8D%E9%94%99"><span class="nav-text">310. 最小高度树 不错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#317-%E7%A6%BB%E5%BB%BA%E7%AD%91%E7%89%A9%E6%9C%80%E8%BF%91%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-text">317.离建筑物最近的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#863-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-K-%E7%9A%84%E7%BB%93%E7%82%B9"><span class="nav-text">863. 二叉树中所有距离为 K 的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-text">994. 腐烂的橘子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">1091. 二进制矩阵中的最短路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#133-%E5%85%8B%E9%9A%86%E5%9B%BE-BFS-%E5%93%88%E5%B8%8C"><span class="nav-text">133. 克隆图 BFS+哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#261-%E4%BB%A5%E5%9B%BE%E5%88%A4%E6%A0%91-BFS-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">261.以图判树 BFS+并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#323-%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%95%B0%E7%9B%AE-BFS-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">323.无向图中连通分量的数目 BFS+二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#490-%E8%BF%B7%E5%AE%AB"><span class="nav-text">490. 迷宫</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#505-%E8%BF%B7%E5%AE%AB-II"><span class="nav-text">505. 迷宫 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#499-%E8%BF%B7%E5%AE%AB-III"><span class="nav-text">499. 迷宫 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HJ43-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="nav-text">HJ43 迷宫问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1926-%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3"><span class="nav-text">1926. 迷宫中离入口最近的出口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDD4%E8%BF%B7%E5%AE%AB%E5%AF%BB%E8%B7%AF"><span class="nav-text">PDD4迷宫寻路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%BF%B7%E5%AE%AB"><span class="nav-text">机器人走迷宫</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%B0%E8%BF%B7%E5%AE%AB%E6%9C%80%E5%B0%8F%E6%B6%88%E8%80%97"><span class="nav-text">走迷宫最小消耗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1036-%E9%80%83%E7%A6%BB%E5%A4%A7%E8%BF%B7%E5%AE%AB"><span class="nav-text">1036. 逃离大迷宫</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChaoZhong Zhang"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">ChaoZhong Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhangChaoZhong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhangChaoZhong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zczindex@gmail.com" title="E-Mail → zczindex@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChaoZhong Zhang
  </span>
  <span class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LitCJHzcYDrw3V694F5ykefU-9Nh9j0Va',
      appKey     : 'xrhUoMdaVndszRNhqsBy6jni',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
