<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人资源分享</title>
    <url>/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="计算机视觉（持续更新）"><a href="#计算机视觉（持续更新）" class="headerlink" title="计算机视觉（持续更新）"></a>计算机视觉（持续更新）</h1><h2 id="（一）工具"><a href="#（一）工具" class="headerlink" title="（一）工具"></a>（一）工具</h2><h3 id="1-0-PPT模板"><a href="#1-0-PPT模板" class="headerlink" title="1.0 PPT模板"></a>1.0 PPT模板</h3><h4 id="学术模板"><a href="#学术模板" class="headerlink" title="学术模板"></a><a href="ppt/%E5%AD%A6%E6%9C%AF%E6%A8%A1%E6%9D%BF.pptx">学术模板</a></h4><h4 id="创新项目模板"><a href="#创新项目模板" class="headerlink" title="创新项目模板"></a><a href="ppt/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF.pptx">创新项目模板</a></h4><h4 id="项目介绍模板"><a href="#项目介绍模板" class="headerlink" title="项目介绍模板"></a><a href="ppt/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E6%A8%A1%E6%9D%BF.pptx">项目介绍模板</a></h4><h4 id="开题报告模板16-9"><a href="#开题报告模板16-9" class="headerlink" title="开题报告模板16:9"></a><a href="ppt/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF.pptx">开题报告模板16:9</a></h4><h4 id="开题报告模板4-3"><a href="#开题报告模板4-3" class="headerlink" title="开题报告模板4:3"></a><a href="ppt/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF2.pptx">开题报告模板4:3</a></h4><h3 id="1-1-绘图"><a href="#1-1-绘图" class="headerlink" title="1.1 绘图"></a>1.1 绘图</h3><h4 id="1-PPT-🌟"><a href="#1-PPT-🌟" class="headerlink" title="(1) PPT 🌟"></a>(1) PPT 🌟</h4><blockquote>
<p>一般用来画神经网络图，当然，画流程图，技术路线图都可以，全能的</p>
<p>推荐一个PPT科研绘图实例库  <a href="https://docs.google.com/presentation/d/11mR1nkIR9fbHegFkcFq8z9oDQ5sjv8E3JJp1LfLGKuk/edit?usp=sharing">PPT好看的科研图</a></p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230246901.png" alt="image-20211225230246901"></p>
<p><code>上面是我画的一个神经网络图</code></p>
<span id="more"></span>

<h4 id="2-processon-🌟"><a href="#2-processon-🌟" class="headerlink" title="(2) processon 🌟"></a><a href="https://www.processon.com/">(2) processon</a> 🌟</h4><blockquote>
<p>一般用来画技术路线图，系统架构图<br>唯一缺点：无法导出高清图（需要付费），不过清晰度也够用了</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230536808.png" alt="image-20211225230536808"></p>
<h4 id="3-diagrams-🌟"><a href="#3-diagrams-🌟" class="headerlink" title="(3) diagrams 🌟"></a><a href="https://app.diagrams.net/">(3) diagrams</a> 🌟</h4><blockquote>
<p>跟上面基本一样，但可以导出高清图，下面是我画的一个图</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225231147475.png" alt="image-20211225231147475"></p>
<h4 id="4-codeimg"><a href="#4-codeimg" class="headerlink" title="(4) codeimg"></a><a href="https://codeimg.io/">(4) codeimg</a></h4><h4 id="5-carbon"><a href="#5-carbon" class="headerlink" title="(5) carbon"></a><a href="https://carbon.now.sh/">(5) carbon</a></h4><blockquote>
<p>上面2个都可以将代码块转为图片</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230347535.png" alt="image-20211225230347535"></p>
<h4 id="6-在线PS"><a href="#6-在线PS" class="headerlink" title="(6) 在线PS"></a><a href="https://ps.gaoding.com/#/">(6) 在线PS</a></h4><h4 id="7-python科研图"><a href="#7-python科研图" class="headerlink" title="(7) python科研图"></a>(7) python科研图</h4><p><a href="https://github.com/garrettj403/SciencePlots">https://github.com/garrettj403/SciencePlots</a> 🌟🌟🌟🌟🌟</p>
<p><a href="https://github.com/reiinakano/scikit-plot">https://github.com/reiinakano/scikit-plot</a></p>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230436063.png" alt="image-20211225230436063"></p>
<h3 id="1-2-论文搜索"><a href="#1-2-论文搜索" class="headerlink" title="1.2 论文搜索"></a>1.2 论文搜索</h3><h4 id="1-中文SCIHUB"><a href="#1-中文SCIHUB" class="headerlink" title="(1) 中文SCIHUB"></a><a href="https://www.scihub.net.cn/">(1) 中文SCIHUB</a></h4><blockquote>
<p>非常全的一个论文检索网站</p>
</blockquote>
<h4 id="2-connectedpapers-🌟"><a href="#2-connectedpapers-🌟" class="headerlink" title="(2) connectedpapers 🌟"></a><a href="https://www.connectedpapers.com/">(2) connectedpapers</a> 🌟</h4><blockquote>
<p>可以生成查找论文的关系网络，理清某方向的研究脉络，写文献综述方便</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230143574.png" alt="image-20211225230143574"></p>
<h4 id="3-researchrabbitapp-🌟"><a href="#3-researchrabbitapp-🌟" class="headerlink" title="(3) researchrabbitapp 🌟"></a><a href="https://researchrabbitapp.com/">(3) researchrabbitapp</a> 🌟</h4><blockquote>
<p>又一个写文献综述神器，注册时，随便网上找一个学校邮箱注册就行</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225225937935.png" alt="image-20211225225937935"></p>
<h4 id="4-SCIHUB-🌟"><a href="#4-SCIHUB-🌟" class="headerlink" title="(4) SCIHUB 🌟"></a><a href="https://www.sci-hub.ren/">(4) SCIHUB</a> 🌟</h4><blockquote>
<p>无敌，几乎可以搜索到所有论文</p>
</blockquote>
<h4 id="5-paperswithcode-🌟"><a href="#5-paperswithcode-🌟" class="headerlink" title="(5) paperswithcode 🌟"></a><a href="https://paperswithcode.com/">(5) paperswithcode</a> 🌟</h4><blockquote>
<p><strong>可以找到论文的代码</strong>，以及当前研究任务的排行榜</p>
</blockquote>
<h4 id="6-arxiv"><a href="#6-arxiv" class="headerlink" title="(6) arxiv"></a><a href="https://arxiv.org/">(6) arxiv</a></h4><h4 id="7-谷歌学术"><a href="#7-谷歌学术" class="headerlink" title="(7) 谷歌学术"></a><a href="https://scholar.google.com/">(7) 谷歌学术</a></h4><h4 id="8-X-MOL"><a href="#8-X-MOL" class="headerlink" title="(8) X-MOL"></a><a href="https://www.x-mol.com/">(8) X-MOL</a></h4><blockquote>
<p>支持订阅的论文网站（有手机端，网页端）</p>
</blockquote>
<h4 id="9-easyScholar"><a href="#9-easyScholar" class="headerlink" title="(9) easyScholar"></a><a href>(9) easyScholar</a></h4><blockquote>
<p>判断文献质量（浏览器插件就可以安装）</p>
</blockquote>
<h3 id="1-3-期刊选择"><a href="#1-3-期刊选择" class="headerlink" title="1.3 期刊选择"></a>1.3 期刊选择</h3><h4 id="1-Journalrank"><a href="#1-Journalrank" class="headerlink" title="(1)Journalrank"></a><a href="https://www.scimagojr.com/journalrank.php">(1)Journalrank</a></h4><h4 id="2-Journalguide"><a href="#2-Journalguide" class="headerlink" title="(2)Journalguide"></a><a href="https://www.journalguide.com/">(2)Journalguide</a></h4><h3 id="1-4-转转小工具"><a href="#1-4-转转小工具" class="headerlink" title="1.4 转转小工具"></a>1.4 转转小工具</h3><h4 id="1-PDF转PPT"><a href="#1-PDF转PPT" class="headerlink" title="(1) PDF转PPT"></a><a href="https://smallpdf.com/pdf-to-ppt">(1) PDF转PPT</a></h4><h4 id="2-视频转文字-🌟"><a href="#2-视频转文字-🌟" class="headerlink" title="(2) 视频转文字 🌟"></a><a href="https://www.feishu.cn/product/minutes">(2) 视频转文字</a> 🌟</h4><blockquote>
<p>类似于自动生成字幕，还可以提取里面对话的关键信息</p>
</blockquote>
<h4 id="3-B站视频下载"><a href="#3-B站视频下载" class="headerlink" title="(3) B站视频下载"></a><a href="https://xbeibeix.com/api/bilibili/">(3) B站视频下载</a></h4><h3 id="1-5-素材"><a href="#1-5-素材" class="headerlink" title="1.5 素材"></a>1.5 素材</h3><h4 id="（1）插图"><a href="#（1）插图" class="headerlink" title="（1）插图"></a>（1）插图</h4><p><a href="https://undraw.co/search">https://undraw.co/search</a></p>
<p><a href="https://www.manypixels.co/gallery">https://www.manypixels.co/gallery</a></p>
<h4 id="（2）图标"><a href="#（2）图标" class="headerlink" title="（2）图标"></a>（2）图标</h4><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p>
<p><a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a></p>
<h3 id="1-6-写作"><a href="#1-6-写作" class="headerlink" title="1.6 写作"></a>1.6 写作</h3><h4 id="（1）latex写论文"><a href="#（1）latex写论文" class="headerlink" title="（1）latex写论文"></a>（1）latex写论文</h4><p><a href="https://www.overleaf.com/">https://www.overleaf.com/</a></p>
<h4 id="（2）语法纠错"><a href="#（2）语法纠错" class="headerlink" title="（2）语法纠错"></a>（2）语法纠错</h4><p><a href="https://www.grammarly.com/grammar-check">https://www.grammarly.com/grammar-check</a></p>
<h4 id="（3）句子改写"><a href="#（3）句子改写" class="headerlink" title="（3）句子改写"></a>（3）句子改写</h4><p><a href="https://app.wordtune.com/">https://app.wordtune.com</a></p>
<p><a href="https://quillbot.com/">https://quillbot.com/</a></p>
<p><a href="https://paraphrasing-tool.com/">https://paraphrasing-tool.com/</a></p>
<h4 id="（4）句式套路"><a href="#（4）句式套路" class="headerlink" title="（4）句式套路"></a>（4）句式套路</h4><p><a href="https://www.phrasebank.manchester.ac.uk/describing-methods/">https://www.phrasebank.manchester.ac.uk/describing-methods/</a></p>
<h4 id="（5）翻译软件"><a href="#（5）翻译软件" class="headerlink" title="（5）翻译软件"></a>（5）翻译软件</h4><p><a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></p>
<p><a href="https://fanyi.baidu.com/">https://fanyi.baidu.com/</a></p>
<p><a href="https://fanyi.youdao.com/">https://fanyi.youdao.com/</a></p>
<h3 id="1-7-搜索途径"><a href="#1-7-搜索途径" class="headerlink" title="1.7 搜索途径"></a>1.7 搜索途径</h3><h4 id="（1）微信公众号文章-🌟"><a href="#（1）微信公众号文章-🌟" class="headerlink" title="（1）微信公众号文章 🌟"></a>（1）微信公众号文章 🌟</h4><blockquote>
<p>质量比较高，毕竟为了运营</p>
</blockquote>
<h4 id="（2）知乎"><a href="#（2）知乎" class="headerlink" title="（2）知乎"></a>（2）知乎</h4><h4 id="（3）谷歌"><a href="#（3）谷歌" class="headerlink" title="（3）谷歌"></a>（3）谷歌</h4><h4 id="（4）必应"><a href="#（4）必应" class="headerlink" title="（4）必应"></a>（4）必应</h4><h4 id="（5）百度"><a href="#（5）百度" class="headerlink" title="（5）百度"></a>（5）百度</h4><h3 id="1-8-记笔记"><a href="#1-8-记笔记" class="headerlink" title="1.8 记笔记"></a>1.8 记笔记</h3><h4 id="（1）Typora"><a href="#（1）Typora" class="headerlink" title="（1）Typora"></a>（1）Typora</h4><h4 id="（2）Obsidian"><a href="#（2）Obsidian" class="headerlink" title="（2）Obsidian"></a>（2）Obsidian</h4><h4 id="（3）语雀"><a href="#（3）语雀" class="headerlink" title="（3）语雀"></a>（3）语雀</h4><h2 id="（二）社区网站"><a href="#（二）社区网站" class="headerlink" title="（二）社区网站"></a>（二）社区网站</h2><h3 id="1-极市开发者社区-🌟"><a href="#1-极市开发者社区-🌟" class="headerlink" title="(1) 极市开发者社区 🌟"></a><a href="https://bbs.cvmart.net/">(1) 极市开发者社区</a> 🌟</h3><h3 id="2-智源社区"><a href="#2-智源社区" class="headerlink" title="(2) 智源社区"></a><a href="https://hub.baai.ac.cn/">(2) 智源社区</a></h3><h3 id="3-飞浆"><a href="#3-飞浆" class="headerlink" title="(3) 飞浆"></a><a href="https://www.paddlepaddle.org.cn/developercommunity">(3) 飞浆</a></h3><h3 id="4-和鲸社区"><a href="#4-和鲸社区" class="headerlink" title="(4) 和鲸社区"></a><a href="https://www.heywhale.com/home/project">(4) 和鲸社区</a></h3><h3 id="5-红色石头"><a href="#5-红色石头" class="headerlink" title="(5) 红色石头"></a><a href="https://redstonewill.com/">(5) 红色石头</a></h3><h3 id="6-我爱计算机视觉-🌟"><a href="#6-我爱计算机视觉-🌟" class="headerlink" title="(6) 我爱计算机视觉 🌟"></a><a href="https://www.52cv.net/">(6) 我爱计算机视觉</a> 🌟</h3><h3 id="7-GiantPandaCV-🌟"><a href="#7-GiantPandaCV-🌟" class="headerlink" title="(7) GiantPandaCV 🌟"></a><a href="http://giantpandacv.com/">(7) GiantPandaCV</a> 🌟</h3><h3 id="8-SIGAI"><a href="#8-SIGAI" class="headerlink" title="(8) SIGAI"></a><a href="https://www.zhihu.com/org/bei-jing-zhang-liang-wu-xian-ke-ji-you-xian-gong-si/posts">(8) SIGAI</a></h3><h2 id="（三）教程"><a href="#（三）教程" class="headerlink" title="（三）教程"></a>（三）教程</h2><h3 id="1-tensorflow2"><a href="#1-tensorflow2" class="headerlink" title="(1) tensorflow2"></a><a href="https://github.com/lyhue1991/eat_tensorflow2_in_30_days">(1) tensorflow2</a></h3><h3 id="2-pytorch"><a href="#2-pytorch" class="headerlink" title="(2) pytorch"></a><a href="https://github.com/lyhue1991/eat_pytorch_in_20_days">(2) pytorch</a></h3><h3 id="3-flask"><a href="#3-flask" class="headerlink" title="(3) flask"></a><a href="https://github.com/qzq1111/flask-restful-example">(3) flask</a></h3><h3 id="4-Ai-learn"><a href="#4-Ai-learn" class="headerlink" title="(4) Ai-learn"></a><a href="https://github.com/tangyudi/Ai-learn">(4) Ai-learn</a></h3><h3 id="5-莫烦-🌟"><a href="#5-莫烦-🌟" class="headerlink" title="(5) 莫烦 🌟"></a><a href="https://mofanpy.com/">(5) 莫烦</a> 🌟</h3><h3 id="6-李宏毅-🌟"><a href="#6-李宏毅-🌟" class="headerlink" title="(6) 李宏毅 🌟"></a><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses.html">(6) 李宏毅</a> 🌟</h3><h3 id="7-网络搭建-🌟"><a href="#7-网络搭建-🌟" class="headerlink" title="(7) 网络搭建 🌟"></a><a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">(7) 网络搭建</a> 🌟</h3><h2 id="（四）项目"><a href="#（四）项目" class="headerlink" title="（四）项目"></a>（四）项目</h2><blockquote>
<p>以下总结项目开发用得上的github</p>
</blockquote>
<h3 id="4-1模型"><a href="#4-1模型" class="headerlink" title="4.1模型"></a>4.1模型</h3><h4 id="（1）目标检测🌟"><a href="#（1）目标检测🌟" class="headerlink" title="（1）目标检测🌟"></a>（1）目标检测🌟</h4><p><a href="https://github.com/ultralytics/yolov5">Yolov5</a> </p>
<p><a href="https://github.com/PaddlePaddle/PaddleDetection">飞浆检测框架</a></p>
<h4 id="（2）目标检测（移动端）"><a href="#（2）目标检测（移动端）" class="headerlink" title="（2）目标检测（移动端）"></a>（2）目标检测（移动端）</h4><p><a href="https://github.com/ppogg/YOLOv5-Lite">YOLOv5-Lite</a></p>
<p><a href="https://github.com/cmdbug/YOLOv5_NCNN">YOLOv5_NCNN</a></p>
<h4 id="（3）目标跟踪"><a href="#（3）目标跟踪" class="headerlink" title="（3）目标跟踪"></a>（3）目标跟踪</h4><p><a href="https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch">Yolov5_DeepSort</a></p>
<p><a href="https://github.com/cong/yolov5_deepsort_tensorrt">yolov5_deepsort_tensorrt</a></p>
<h4 id="（4）行为检测"><a href="#（4）行为检测" class="headerlink" title="（4）行为检测"></a>（4）行为检测</h4><p><a href="https://github.com/open-mmlab/mmaction2">mmaction2</a><br><a href="https://platform.openmmlab.com/home/">OpenMMLab</a></p>
<h4 id="（5）姿态检测"><a href="#（5）姿态检测" class="headerlink" title="（5）姿态检测"></a>（5）姿态检测</h4><p><a href="https://github.com/MVIG-SJTU/AlphaPose">AlphaPose</a></p>
<h4 id="（6）人脸检测-amp-识别🌟"><a href="#（6）人脸检测-amp-识别🌟" class="headerlink" title="（6）人脸检测&amp;识别🌟"></a>（6）人脸检测&amp;识别🌟</h4><p><a href="https://github.com/deepinsight/insightface">insightface</a></p>
<p><a href="https://github.com/ronghuaiyang/arcface-pytorch">arcface</a></p>
<h4 id="（7）头部检测🌟"><a href="#（7）头部检测🌟" class="headerlink" title="（7）头部检测🌟"></a>（7）头部检测🌟</h4><p><a href="https://github.com/tgisaturday/S3FD_ATSS_SAPD">S3FD_ATSS_SAPD</a></p>
<p><a href="https://github.com/YonghaoHe/LFFD-A-Light-and-Fast-Face-Detector-for-Edge-Devices/tree/master/head_detection">head_detection</a></p>
<h4 id="（8）车牌检测🌟"><a href="#（8）车牌检测🌟" class="headerlink" title="（8）车牌检测🌟"></a>（8）车牌检测🌟</h4><p><a href="https://github.com/zeusees/License-Plate-Detector">License-Plate-Detector</a></p>
<p><a href="https://github.com/detectRecog/CCPD">CCPD</a></p>
<p><a href="https://github.com/xialuxi/yolov5-car-plate">yolov5-car-plate</a></p>
<h4 id="（9）图像分类🌟"><a href="#（9）图像分类🌟" class="headerlink" title="（9）图像分类🌟"></a>（9）图像分类🌟</h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/56779">resNet</a></p>
<p><a href="https://aistudio.baidu.com/aistudio/projectdetail/56889">SE_ResNeXt</a></p>
<p><a href="https://github.com/PaddlePaddle/PaddleClas">PaddleClas</a></p>
<h4 id="（10）文字识别🌟"><a href="#（10）文字识别🌟" class="headerlink" title="（10）文字识别🌟"></a>（10）文字识别🌟</h4><p><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a></p>
<h4 id="（11）实例分割"><a href="#（11）实例分割" class="headerlink" title="（11）实例分割"></a>（11）实例分割</h4><p><a href="https://github.com/dbolya/yolact">yolact</a></p>
<h4 id="（12）抠图"><a href="#（12）抠图" class="headerlink" title="（12）抠图"></a>（12）抠图</h4><p><a href="https://github.com/ZHKKKe/MODNet">MODNet</a></p>
<p><a href="https://github.com/danielgatis/rembg">rembg</a></p>
<h4 id="（13）小目标检测"><a href="#（13）小目标检测" class="headerlink" title="（13）小目标检测"></a>（13）小目标检测</h4><p><a href="https://mp.weixin.qq.com/s/mz3gC_PUhM7th0UboOAhzQ">YOLO-Z</a></p>
<h4 id="（14）文本分类🌟"><a href="#（14）文本分类🌟" class="headerlink" title="（14）文本分类🌟"></a>（14）文本分类🌟</h4><p><a href="https://github.com/649453932/Bert-Chinese-Text-Classification-Pytorch">Bert-Chinese-Text-Classification-Pytorch</a></p>
<p><a href="https://github.com/ymcui/Chinese-BERT-wwm">Chinese-BERT-wwm</a></p>
<p><a href="https://github.com/huggingface/transformers">transformers</a></p>
<h4 id="（15）文本纠错"><a href="#（15）文本纠错" class="headerlink" title="（15）文本纠错"></a>（15）文本纠错</h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/1872369">ERNIE</a></p>
<p><a href="https://github.com/PaddlePaddle/PaddleNLP">PaddleNLP</a></p>
<h4 id="（16）文章摘要"><a href="#（16）文章摘要" class="headerlink" title="（16）文章摘要"></a>（16）文章摘要</h4><p><a href="https://github.com/huggingface/transformers">transformers</a></p>
<h3 id="4-2-模型加速"><a href="#4-2-模型加速" class="headerlink" title="4.2 模型加速"></a>4.2 模型加速</h3><blockquote>
<p>ONNX 作为<strong>神经网络交换格式</strong></p>
</blockquote>
<h4 id="1-TensorRT"><a href="#1-TensorRT" class="headerlink" title="(1) TensorRT"></a><a href="https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html">(1) TensorRT</a></h4><p><a href="https://github.com/wang-xinyu/tensorrtx">tensorrtx</a></p>
<blockquote>
<p>不支持WIN系统的Python API调用</p>
</blockquote>
<h4 id="2-NCNN"><a href="#2-NCNN" class="headerlink" title="(2) NCNN"></a><a href="https://github.com/Tencent/ncnn">(2) NCNN</a></h4><h4 id="3-OpenVINO"><a href="#3-OpenVINO" class="headerlink" title="(3) OpenVINO"></a><a href="https://docs.openvinotoolkit.org/latest/index.html">(3) OpenVINO</a></h4><h3 id="4-3-中间件"><a href="#4-3-中间件" class="headerlink" title="4.3 中间件"></a>4.3 中间件</h3><h4 id="（1）消息推送-amp-通信"><a href="#（1）消息推送-amp-通信" class="headerlink" title="（1）消息推送&amp;通信"></a>（1）消息推送&amp;通信</h4><p><a href="https://github.com/miguelgrinberg/Flask-SocketIO">flask-socketio</a></p>
<h4 id="（2）向量检索"><a href="#（2）向量检索" class="headerlink" title="（2）向量检索"></a>（2）向量检索</h4><p><a href="https://github.com/erikbern/ann-benchmarks/">Annoy</a></p>
<h4 id="（3）全文检索引擎"><a href="#（3）全文检索引擎" class="headerlink" title="（3）全文检索引擎"></a>（3）全文检索引擎</h4><p><a href="https://elasticsearch-py.readthedocs.io/en/v7.16.2/">Elasticsearch</a></p>
<h4 id="（4）缓存"><a href="#（4）缓存" class="headerlink" title="（4）缓存"></a>（4）缓存</h4><p><a href="https://www.runoob.com/w3cnote/python-redis-intro.html">Redis</a></p>
<h4 id="（6）消息队列"><a href="#（6）消息队列" class="headerlink" title="（6）消息队列"></a>（6）消息队列</h4><p><a href="https://github.com/pika/pika">RabbitMQ</a></p>
<h4 id="（7）线程-amp-多进程"><a href="#（7）线程-amp-多进程" class="headerlink" title="（7）线程&amp;多进程"></a>（7）线程&amp;多进程</h4><blockquote>
<p>解决摄像头读取延迟问题</p>
</blockquote>
<p><a href="https://github.com/Yonv1943/Python/blob/master/Demo_camera_and_network/ip_camera.py">Ip_camera</a></p>
<p><a href="https://mp.weixin.qq.com/s/3xTdtrcyZ3BVCjjEXeaExA">多进程读取</a></p>
<h4 id="（8）分库分表，读写分离"><a href="#（8）分库分表，读写分离" class="headerlink" title="（8）分库分表，读写分离"></a>（8）分库分表，读写分离</h4><p><a href="https://shardingsphere.apache.org/index_zh.html">shardingsphere</a></p>
<h3 id="4-4-开源项目"><a href="#4-4-开源项目" class="headerlink" title="4.4 开源项目"></a>4.4 开源项目</h3><h4 id="（1）-Html网站模板"><a href="#（1）-Html网站模板" class="headerlink" title="（1） Html网站模板"></a>（1） Html网站模板</h4><p><a href="http://www.pearadmin.com/">pearadmin</a></p>
<h4 id="（2）-Vue网站模板"><a href="#（2）-Vue网站模板" class="headerlink" title="（2） Vue网站模板"></a>（2） Vue网站模板</h4><p><a href="https://github.com/PanJiaChen/vue-element-admin/tree/i18n">vue-element-admin</a></p>
<p><a href="https://github.com/bihell/Dice">Dice</a></p>
<p><a href="http://webflash.enilu.cn/">webflash</a></p>
<p><a href="https://github.com/microapp-store/linjiashop">linjiashop</a></p>
<h4 id="（3）-网站框架"><a href="#（3）-网站框架" class="headerlink" title="（3）  网站框架"></a>（3）  网站框架</h4><p><a href="https://arco.design/">arcodesign</a></p>
<p><a href="https://semi.design/zh-CN">semidesign</a></p>
<p><a href="https://pro.ant.design/">Ant Design Pro</a></p>
<p><a href="https://tdesign.tencent.com/starter/docs/get-started">TDesign</a></p>
<p><a href="https://vvbin.cn/doc-next/">Vben Admin</a></p>
<h4 id="（4）-跨平台应用开发"><a href="#（4）-跨平台应用开发" class="headerlink" title="（4） 跨平台应用开发"></a>（4） 跨平台应用开发</h4><p><a href="https://flutterchina.club/">Flutter</a></p>
<h4 id="（5）-桌面开发"><a href="#（5）-桌面开发" class="headerlink" title="（5） 桌面开发"></a>（5） 桌面开发</h4><p><a href="https://github.com/PyQt5/PyQt">PyQt</a></p>
<p><a href="https://github.com/Wanderson-Magalhaes/Modern_GUI_PyDracula_PySide6_or_PyQt6">PySide6</a></p>
<p><a href="https://github.com/UN-GCPDS/qt-material">qt-material</a></p>
<p><a href="https://github.com/israel-dryer/ttkbootstrap">ttkbootstrap</a></p>
<h4 id="（6）-移动开发"><a href="#（6）-移动开发" class="headerlink" title="（6） 移动开发"></a>（6） 移动开发</h4><p><a href="https://github.com/Tencent/QMUI_Android">QMUI_Android</a></p>
<h4 id="4-5-数字图像处理工具包"><a href="#4-5-数字图像处理工具包" class="headerlink" title="4.5 数字图像处理工具包"></a>4.5 数字图像处理工具包</h4><p><a href="https://github.com/o0o0o0o0o0o0o/image-processing-from-scratch">(1) image-processing</a></p>
<p><a href="https://github.com/CodecWang/opencv-python-tutorial">(2) opencv-python-tutorial</a></p>
<p><a href="https://github.com/PyImageSearch/imutils">(3) imutils</a></p>
<h4 id="4-6-图像-amp-文本特征提取"><a href="#4-6-图像-amp-文本特征提取" class="headerlink" title="4.6 图像&amp;文本特征提取"></a>4.6 图像&amp;文本特征提取</h4><p><a href="https://github.com/1044197988/Python-Image-feature-extraction">(1) Python-Image-feature-extraction</a></p>
<h4 id="4-7-图像数据增强"><a href="#4-7-图像数据增强" class="headerlink" title="4.7 图像数据增强"></a>4.7 图像数据增强</h4><p><a href="https://github.com/aleju/imgaug">imgaug</a></p>
<h2 id="（五）相关建议"><a href="#（五）相关建议" class="headerlink" title="（五）相关建议"></a>（五）相关建议</h2><h3 id="5-1导师沟通"><a href="#5-1导师沟通" class="headerlink" title="5.1导师沟通"></a>5.1导师沟通</h3><h4 id="（1）礼貌"><a href="#（1）礼貌" class="headerlink" title="（1）礼貌"></a>（1）礼貌</h4><blockquote>
<p>（1）打招呼，您</p>
<p>（2）进办公室，记得敲门</p>
</blockquote>
<h4 id="（2）及时反馈"><a href="#（2）及时反馈" class="headerlink" title="（2）及时反馈"></a>（2）及时反馈</h4><blockquote>
<p>交待的事情，做完或没做完都得及时跟导师说下</p>
</blockquote>
<h4 id="（3）想好再说"><a href="#（3）想好再说" class="headerlink" title="（3）想好再说"></a>（3）想好再说</h4><blockquote>
<p>（1）发信息要逻辑清晰，不要让老师去猜…</p>
<p>（2）有些事情无法在通过发信息说清，最好通过语音或者线下跟导师沟通</p>
</blockquote>
<h4 id="（4）有事提前说"><a href="#（4）有事提前说" class="headerlink" title="（4）有事提前说"></a>（4）有事提前说</h4><blockquote>
<p>（1）回家／组会请假：具体原因（不要含糊），具体时间，提前1-2天</p>
</blockquote>
<h4 id="（5）不用什么事情都交代"><a href="#（5）不用什么事情都交代" class="headerlink" title="（5）不用什么事情都交代"></a>（5）不用什么事情都交代</h4><blockquote>
<p>导师：不喜欢学生搞科研之外的事情（比如：蓝桥杯，华为杯等竞赛）</p>
<p>（1）自己确实报名参加了，不用跟导师说，直接去就行，千万不要组会上跟他说</p>
<p>（2）汇报内容最好是课程专业学习，论文，机器学习基础知识。</p>
</blockquote>
<h3 id="5-2-选课建议（专硕）"><a href="#5-2-选课建议（专硕）" class="headerlink" title="5.2 选课建议（专硕）"></a>5.2 选课建议（专硕）</h3><table>
<thead>
<tr>
<th>自然辩证法概论</th>
</tr>
</thead>
<tbody><tr>
<td>中国特色社会主义理论与实践研究</td>
</tr>
<tr>
<td>英语</td>
</tr>
<tr>
<td>专业英语</td>
</tr>
<tr>
<td>数据结构</td>
</tr>
<tr>
<td>统计学习</td>
</tr>
<tr>
<td>运筹学</td>
</tr>
<tr>
<td>高级操作系统或者计算机网络</td>
</tr>
<tr>
<td>工程伦理</td>
</tr>
<tr>
<td>软件系统实验</td>
</tr>
<tr>
<td>专业实践</td>
</tr>
<tr>
<td>劳动教育</td>
</tr>
</tbody></table>
<blockquote>
<p>组合数学，软件形式化方法（禁选）</p>
</blockquote>
<h2 id="（六）学术相关"><a href="#（六）学术相关" class="headerlink" title="（六）学术相关"></a>（六）学术相关</h2><h3 id="6-1-开题报告注意事项"><a href="#6-1-开题报告注意事项" class="headerlink" title="6.1 开题报告注意事项"></a>6.1 开题报告注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.技术路线图</span><br><span class="line">  1）要解释说明（详细点）</span><br><span class="line">  2）打印出来的图要清晰，最好不要加填充颜色（ppt可以）</span><br><span class="line">2.研究内容，采用什么方法解决什么问题</span><br><span class="line">3.关键技术，不能只是关键字</span><br><span class="line">4.参考文献</span><br><span class="line">  1）参考文献要有中英文献</span><br><span class="line">  2）引用要按顺序，或者时间顺序</span><br><span class="line">  3）参考文献时间近5年，不能太久远</span><br><span class="line">  4）有35多篇左右</span><br><span class="line">  5）文献按照GB/T 7714格式</span><br><span class="line">  5.英文字体要罗马字体</span><br><span class="line">6.打印的时候注意检查格式（行间距）</span><br><span class="line">7.选题类型跟老师商量</span><br><span class="line">8.标题，子标题，关键内容最好加粗（增强可读性）</span><br><span class="line">9.第一次出现的缩写英文，要用全称</span><br><span class="line">10.表达</span><br><span class="line">  1）不能口语化</span><br><span class="line">  2）简洁表达，不要啰嗦</span><br><span class="line">  3）不能使用我，我们等主观词语</span><br><span class="line">10.图要有编号</span><br></pre></td></tr></table></figure>

<h3 id="6-2-组会PPT演讲注意事项"><a href="#6-2-组会PPT演讲注意事项" class="headerlink" title="6.2 组会PPT演讲注意事项"></a>6.2 组会PPT演讲注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，要讲的内容先做好调研，为什么要研究这个，这个存在什么问题，挑战；</span><br><span class="line">目前有什么方法，这些方法的具体原理是什么，优缺点，最后再总结下。</span><br><span class="line"></span><br><span class="line">1.PPT本身</span><br><span class="line">  1）字体要大点，要让观众看得清（非常非常重要）</span><br><span class="line">  2）排版要整齐</span><br><span class="line">  3）公式用latex打出来</span><br><span class="line">  4）每页内容尽可能把页面填充满，不要留有太多空白区域</span><br><span class="line">2.演讲逻辑思路要清晰（非常非常重要）</span><br><span class="line">  举个栗子：一般分为以下4个步骤</span><br><span class="line">  1）任务定义（一句话概括）	</span><br><span class="line">  2）背景（存在什么问题，有什么难点，挑战，原因）</span><br><span class="line">  3）方法（一句话总体概括该方法（可以穿插该方法的来源），再讲述具体原理，接着举个通俗易懂的例子，最好画个图，这样观众更加容易理解）</span><br><span class="line">  4）总结方法的优点与缺点</span><br><span class="line">  PS：最好自己先打个演讲稿，私下演练至少3遍。</span><br></pre></td></tr></table></figure>

<h3 id="6-3-写论文等于开脑洞？"><a href="#6-3-写论文等于开脑洞？" class="headerlink" title="6.3 写论文等于开脑洞？"></a>6.3 写论文等于开脑洞？</h3><p><a href="https://www.youtube.com/watch?v=KAGm1ldMIPs">https://www.youtube.com/watch?v=KAGm1ldMIPs</a><br>一篇学术论文的诞生：从构思到发表</p>
<h3 id="6-4-如何看论文"><a href="#6-4-如何看论文" class="headerlink" title="6.4 如何看论文"></a>6.4 如何看论文</h3><p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A6%82%E4%BD%95%E7%9C%8B%E8%AE%BA%E6%96%87.png" alt="研究生如何看论文"></p>
<p><code>笔记例子</code></p>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211226104343545.png" alt="image-20211226104343545"></p>
<h2 id="（七）找工作"><a href="#（七）找工作" class="headerlink" title="（七）找工作"></a>（七）找工作</h2><h3 id="7-1-刷题"><a href="#7-1-刷题" class="headerlink" title="7.1 刷题"></a>7.1 刷题</h3><h4 id="1-Leetcode-推荐刷题顺序"><a href="#1-Leetcode-推荐刷题顺序" class="headerlink" title="(1) Leetcode 推荐刷题顺序"></a><a href="https://www.bilibili.com/read/cv9904414">(1) Leetcode 推荐刷题顺序</a></h4><h4 id="2-代码随想录"><a href="#2-代码随想录" class="headerlink" title="(2) 代码随想录"></a><a href="https://programmercarl.com/">(2) 代码随想录</a></h4><h4 id="3-宫水三叶"><a href="#3-宫水三叶" class="headerlink" title="(3) 宫水三叶"></a><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/">(3) 宫水三叶</a></h4><h4 id="4-潇晨"><a href="#4-潇晨" class="headerlink" title="(4) 潇晨"></a><a href="https://xiaochen1024.com/">(4) 潇晨</a></h4><h3 id="7-2-八股文"><a href="#7-2-八股文" class="headerlink" title="7.2 八股文"></a>7.2 八股文</h3><h4 id="1-CS-Notes"><a href="#1-CS-Notes" class="headerlink" title="(1) CS-Notes"></a><a href="https://github.com/CyC2018/CS-Notes">(1) CS-Notes</a></h4><h4 id="2-JavaGuide"><a href="#2-JavaGuide" class="headerlink" title="(2) JavaGuide"></a><a href="https://github.com/Snailclimb/JavaGuide">(2) JavaGuide</a></h4><h3 id="7-3-面经"><a href="#7-3-面经" class="headerlink" title="7.3 面经"></a>7.3 面经</h3><p><a href="https://www.nowcoder.com/discuss/576996">迟来的秋招总结，回馈牛油，已签约字节</a> 必看</p>
<p><a href="https://www.nowcoder.com/discuss/562887">2020年最新字节高频面试（Java岗）</a></p>
<p><a href="https://www.nowcoder.com/discuss/586326">神奇的3个月突击大厂后端上岸教程</a></p>
<p><a href="https://www.nowcoder.com/discuss/593392">来自一个菜鸟的Java后端面试经验总结</a></p>
<p><a href="https://www.nowcoder.com/discuss/67733">【干货】Java程序员面试考点大合集</a></p>
<p><a href="https://www.nowcoder.com/discuss/447742">Java 面试知识点【背诵版 240题 约7w字】</a></p>
<p><a href="https://www.nowcoder.com/discuss/586266">秋招总结,我是如何拿到两百万年薪offers</a></p>
<h3 id="7-4-JAVA技术路线"><a href="#7-4-JAVA技术路线" class="headerlink" title="7.4 JAVA技术路线"></a>7.4 JAVA技术路线</h3><p><a href="https://www.r2coding.com/#/">https://www.r2coding.com/#/</a></p>
<p><a href="https://github.com/liyupi/code-roadmap">https://github.com/liyupi/code-roadmap</a></p>
<h2 id="（八）兴趣爱好"><a href="#（八）兴趣爱好" class="headerlink" title="（八）兴趣爱好"></a>（八）兴趣爱好</h2><blockquote>
<p>用来对抗人生的荒谬</p>
</blockquote>
<h4 id="8-1-羽毛球"><a href="#8-1-羽毛球" class="headerlink" title="8.1 羽毛球"></a>8.1 羽毛球</h4><p><a href="https://www.bilibili.com/video/BV1tt41117wX">林丹 VS 李宗伟</a></p>
<h4 id="8-2-游泳"><a href="#8-2-游泳" class="headerlink" title="8.2 游泳"></a>8.2 游泳</h4><p><a href="https://www.bilibili.com/video/BV1bE411H7YM">孙杨</a></p>
<p><a href="https://space.bilibili.com/7283282">梦觉教游泳</a></p>
<h4 id="8-3-围棋"><a href="#8-3-围棋" class="headerlink" title="8.3 围棋"></a>8.3 围棋</h4><p><a href="https://www.youtube.com/watch?v=5kIQ0F8iN8U">柯洁 VS alphago</a></p>
<p><a href="https://www.youtube.com/channel/UCfGY9xUbDuSGWO-t5nIC33A">Yifei Hu</a></p>
<h4 id="8-4-跑步"><a href="#8-4-跑步" class="headerlink" title="8.4 跑步"></a>8.4 跑步</h4><h4 id="8-5-写博客"><a href="#8-5-写博客" class="headerlink" title="8.5 写博客"></a>8.5 写博客</h4><p><a href="https://blog.csdn.net/qq_36903042/article/details/82228883">搭建个人博客</a></p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>1.二叉树</title>
    <url>/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h1><blockquote>
<p>二叉树：</p>
</blockquote>
<span id="more"></span>

<h3 id="遍历系列"><a href="#遍历系列" class="headerlink" title="遍历系列"></a>遍历系列</h3><h4 id="二叉树遍历：迭代统一版本"><a href="#二叉树遍历：迭代统一版本" class="headerlink" title="二叉树遍历：迭代统一版本"></a>二叉树遍历：迭代统一版本</h4><p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈：访问逆序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 添加根节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 根节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br></pre></td></tr></table></figure>

<p><strong>前序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<p><strong>后序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;left);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;right);   </span><br></pre></td></tr></table></figure>

<h4 id="144-二叉树的前序遍历-🀄️"><a href="#144-二叉树的前序遍历-🀄️" class="headerlink" title="144. 二叉树的前序遍历 🀄️"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*前，中，后，主要看根在哪。</span></span><br><span class="line"><span class="comment">根左右</span></span><br><span class="line"><span class="comment">⚠️：当然有些可能是根右左</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左根右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LRN</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LRN</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BST用中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root) &#123;</span><br><span class="line">         <span class="built_in">LNR</span>(root,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= res.<span class="built_in">size</span>() ? <span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="102-二叉树的层序遍历-🀄️"><a href="#102-二叉树的层序遍历-🀄️" class="headerlink" title="102. 二叉树的层序遍历 🀄️"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树的层序遍历--广度优先搜索</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    首先根元素入队</span></span><br><span class="line"><span class="comment">    当队列不为空的时候</span></span><br><span class="line"><span class="comment">        求当前队列的长度 si</span></span><br><span class="line"><span class="comment">        依次从队列中取 si个元素进行拓展，然后进入下一次迭代</span></span><br><span class="line"><span class="comment">它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 si个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si 个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;        <span class="comment">//存储每一层的结点值</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;	<span class="comment">//注意🈳️树</span></span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">//树的队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);       <span class="comment">//根先进入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;  <span class="comment">//不为空</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());   <span class="comment">//先放入一个vector&lt;int&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();            <span class="comment">//取出队头，并删除队头</span></span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);        <span class="comment">//根结点值存入vector&lt;int&gt;</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)  q.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左结点不空,进入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)  q.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右结点不空,进入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根结点的插入顺序不一样。</span></span><br><span class="line"><span class="comment">    如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。</span></span><br><span class="line"><span class="comment">    如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">//从左到右</span></span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(flag) res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);               <span class="comment">//插入到最后面</span></span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">back</span>().<span class="built_in">insert</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),node-&gt;val);   <span class="comment">//插入到最前面</span></span><br><span class="line">                   </span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：返回其节点值自底向上的层序遍历</span></span><br><span class="line"><span class="comment">思路：只需要将每次层序遍历的结点的容器插入到结果最前面就可以了，这样后面遍历的就变成前面的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">       queue&lt;TreeNode *&gt; q;</span><br><span class="line">       q.<span class="built_in">push</span>(root);</span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">           <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">           vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">               <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">               t.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">           &#125;</span><br><span class="line">           res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),t);   <span class="comment">//插入到最前面</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树的深度遍历和先根遍历基本上是一样的,只是先根遍历有左右之分,而深度遍历没有左右之分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路1:层序遍历，记录下每层的最后一个元素。</span></span><br><span class="line"><span class="comment">思路2:先序遍历(这里是根右左)，记录下每层的第一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == s - <span class="number">1</span>) res.<span class="built_in">push_back</span>(node-&gt;val);    <span class="comment">//⚠️保存最后一个</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/116_sample.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度O(n)</span></span><br><span class="line"><span class="comment">思路：用层序遍历，这样我们可以在遍历每一层的时候修改这一层节点的 next 指针，这样就可以把每一层都组织成链表。</span></span><br><span class="line"><span class="comment">（初始状态下，所有 next 指针都被设置为 NULL。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;      <span class="comment">//层序遍历</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; s - <span class="number">1</span>) node-&gt;next = q.<span class="built_in">front</span>();  <span class="comment">//⚠️前面的指向后面，front()查询队头元素</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II-⭐️"><a href="#117-填充每个节点的下一个右侧节点指针-II-⭐️" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II ⭐️"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> ⭐️</h4><p><img src="/Users/zcz/Desktop/images/image-20220428104511190.png" alt="image-20220428104511190"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：使用已建立的 next 指针，cur 指针利用 next 不停的遍历当前层。</span></span><br><span class="line"><span class="comment">	1）如果 cur 的左右孩子不为 null 就将它接到 tail 后边，然后更新tail。</span></span><br><span class="line"><span class="comment">	2）当 cur 为 null 的时候，再利用 dummy 指针得到下一层的开始节点。</span></span><br><span class="line"><span class="comment">	遍历完每一层。就要将dummy-&gt;next赋值给cur</span></span><br><span class="line"><span class="comment">dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            Node* tail = dummy;  <span class="comment">//赋值给tail</span></span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) &#123;tail-&gt;next = cur-&gt;left;tail = tail-&gt;next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) &#123;tail-&gt;next = cur-&gt;right;tail= tail-&gt;next;&#125;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同103</span><br></pre></td></tr></table></figure>



<h3 id="BST-中序遍历"><a href="#BST-中序遍历" class="headerlink" title="BST+中序遍历"></a>BST+中序遍历</h3><h4 id="98-验证二叉搜索树-⭐️"><a href="#98-验证二叉搜索树-⭐️" class="headerlink" title="98. 验证二叉搜索树 ⭐️"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉搜索树</span></span><br><span class="line"><span class="comment">1.左子树上所有结点的值均&lt;它的根结点的值。</span></span><br><span class="line"><span class="comment">2.右子树上所有结点的值均&gt;它的根结点的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">先序遍历</span></span><br><span class="line"><span class="comment">遍历时，不仅左结点小于根结点，根结点大于右结点。而是要整个左子树&lt;根&lt;右子树。此时需要保存子树的上界和下界。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。</span></span><br><span class="line"><span class="comment">同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> low,<span class="keyword">long</span> <span class="keyword">long</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">//本身空或者遍历完</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断根结点值(是否越界)，再遍历左子树，右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,low,root-&gt;val) &amp;&amp; <span class="built_in">check</span>(root-&gt;right,root-&gt;val,high); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root,LONG_MIN,LONG_MAX);<span class="comment">//要long long(32,64都是8字节) </span></span><br><span class="line">      																			 <span class="comment">//或者long(32位 4字节，64位8子节)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="99-恢复二叉搜索树-⭐️难"><a href="#99-恢复二叉搜索树-⭐️难" class="headerlink" title="99. 恢复二叉搜索树 ⭐️难"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a> ⭐️难</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/26e9f631ec22f42f50099cf4fd9a55510ad0e7b0a4a836c772b6850591ddb737-image.png" alt="image.png"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/fde85797d0aa3cee9f8a84f39e820aed269f6c45b8eaf4d0672489c08f98090b-4.png" alt="4.jpg"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20211119191906437.png" alt="image-20211119191906437"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3种解法：</span></span><br><span class="line"><span class="comment">1.先弄个vector容器。 再摘下“树”上的数据（中序遍历）。 然后vector排序。 再把vector容器里的数据挂在“树上”（中序遍历）。 </span></span><br><span class="line"><span class="comment">时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">2.只用比较前后访问的节点值，prev 保存上一个访问的节点，当前访问的是 root 节点。</span></span><br><span class="line"><span class="comment">每访问一个节点，如果prev.val&gt;=root.val，就找到了一对“错误对”。</span></span><br><span class="line"><span class="comment">检查一下它是第一对错误对，还是第二对错误对。</span></span><br><span class="line"><span class="comment">遍历结束，就确定了待交换的两个错误点，进行交换。</span></span><br><span class="line"><span class="comment">时间复杂度O(N)，N是节点个数</span></span><br><span class="line"><span class="comment">空间复杂度O(H)，递归栈的深度</span></span><br><span class="line"><span class="comment">3. Morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，Morris遍历可以将非递归遍历中的空间复杂度降为O(1)</span></span><br><span class="line"><span class="comment">Morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      TreeNode* err1=<span class="literal">nullptr</span>;</span><br><span class="line">      TreeNode* err2=<span class="literal">nullptr</span>;</span><br><span class="line">      TreeNode* prev=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);	</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">LNR</span>(root-&gt;left);</span><br><span class="line">          <span class="comment">// 记录第一个错误点</span></span><br><span class="line">          <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 == <span class="literal">nullptr</span>) err1 = prev;</span><br><span class="line">          <span class="comment">// 第一个错误点已确定,记录第二个错误点</span></span><br><span class="line">          <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 != <span class="literal">nullptr</span>) err2 = root;</span><br><span class="line">          prev = root;    <span class="comment">//更新prev</span></span><br><span class="line">          <span class="built_in">LNR</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LNR</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(err1-&gt;val,err2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *x = <span class="literal">nullptr</span>, *y = <span class="literal">nullptr</span>, *pred = <span class="literal">nullptr</span>, *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// (1)predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// (2)让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    predecessor-&gt;right = root; </span><br><span class="line">                    root = root-&gt;left;          <span class="comment">//访问左孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (3)说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//记录错误结点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                        x = root;</span><br><span class="line">                        <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                            y = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pred = root; <span class="comment">//更新pred</span></span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>; <span class="comment">//置为空</span></span><br><span class="line">                    root = root-&gt;right;           <span class="comment">//访问右孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录错误结点</span></span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                    x = root;</span><br><span class="line">                    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        y = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pred = root;<span class="comment">//更新pred</span></span><br><span class="line">                root = root-&gt;right; <span class="comment">//直接访问右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val, y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思路：中序遍历完就是一个递增的序列，取出第k个元素就是第k小的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历(⚠️这里是右根左，由于是递归)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RNL</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RNL</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉树的下一个结点-⭐️"><a href="#8-二叉树的下一个结点-⭐️" class="headerlink" title="8.二叉树的下一个结点 ⭐️"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">8.二叉树的下一个结点</a> ⭐️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前驱节点：当前节点左子树的最右节点</span></span><br><span class="line"><span class="comment">后继节点：当前节点右子树的最左节点</span></span><br><span class="line"><span class="comment">（最左节点是中序遍历（左根右）的第一个节点。）</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）当前节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</span></span><br><span class="line"><span class="comment">2）否则，向上找第一个左指针指向的树包含该节点的祖先节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode right = pNode.right;	<span class="comment">//1）右子树</span></span><br><span class="line">            <span class="keyword">while</span>(right.left != <span class="keyword">null</span>)					<span class="comment">//最左节点</span></span><br><span class="line">                right = right.left;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123; <span class="comment">//2）⚠️找出其父结点</span></span><br><span class="line">                TreeLinkNode root = pNode.next;<span class="comment">//pNode是root的子结点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == pNode)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                pNode  = pNode.next;<span class="comment">//继续向上找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="285-二叉搜索树的后续结点⭐️"><a href="#285-二叉搜索树的后续结点⭐️" class="headerlink" title="285.二叉搜索树的后续结点⭐️"></a><a href="https://leetcode-cn.com/problems/inorder-successor-in-bst/">285.二叉搜索树的后续结点</a>⭐️</h4><p>给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。</p>
<p>结点 p 的后继是值<strong>比 p.val 大</strong>的结点中<strong>键值最小</strong>的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果p比当前节点小，说明在左子树，res=root；否则去右子树搜索。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val) &#123;	<span class="comment">//root 右子树的最左</span></span><br><span class="line">                res = root;	<span class="comment">//root 键值最小，最左边⚠️</span></span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;			<span class="comment">//root 左子树的最右</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="272-最接近的二叉搜索树值2"><a href="#272-最接近的二叉搜索树值2" class="headerlink" title="272.最接近的二叉搜索树值2"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/">272.最接近的二叉搜索树值2</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-36-二叉搜索树与双向链表⭐️"><a href="#剑指-Offer-36-二叉搜索树与双向链表⭐️" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表⭐️"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a>⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">题意：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span></span><br><span class="line"><span class="comment">排序的双向链表=&gt;中序遍历：</span></span><br><span class="line"><span class="comment">思路：中序遍历</span></span><br><span class="line"><span class="comment">1）递归左子树</span></span><br><span class="line"><span class="comment">2）cur.left = pre ，也构建 pre.right = cur </span></span><br><span class="line"><span class="comment">3）更新pre</span></span><br><span class="line"><span class="comment">4）head指向当前节点cur</span></span><br><span class="line"><span class="comment">5）递归右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *pre, *head; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = pre; </span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) </span><br><span class="line">            pre-&gt;right = root;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;	<span class="comment">//循环双向链表</span></span><br><span class="line">        pre-&gt;right = head; </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T,S:O(n^2) 根左右</span></span><br><span class="line"><span class="comment">思路：先序遍历，发现叶子结点就加入结果集中；没有就继续递归左右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode* root,string path,vector&lt;string&gt; &amp;res)</span></span>&#123; <span class="comment">//⚠️string类不加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">//叶子结点，加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//不是叶子结点，递归左右子树</span></span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;left,path,res);</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;right,path,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">getPath</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270.最接近的二叉搜索树值"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">270.最接近的二叉搜索树值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="255-验证前序遍历序列二叉搜索树"><a href="#255-验证前序遍历序列二叉搜索树" class="headerlink" title="255.验证前序遍历序列二叉搜索树"></a><a href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/">255.验证前序遍历序列二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序遍历将二叉树取下来，再遍历一遍变成链表</span></span><br><span class="line"><span class="comment">⚠️：前一个节点的左孩子为空，当前结点赋值给前一个节点的右孩子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">int</span> s =res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s;i++)&#123;</span><br><span class="line">            TreeNode* prev = res[i<span class="number">-1</span>],*cur = res[i];</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;   <span class="comment">//前驱结点为空</span></span><br><span class="line">            prev-&gt;right = cur;      <span class="comment">//前驱结点的右结点为当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode* root,vector&lt;TreeNode*&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156.上下翻转二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-upside-down/">156.上下翻转二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4><h4 id="297-二叉树的序列化与反序列化-💣"><a href="#297-二叉树的序列化与反序列化-💣" class="headerlink" title="297. 二叉树的序列化与反序列化 💣"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a> 💣</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*序列化：二叉树转换为&quot;&#123;1,2,3,#,#,6,7&#125;&quot;；</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">反序列化：&quot;&#123;1,2,3,#,#,6,7&#125;&quot;转换为二叉树</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）取出空格的下标</span></span><br><span class="line"><span class="comment">2）取出deserializeStr空格前的字符串（当前节点），没有空格则是最后一个节点</span></span><br><span class="line"><span class="comment">3）更新deserializeStr（空格后的字符串）</span></span><br><span class="line"><span class="comment">4）创建根节点</span></span><br><span class="line"><span class="comment">5）递归创建左右子树</span></span><br><span class="line"><span class="comment">6）返回根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string deserializeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot; &quot;</span>+<span class="built_in">serialize</span>(root-&gt;left)+<span class="string">&quot; &quot;</span>+<span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">my_deserialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deserializeStr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> index = deserializeStr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        string node =  index == <span class="number">-1</span> ? deserializeStr:deserializeStr.<span class="built_in">substr</span>(<span class="number">0</span>,index);<span class="comment">//空格前的字符串,不包括index</span></span><br><span class="line">        deserializeStr = index == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span>:deserializeStr.<span class="built_in">substr</span>(index+<span class="number">1</span>);<span class="comment">//空格后的字符串，更新deserializeStr</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">atoi</span>(node.<span class="built_in">c_str</span>());</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        cur-&gt;left = <span class="built_in">my_deserialize</span>();</span><br><span class="line">        cur-&gt;right = <span class="built_in">my_deserialize</span>();</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        deserializeStr = data;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">my_deserialize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列💣"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列💣" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列💣"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>💣</h4><p><img src="/Users/zcz/Desktop/images/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png" alt="Picture10.png"></p>
<p><img src="/Users/zcz/Desktop/images/image-20220227172451571.png" alt="image-20220227172451571"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历倒序==先序遍历的镜像， 左右根</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调栈 存储值递增</span></span><br><span class="line"><span class="comment">倒序遍历序列</span></span><br><span class="line"><span class="comment">1）左子树大于root，直接false</span></span><br><span class="line"><span class="comment">2）保证左子树&lt;右子树，更新root</span></span><br><span class="line"><span class="comment">3）将当前数据进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;		<span class="comment">//先赋值最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//倒序</span></span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="keyword">false</span>;	<span class="comment">//保证左子树&lt;root</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;postorder[i] &lt; stack.peek()  ) <span class="comment">//保证 左子树 &lt; 右子树</span></span><br><span class="line">                root = stack.pop();	<span class="comment">//更新root</span></span><br><span class="line">            stack.add(postorder[i]);<span class="comment">//单调递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="计算个数，通过界定-1-n-求解"><a href="#计算个数，通过界定-1-n-求解" class="headerlink" title="计算个数，通过界定(1,n)求解"></a>计算个数，通过界定(1,n)求解</h3><h4 id="95-不同的二叉搜索树-II-⭐️"><a href="#95-不同的二叉搜索树-II-⭐️" class="headerlink" title="95. 不同的二叉搜索树 II ⭐️"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">如果我们枚举根节点的值为 i，</span></span><br><span class="line"><span class="comment">那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]</span></span><br><span class="line"><span class="comment">再枚举左，右子树，挂到根结点上，将根结点加入到结果集中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st &gt; ed) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;<span class="comment">//&#123;nullptr&#125; 长度为1，&#123;&#125;长度为0</span></span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=st;i &lt;= ed; i++)&#123;</span><br><span class="line">            <span class="comment">//获得所有可行的左子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; lTrees = <span class="built_in">generateTrees</span>(st,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//获得所有可行的右子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rTrees = <span class="built_in">generateTrees</span>(i+<span class="number">1</span>,ed);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; l:lTrees)&#123;    <span class="comment">//枚举左，右子树，挂到根结点上</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; r:rTrees)&#123;</span><br><span class="line">                    TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);  <span class="comment">//根结点</span></span><br><span class="line">                    allTrees.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    cur-&gt;left = l;</span><br><span class="line">                    cur-&gt;right = r;         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="先左右后自己"><a href="#先左右后自己" class="headerlink" title="先左右后自己"></a>先左右后自己</h3><h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306160658602.png" alt="image-20210306160658602"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306161232086.png" alt="image-20210306161232086"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</span></span><br><span class="line"><span class="comment">卡特兰数G(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:,</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += <span class="built_in">numTrees</span>(i - <span class="number">1</span>) * <span class="built_in">numTrees</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和-🀄️⭐️"><a href="#124-二叉树中的最大路径和-🀄️⭐️" class="headerlink" title="124. 二叉树中的最大路径和 🀄️⭐️"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 🀄️⭐️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095058804.png" alt="image-20210308095058804"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">题意：给你一个二叉树的根节点 root ，返回其最大路径和</span></span><br><span class="line"><span class="comment">思路：考虑一个二叉树单元：有3种情况：a+b+c,a+b,a+c</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  b   c</span></span><br><span class="line"><span class="comment">递归左右子树，更新3种情况的最大和，返回较大值a+max(b,+c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;left),<span class="number">0</span>); <span class="comment">//子问题:取max，如果结点负数就取0</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;right),<span class="number">0</span>);<span class="comment">//子问题</span></span><br><span class="line">        res = <span class="built_in">max</span>(res,l + r + root-&gt;val);	<span class="comment">//额外：人字形答案</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l,r);	<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果root等于q或者p，或者NULL，直接返回root</span></span><br><span class="line"><span class="comment">递归左子树</span></span><br><span class="line"><span class="comment">递归右子树</span></span><br><span class="line"><span class="comment">左结点，右结点都不为空，返回root（最终答案）</span></span><br><span class="line"><span class="comment">返回 左结点或者右结点，哪个不空返回哪个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span> &amp;&amp; r != <span class="literal">NULL</span>) <span class="keyword">return</span> root;	<span class="comment">//左右子树不空</span></span><br><span class="line">        <span class="keyword">return</span> l!=<span class="literal">NULL</span>?l:r;	<span class="comment">//哪个不空，返回哪个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="250-统计同值子树"><a href="#250-统计同值子树" class="headerlink" title="250.统计同值子树"></a><a href="https://leetcode-cn.com/problems/count-univalue-subtrees/">250.统计同值子树</a></h4><p>给定一个二叉树，统计该二叉树数值相同的子树个数。</p>
<p>同值子树是指该子树的所有节点都拥有相同的数值。</p>
<p>示例：</p>
<p>输入: root = [5,1,5,5,5,null,5]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   5</span><br><span class="line"> / \   \</span><br><span class="line">5   5   5</span><br></pre></td></tr></table></figure>

<p>输出: 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="333-最大BST子树"><a href="#333-最大BST子树" class="headerlink" title="333.最大BST子树"></a><a href="https://leetcode-cn.com/problems/largest-bst-subtree/">333.最大BST子树</a></h4><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="先自己后左右"><a href="#先自己后左右" class="headerlink" title="先自己后左右"></a>先自己后左右</h3><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.如果两个二叉树都为空，则两个二叉树相同。</span></span><br><span class="line"><span class="comment">2.如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，</span></span><br><span class="line"><span class="comment">4.若不相同则两个二叉树一定不同，若相同，</span></span><br><span class="line"><span class="comment">  再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</span></span><br><span class="line"><span class="comment">  这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;      <span class="comment">//都为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//1个为空，1个不空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p-&gt;val != q-&gt;val)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//值不相等</span></span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);&#125; <span class="comment">//值相等，递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h4 id="剑指-Offer-55-I-二叉树的深度-同上"><a href="#剑指-Offer-55-I-二叉树的深度-同上" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度 同上"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a> 同上</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095241593.png" alt="image-20210308095241593"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">思路：如果为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+max（左子树的深度，右子树的深度）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));	<span class="comment">//根结点+左右子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的结点数"><a href="#获取二叉树的结点数" class="headerlink" title="获取二叉树的结点数"></a>获取二叉树的结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAllNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">getAllNode</span>(root-&gt;left)+<span class="built_in">getAllNode</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的叶子结点数"><a href="#获取二叉树的叶子结点数" class="headerlink" title="获取二叉树的叶子结点数"></a>获取二叉树的叶子结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果根结点为空，直接返回0</span></span><br><span class="line"><span class="comment">如果左结点和右结点同时为空，直接返回1</span></span><br><span class="line"><span class="comment">返回 递归左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leafCount</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">leafCount</span>(root-&gt;left)+<span class="built_in">leafCount</span>(root-&gt;right);<span class="comment">//不包含根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="某结点是否在二叉树中"><a href="#某结点是否在二叉树中" class="headerlink" title="某结点是否在二叉树中"></a>某结点是否在二叉树中</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isExist</span><span class="params">(TreeNode* root,TreeNode* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val == p-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//根</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isExist</span>(root-&gt;left,p)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//左</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isExist</span>(root-&gt;right,p);			<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><h4 id="105-从前序与中序遍历序列构造二叉树-🀄️"><a href="#105-从前序与中序遍历序列构造二叉树-🀄️" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 🀄️"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210306175110221.png" alt="image-20210306175110221"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306175018888.png" alt="image-20210306175018888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序的第一个就是根结点，取出来；</span></span><br><span class="line"><span class="comment">再查找根结点在中序中的位置；</span></span><br><span class="line"><span class="comment">然后递归寻找前序和中序的左区间，右区间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;    <span class="comment">//超出范围</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preL];           <span class="comment">//先序遍历的第一个是根，取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];              <span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);  <span class="comment">//new根结点</span></span><br><span class="line">        <span class="comment">//前序，中序的左区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(preorder,preL+<span class="number">1</span>,pIndex-inL+preL,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//前序，中序的右区间</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(preorder,pIndex-inL+preL+<span class="number">1</span>,preR,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = preorder.<span class="built_in">size</span>();   <span class="comment">//前序结点数</span></span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();     <span class="comment">//中序结点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; inLen; i++) map.<span class="built_in">insert</span>(&#123;inorder[i],i&#125;);   <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(preorder,<span class="number">0</span>,preLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306194848625.png" alt="image-20210306194848625"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同105相同的思路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> postL,<span class="keyword">int</span> postR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postL &gt; postR || inL &gt;inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postR];	<span class="comment">//取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];	<span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">      	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);	<span class="comment">//new根结点</span></span><br><span class="line">				<span class="comment">//前序，后序的左区间  以及 //前序，后序的右区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(postorder,postL,postL+pIndex-inL<span class="number">-1</span>,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(postorder,postL+pIndex-inL,postR<span class="number">-1</span>,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();		<span class="comment">//后序结点数</span></span><br><span class="line">        <span class="keyword">int</span> postLen = postorder.<span class="built_in">size</span>();		<span class="comment">//前序结点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++) map[inorder[i]]=i;; <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(postorder,<span class="number">0</span>,postLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h4><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：同109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(nums,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="109-有序链表转换二叉搜索树-🀄️"><a href="#109-有序链表转换二叉搜索树-🀄️" class="headerlink" title="109. 有序链表转换二叉搜索树 🀄️"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将有序数组转换为二叉搜索树,并且高度平衡</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">构造出的二叉搜索树的中序遍历结果就是链表本身，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。</span></span><br><span class="line"><span class="comment">	中位数节点对应的编号为 mid=left+(right-left)/2+1；</span></span><br><span class="line"><span class="comment">	左右子树对应的编号范围分别为 [left,mid−1] 和 [mid+1,right]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组下标0,1,2,3,4 区别 </span></span><br><span class="line"><span class="comment">(r+l+1)/2			(1)	2 1 0 4 3	区间右边优先</span></span><br><span class="line"><span class="comment">l+(r-l)/2			(2)	2 0 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">while</span>(head)&#123;head = head-&gt;next;len++;&#125;</span><br><span class="line">        	<span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode*  <span class="title">buildTree</span><span class="params">(ListNode* &amp;head,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//⚠️记得head加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (r+l)&gt;&gt;<span class="number">1</span>;                    <span class="comment">//⚠️中间结点为根结点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();        <span class="comment">//根结点</span></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(head,l,mid<span class="number">-1</span>);   <span class="comment">//递归左子树</span></span><br><span class="line">        root-&gt;val = head-&gt;val;                  <span class="comment">//⚠️中序必须这里赋值给根结点</span></span><br><span class="line">        head = head-&gt;next;                      <span class="comment">//⚠️注意更新head</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(head,mid+<span class="number">1</span>,r);  <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">getLength</span>(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//获取左右子树的高度，如果abs(right-left) &gt; 1，则不是平衡树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l= <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>) res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">找出2个原始状态：为空直接返回0；左右结点为空，返回1；</span></span><br><span class="line"><span class="comment">再递归左子树，右子树的最小深度，取较小的+1就是答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right),res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(H) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4><h4 id="剑指-Offer-34-二叉树中和为某一值的路径💣"><a href="#剑指-Offer-34-二叉树中和为某一值的路径💣" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径💣"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径💣</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减去root.val，递归左右子树</span></span><br><span class="line"><span class="comment">/*T,S:O(N)</span></span><br><span class="line"><span class="comment">思路：1）根左右遍历；选择当前值，更新目标值</span></span><br><span class="line"><span class="comment">2）路径记录（判断是否符合，符合就加入结果集）</span></span><br><span class="line"><span class="comment">3）递归左右子树</span></span><br><span class="line"><span class="comment">4）撤销选择（回溯）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum,vector&lt;<span class="keyword">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum,path);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum,path);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum,vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="437-路径总和-III🀄️"><a href="#437-路径总和-III🀄️" class="headerlink" title="437. 路径总和 III🀄️"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="comment">2.前缀和：T,S:O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">路径数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetSum == root-&gt;val) res++;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum);    <span class="comment">//先递归根结点到叶子结点的路径；再递归子树的路径</span></span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1110-删点成林-🀄️"><a href="#1110-删点成林-🀄️" class="headerlink" title="1110. 删点成林 🀄️"></a><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(n) S:O(H+N)</span></span><br><span class="line"><span class="comment">思路：先序遍历：如果 node 是root 而且没有被删除，则加入答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; to_delete_set;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : to_delete) <span class="comment">//1.存入set</span></span><br><span class="line">            to_delete_set.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="built_in">helper</span>(root, result, to_delete_set, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, vector&lt;TreeNode*&gt;&amp; result, set&lt;<span class="keyword">int</span>&gt;&amp; to_delete_set, <span class="keyword">bool</span> is_root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> deleted = to_delete_set.<span class="built_in">count</span>(node-&gt;val);    <span class="comment">//2.判断是否删除</span></span><br><span class="line">        <span class="keyword">if</span> (is_root &amp;&amp; !deleted) result.<span class="built_in">push_back</span>(node);    <span class="comment">//是根结点且不删除</span></span><br><span class="line">        node-&gt;left = <span class="built_in">helper</span>(node-&gt;left, result, to_delete_set, deleted);</span><br><span class="line">        node-&gt;right =  <span class="built_in">helper</span>(node-&gt;right, result, to_delete_set, deleted);</span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="literal">NULL</span> : node;  <span class="comment">//3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="129-求根到叶子节点数字之和-🀄️⭐️"><a href="#129-求根到叶子节点数字之和-🀄️⭐️" class="headerlink" title="129. 求根到叶子节点数字之和 🀄️⭐️"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a> 🀄️⭐️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095648125.png" alt="image-20210308095648125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*从上到下:先序遍历</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_sum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;<span class="comment">//base case 根结点</span></span><br><span class="line">        num = root-&gt;val+num*<span class="number">10</span>;     </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) res += num; <span class="comment">//base case 叶结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">get_sum</span>(root-&gt;left,num);     <span class="comment">//子问题</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">get_sum</span>(root-&gt;right,num);   <span class="comment">//子问题</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">get_sum</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(log⁡2n) S:O(1)</span></span><br><span class="line"><span class="comment">思路：二分查找 + 位运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><blockquote>
<p>Q： 为何需要暂存 root的左子节点？<br>A： 在递归右子节点 “root.left=mirrorTree(root.right);” 执行完毕后， root.left的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T，S：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210722224510100.png" alt="image-20210722224510100"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="298-二叉树最长连续序列🀄️⭐️"><a href="#298-二叉树最长连续序列🀄️⭐️" class="headerlink" title="298.二叉树最长连续序列🀄️⭐️"></a><a href="https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence/">298.二叉树最长连续序列</a>🀄️⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历：自顶向下：T,S:O(n)</span></span><br><span class="line"><span class="comment">//先递归根结点length =(parent != null &amp;&amp; p.val == parent.val + 1)? length + 1 : 1;再递归左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root, null, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode p, TreeNode parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == null) <span class="keyword">return</span> length;</span><br><span class="line">    length = (parent != null &amp;&amp; p.val == parent.val + <span class="number">1</span>) ? length + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(length, Math.<span class="built_in">max</span>(<span class="built_in">dfs</span>(p.left, p, length),</span><br><span class="line">                                     <span class="built_in">dfs</span>(p.right, p, length)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="366-寻找二叉树的叶子结点🀄️"><a href="#366-寻找二叉树的叶子结点🀄️" class="headerlink" title="366.寻找二叉树的叶子结点🀄️"></a><a href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">366.寻找二叉树的叶子结点</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">//思路：后序遍历，深度从底向上算,叶子结点的深度为0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//depth从0开始</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//返回-1,从0开始</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= res.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findLeaves</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(s*t) S:O(max&#123;s,t&#125;)  树的深度s，t</span></span><br><span class="line"><span class="comment">//思路：转化为检查根结点，左右子树是否相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(!root &amp;&amp; !subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;left,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：先序遍历：res+=左子树的左叶子结点的val</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">NLR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* l = <span class="built_in">NLR</span>(root-&gt;left);</span><br><span class="line">        TreeNode* r = <span class="built_in">NLR</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; l-&gt;left == <span class="literal">nullptr</span> &amp;&amp; l-&gt;right ==<span class="literal">nullptr</span>) res+=l-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">NLR</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">层次遍历：每次保存第一个值 res=cur</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="538-把二叉搜索树转换为累加树-https-leetcode-cn-com-problems-find-bottom-left-tree-value"><a href="#538-把二叉搜索树转换为累加树-https-leetcode-cn-com-problems-find-bottom-left-tree-value" class="headerlink" title="538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>](<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a>)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*思路：反序中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">RNL</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RNL</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：中序遍历，pre，res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;res,<span class="keyword">int</span> &amp;pre)</span></span>&#123;<span class="comment">//⚠️引用</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res,pre);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="number">-1</span>)&#123;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,root-&gt;val-pre);</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX,pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res,pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="897-递增顺序查找树-🀄️"><a href="#897-递增顺序查找树-🀄️" class="headerlink" title="897. 递增顺序查找树 🀄️"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*中序遍历：dummyNode，中间改变指向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *resNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;left);</span><br><span class="line">        resNode-&gt;right = node;</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        resNode = node;     <span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">increasingBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        TreeNode *dummyNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        resNode = dummyNode;    <span class="comment">//dummyNode暂存头指针</span></span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="653-两数之和-IV-输入-BST🀄️"><a href="#653-两数之和-IV-输入-BST🀄️" class="headerlink" title="653. 两数之和 IV - 输入 BST🀄️"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈希表 set.count(target-root-&gt;val)</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; my_set;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(TreeNode* root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(my_set.<span class="built_in">count</span>(k-root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        my_set.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root-&gt;left,k) || <span class="built_in">find</span>(root-&gt;right,k);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点🀄️"><a href="#450-删除二叉搜索树中的节点🀄️" class="headerlink" title="450. 删除二叉搜索树中的节点🀄️"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a>🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20211125195244554.png" alt="image-20211125195244554"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：1.key&gt;root.val，删除右子树2.&lt;删除左子树 3.相等，root为叶子结点，有右结点，只有左结点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//中序遍历序列的下一个节点。即比当前节点大的最小节点（后续结点）</span></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left != <span class="literal">nullptr</span>) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//中序遍历序列的前一个节点。即比当前节点小的最大节点（前续结点）</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;right != <span class="literal">nullptr</span>) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">successor</span>(root);</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">predecessor</span>(root);</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*转化为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(subRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || subRoot == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;left,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：逻辑&amp;&amp;   T,S:O(n)</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));<span class="comment">//A &amp;&amp; B,A为false时，则不执行B</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">617.合并二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(min⁡(m,n))</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        merged-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        merged-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="654-最大二叉树-🀄️"><a href="#654-最大二叉树-🀄️" class="headerlink" title="654.最大二叉树 🀄️"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree">654.最大二叉树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先序遍历：每次取最大值作为根结点</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 寻找最大值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), mid)</span></span>;           <span class="comment">// 构建左/右部分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(mid + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(*mid);        <span class="comment">// 递归的优美</span></span><br><span class="line">        root -&gt; left = <span class="built_in">constructMaximumBinaryTree</span>(l);</span><br><span class="line">        root -&gt; right = <span class="built_in">constructMaximumBinaryTree</span>(r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="655-输出二叉树-🀄️"><a href="#655-输出二叉树-🀄️" class="headerlink" title="655.输出二叉树 🀄️"></a><a href="https://leetcode-cn.com/problems/print-binary-tree">655.输出二叉树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(h∗2^h)  h树的高度</span></span><br><span class="line"><span class="comment">思路：先序遍历+二分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">printTree</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">2</span>, m) <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 二维vector一致填充好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fill</span>(root, <span class="number">0</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        res[depth][mid] = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;left, depth+<span class="number">1</span>, begin, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;right, depth+<span class="number">1</span>, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>2.DFS/BFS+回溯</title>
    <url>/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="2-DFS-BFS-回溯"><a href="#2-DFS-BFS-回溯" class="headerlink" title="2.DFS/BFS+回溯"></a>2.DFS/BFS+回溯</h1><blockquote>
<p>回溯：</p>
<p>DFS：</p>
<p>BFS：</p>
</blockquote>
<span id="more"></span>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">模板</span><br><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line">def <span class="built_in">backtrack</span>(未探索区域, res, path):</span><br><span class="line">    <span class="keyword">if</span> 未探索区域满足结束条件:</span><br><span class="line">        res.<span class="built_in">add</span>(path) # 深度拷贝</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 未探索区域当前可能的选择:</span><br><span class="line">        <span class="keyword">if</span> 当前选择符合要求:</span><br><span class="line">            path.<span class="built_in">add</span>(作出选择)</span><br><span class="line">            <span class="built_in">backtrack</span>(新的未探索区域, res, path)</span><br><span class="line">            path.<span class="built_in">pop</span>() 撤销选择</span><br></pre></td></tr></table></figure>

<h4 id="131-分割回文串-🀄️"><a href="#131-分割回文串-🀄️" class="headerlink" title="131. 分割回文串 🀄️"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(N∗2^N)  S:O(2^N)</span></span><br><span class="line"><span class="comment">思路：经典回溯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backTrack</span>(s,res,&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(string s,vector&lt;vector&lt;string&gt;&gt; &amp;res,vector&lt;string&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;              <span class="comment">//空串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);        <span class="comment">//直接加入结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;       <span class="comment">//1.遍历所有可能,从1开始</span></span><br><span class="line">            string pre=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);       <span class="comment">//当前子串  没有取到i</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(pre))&#123;                 <span class="comment">//2.满足</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(pre);        <span class="comment">//3.作出选择 加入</span></span><br><span class="line">                <span class="built_in">backTrack</span>(s.<span class="built_in">substr</span>(i),res,path);    <span class="comment">//4.递归 前面的i-1已经匹配，现从i取到结尾</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();        <span class="comment">//5.回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">0</span>,ed=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st &lt;= ed)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[st] != s[ed]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st++;ed--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">0</span>,ed=str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st&lt;=ed)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(st)!= str.charAt(ed)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            st++;</span><br><span class="line">            ed--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> )&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            String pre = s.substring(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(check(pre))&#123;</span><br><span class="line">                path.add(pre);</span><br><span class="line">                backtrace(s.substring(i));</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        backtrace(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">backTrace</span>(candidates, i, len, target - candidates[i]);<span class="comment">//递归,i⚠️当前数可以重复选择</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;len;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtrace(i,len,candidates,target-candidates[i]);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrace(<span class="number">0</span>,len , candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;x &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;	<span class="comment">//剪枝</span></span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i+<span class="number">1</span>, len, target - candidates[i]);<span class="comment">//递归，i+1</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());	<span class="comment">//为了去重</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; x &amp;&amp; candidates[i-<span class="number">1</span>] == candidates[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtrace(i+<span class="number">1</span>,len,candidates,target-candidates[i]);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrace(<span class="number">0</span>,len,candidates,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="216-组合总和-III💣"><a href="#216-组合总和-III💣" class="headerlink" title="216. 组合总和 III💣"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a>💣</h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211126202127765.png" alt="image-20211126202127765"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能使用1-9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> k,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target &amp;&amp; output.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=(<span class="number">9</span> &gt; (target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>)?(target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>):<span class="number">9</span>);i++)&#123; <span class="comment">//剪枝</span></span><br><span class="line">            sum += i;</span><br><span class="line">            output.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,sum,k,target);</span><br><span class="line">            output.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">1</span>,<span class="number">0</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*2^n) S:O(n) </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;len;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,len,nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,len,nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原集合nums包含重复元素</span></span><br><span class="line"><span class="comment">//T:O(n*2^n) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;nums,vector&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//剪枝，去重⚠️</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);<span class="comment">//做出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,path,i+<span class="number">1</span>);<span class="comment">//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());  <span class="comment">//为了去重⚠️</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums不重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;	<span class="comment">//⚠️从0开始固定长度len</span></span><br><span class="line">            <span class="keyword">if</span> (vis[i]) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//⚠️递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums重复数字  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//vis[i - 1]没有访问过 不重复  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//s有重复 同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(string &amp;s,<span class="keyword">int</span> x,<span class="keyword">int</span> len,string &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(s[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(s,x+<span class="number">1</span>,len,path);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>(),path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A-Z 65-90 a-z 97-122  0-9 48-57</span></span><br><span class="line"><span class="comment">//搜索 T,S:O(N*2^N)   N字符串长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[x]))&#123;	<span class="comment">//数字直接回溯</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[x] = <span class="built_in">tolower</span>(s[x]);	<span class="comment">//回溯小写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">            s[x] = <span class="built_in">toupper</span>(s[x]);<span class="comment">//回溯大写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bacetrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">char</span>[] path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path[x] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; path[x] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            bacetrace(x+<span class="number">1</span>,len,path);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(path[x] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; path[x] &lt;=  <span class="string">&#x27;z&#x27;</span>))&#123;</span><br><span class="line">                path[x] += <span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            bacetrace(x+<span class="number">1</span>,len,path);</span><br><span class="line">            <span class="keyword">if</span>(!(path[x] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; path[x] &lt;=<span class="string">&#x27;Z&#x27;</span>))&#123;</span><br><span class="line">                path[x] -= <span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            bacetrace(x+<span class="number">1</span>,len,path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len= s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path = s.toCharArray();</span><br><span class="line">        bacetrace(<span class="number">0</span>,len,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-17-打印从1到最大的n位数-⭐️"><a href="#剑指-Offer-17-打印从1到最大的n位数-⭐️" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数 ⭐️"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归全排列</span></span><br><span class="line"><span class="comment">//T：O(10^n) S:O(10^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">char</span> NUM[<span class="number">10</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成长度为 len 的数字，正在确定第x位（从左往右）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = x==<span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// X=0表示左边第一位数字，不能为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(NUM[i]); <span class="comment">// 确定本位数字</span></span><br><span class="line">            <span class="built_in">backtrack</span>(x+<span class="number">1</span>, len); <span class="comment">// 确定下一位数字</span></span><br><span class="line">            cur.<span class="built_in">pop_back</span>(); <span class="comment">// 删除本位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 数字长度：1~n</span></span><br><span class="line">            <span class="built_in">backtrack</span>(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_int;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res_int.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(res[i]));</span><br><span class="line">        <span class="keyword">return</span> res_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="comment">//使用哈希表存储字符串 s 的每个下标和从该下标开始的部分可以组成的句子列表，</span></span><br><span class="line"><span class="comment">//在回溯过程中如果遇到已经访问过的下标，则可以直接从哈希表得到结果，而不需要重复计算。</span></span><br><span class="line"><span class="comment">//T,S:O(n*2^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; res;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;  <span class="comment">//哈希表，加快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        wordSet = <span class="built_in">unordered_set</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">count</span>(x)) &#123;        <span class="comment">//没有存过，进入</span></span><br><span class="line">            <span class="keyword">if</span> (x == s.<span class="built_in">size</span>()) &#123;    </span><br><span class="line">                res[x] = &#123;<span class="string">&quot;&quot;</span>&#125;;      <span class="comment">//字符串末尾</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[x] = &#123;&#125;;</span><br><span class="line">          <span class="comment">//由于substr，因此i &lt;= s.size()⚠️</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(x, i - x);   <span class="comment">//从x开始，截取i-x个</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">count</span>(word)) &#123;  <span class="comment">//当前词是否在词典中</span></span><br><span class="line">                    <span class="built_in">backtrack</span>(s, i);        <span class="comment">//i可重复</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; succ: res[i]) &#123;</span><br><span class="line">                        res[x].<span class="built_in">push_back</span>(succ.<span class="built_in">empty</span>() ? word : word + <span class="string">&quot; &quot;</span> + succ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="267-回文排列-II"><a href="#267-回文排列-II" class="headerlink" title="267.回文排列  II"></a><a href="https://leetcode-cn.com/problems/palindrome-permutation-ii/">267.回文排列  II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><a href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hours[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  <span class="comment">//从10个选num个</span></span><br><span class="line">    <span class="keyword">int</span> mins[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x,<span class="keyword">int</span> h,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">11</span> | m &gt;<span class="number">59</span>) <span class="keyword">return</span>;  <span class="comment">//不符合</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;   <span class="comment">//没有指示灯了</span></span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">6</span>];    <span class="comment">//注意这里要字符数组，不能是 string</span></span><br><span class="line">            <span class="built_in">sprintf</span>(tmp,<span class="string">&quot;%d:%02d&quot;</span>,h,m);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">backTrace</span>(num<span class="number">-1</span>,i+<span class="number">1</span>,h+hours[i],m+mins[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(num,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits.charAt(index);</span><br><span class="line">            String letters = phoneMap.get(digit);</span><br><span class="line">            <span class="keyword">int</span> lettersCount = letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="491-递增子序列-⭐️"><a href="#491-递增子序列-⭐️" class="headerlink" title="491. 递增子序列 ⭐️"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a> ⭐️</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果左括号数量不大于 n，我们可以放一个左括号。</span></span><br><span class="line"><span class="comment">如果右括号数量小于左括号的数量，我们可以放一个右括号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="200-岛屿数量-🀄️"><a href="#200-岛屿数量-🀄️" class="headerlink" title="200. 岛屿数量 🀄️"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">遍历所有点：</span></span><br><span class="line"><span class="comment">	遍历整个地图的1，记得遍历过的1赋值为0，这样就不会重复访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;    <span class="comment">//4个方向</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)  <span class="comment">//遍历所有点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;  <span class="comment">//符合条件：dfs</span></span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= row|| j&lt;<span class="number">0</span> ||j &gt;= col || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;       <span class="comment">//遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;				<span class="comment">//遍历4个方向</span></span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j+ d[<span class="number">1</span>];	</span><br><span class="line">            <span class="built_in">dfs</span>(grid,x,y);			 <span class="comment">//没有越界 dfs</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> row =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=row || j &lt;<span class="number">0</span> || j&gt;=col || grid[i][j] ==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i + dir[<span class="number">0</span>],y=j+dir[<span class="number">1</span>];</span><br><span class="line">            dfs(x,y,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(i,j,grid);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(ROW*COl)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">遍历所有点：</span></span><br><span class="line"><span class="comment">	标志为0，res=1，</span></span><br><span class="line"><span class="comment">	遍历4个方向，res+=dfs（）</span></span><br><span class="line"><span class="comment">	返回res(当前的面积)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.<span class="built_in">size</span>() || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() ||grid[i][j] != <span class="number">1</span>)<span class="comment">//提前返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;	<span class="comment">//⚠️当前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            res += <span class="built_in">dfs</span>(grid,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(grid,i,j)); <span class="comment">//取最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs =&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i&gt;=row || j&lt;<span class="number">0</span> || j&gt;=col || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+dir[<span class="number">0</span>],y=j+dir[<span class="number">1</span>];</span><br><span class="line">            res += dfs(x,y,grid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res =Math.max(res,dfs(i,j,grid));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS. T,S:O(nm)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）遇到矩阵边界或海水返回1，将返回值加入res</span></span><br><span class="line"><span class="comment">2）遍历过的标志为2,返回0</span></span><br><span class="line"><span class="comment">3）最终返回ans（当前周长）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//遍历过了</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;   </span><br><span class="line">            <span class="keyword">int</span> x=d[<span class="number">0</span>]+i,y=d[<span class="number">1</span>]+j;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid,x,y);   <span class="comment">//不用再判断 grid[i][j] == 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res += <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                  	<span class="comment">//res = max(res, dfs(grid,i,j));最大周长</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211212102721764.png" alt="image-20211212102721764"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*直接深搜：T：O(n^4)，超时</span></span><br><span class="line"><span class="comment">对于每个 0，将它变成 1，然后做一次深度优先搜索计算出连通块的大小。答案就是找到的最大连通块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以通过记录连通块编号来解决这个问题，不同的连通块编号不同。这样，我们就可以累加不同编号的连通块面积和。</span></span><br><span class="line"><span class="comment">T,S：O(n^2)，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图的连通数,T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">	无边界</span></span><br><span class="line"><span class="comment">	先按行遍历，递归</span></span><br><span class="line"><span class="comment">	再按列遍历，递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="keyword">int</span>&gt; &amp;visited,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">      	visited[i] = <span class="literal">true</span>;		<span class="comment">//标记当前结点遍历过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;   <span class="comment">//遍历下一个j</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;<span class="comment">//当前是1，并且没有访问过</span></span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">//遍历i</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;    <span class="comment">//⚠️注意没有访问过</span></span><br><span class="line">              	res++;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/">841. 钥匙和房间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n+m) S:O(n)  n 是房间的数量，m 是所有房间中的钥匙数量的总数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//能够进入的房间数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">bool</span>&gt; &amp;visited,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[x]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x] = <span class="literal">true</span>;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:rooms[x])&#123; <span class="comment">//遍历当前room[x]的所有钥匙</span></span><br><span class="line">            <span class="built_in">dfs</span>(visited,rooms,it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(visited,rooms,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms,<span class="keyword">int</span> x,<span class="keyword">boolean</span>[] vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">return</span>;</span><br><span class="line">        vis[x] = <span class="keyword">true</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:rooms.get(x))&#123;</span><br><span class="line">            dfs(rooms,i.intValue(),vis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] vis= <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dfs(rooms,<span class="number">0</span>,vis);</span><br><span class="line">        <span class="keyword">return</span> res == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="comment">//遍历一次</span></span><br><span class="line"><span class="comment">//1+各个方向的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//所有位数之和</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k,boolean[][] vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || <span class="built_in">getSum</span>(i) + <span class="built_in">getSum</span>(j) &gt; k || vis[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;   <span class="comment">//标志访问过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,j,m,n,k,vis)+<span class="built_in">dfs</span>(i+<span class="number">1</span>,j,m,n,k,vis)+<span class="built_in">dfs</span>(i,j<span class="number">-1</span>,m,n,k,vis)+<span class="built_in">dfs</span>(i,j+<span class="number">1</span>,m,n,k,vis)+<span class="number">1</span>;<span class="comment">//4个方向+当前格子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       boolean[][] vis = <span class="keyword">new</span> boolean[m][n];</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,m,n,k,vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs =&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res+= x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] vis,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getSum(i) + getSum(j) &gt; k || i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || vis[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vis[i][j] = <span class="keyword">true</span>;   <span class="comment">//标志访问过</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x  = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            res += dfs(vis,x,y,m,n,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(vis,<span class="number">0</span>,<span class="number">0</span>,m,n,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929200631155.png" alt="image-20210929200631155"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(m*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;	<span class="comment">//边界遍历到的&#x27;O&#x27;，标志为A</span></span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=x+d[<span class="number">0</span>],ty=y+d[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(board,tx,ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">dfs</span>(board,i,<span class="number">0</span>),<span class="built_in">dfs</span>(board, i, m - <span class="number">1</span>); <span class="comment">//左右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) <span class="built_in">dfs</span>(board, <span class="number">0</span>, i),<span class="built_in">dfs</span>(board, n - <span class="number">1</span>, i);<span class="comment">//上下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">//标志了，恢复了O</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=row || j&lt;<span class="number">0</span>||j&gt;=col ||board[i][j] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] =<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+dir[<span class="number">0</span>],y=j+dir[<span class="number">1</span>];</span><br><span class="line">            dfs(board,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++) &#123;dfs(board,i,<span class="number">0</span>);dfs(board,i,col-<span class="number">1</span>);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col-<span class="number">1</span>;j++) &#123;dfs(board,<span class="number">0</span>,j);dfs(board,row-<span class="number">1</span>,j);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>) board[i][j] =<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆流而上。T，S：O(m*n)</span></span><br><span class="line"><span class="comment">//P在左上 A在右下</span></span><br><span class="line"><span class="comment">//对于一个点它能流动两边的大洋，那么反过来，两边大洋的水反着流就能达到这个点。</span></span><br><span class="line"><span class="comment">//从低到高，M[x][y] &lt; M[i][j]不符合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; P, A, ans;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        n = M.<span class="built_in">size</span>(), m = M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        P = A = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//左右两边加上下两边出发深搜 ⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">dfs</span>(M, P, i, <span class="number">0</span>), <span class="built_in">dfs</span>(M, A, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">dfs</span>(M, P, <span class="number">0</span>, j), <span class="built_in">dfs</span>(M, A, n - <span class="number">1</span>, j);             </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i][j] &amp;&amp; A[i][j]) ans.<span class="built_in">push_back</span>(&#123;i,j&#125;); </span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt;<span class="number">0</span> || y&gt;=m || M[x][y] &lt; M[i][j]) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(M, visited, x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">boolean</span>[][] P;</span><br><span class="line">    <span class="keyword">boolean</span>[][] A;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] heights,<span class="keyword">boolean</span>[][] vis,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i][j] ) <span class="keyword">return</span>;</span><br><span class="line">        vis[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i][j] &amp;&amp; A[i][j]) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.add(i);tmp.add(j);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+dir[<span class="number">0</span>],y=j+dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=row || y&lt;<span class="number">0</span> || y&gt;=col || heights[x][y] &lt; heights[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(heights,vis,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] heights) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        row=heights.length;</span><br><span class="line">        col = heights[<span class="number">0</span>].length;</span><br><span class="line">        P= <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        A= <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dfs(heights,P,i,<span class="number">0</span>);</span><br><span class="line">            dfs(heights,A,i,col-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">            dfs(heights,P,<span class="number">0</span>,j);</span><br><span class="line">            dfs(heights,A,row-<span class="number">1</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="332-重新安排行程困难"><a href="#332-重新安排行程困难" class="headerlink" title="332. 重新安排行程困难"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a>困难</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">欧拉路径：能否不走重复的路而遍历一个图的所有边。</span></span><br><span class="line"><span class="comment">Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</span></span><br><span class="line"><span class="comment">  1）从起点出发，进行深度优先搜索。</span></span><br><span class="line"><span class="comment">  2）每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</span></span><br><span class="line"><span class="comment">  3）如果没有可移动的路径，则将所在节点加入到栈中，并返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,priority_queue&lt;string,vector&lt;string&gt;,greater&lt;string&gt;&gt;&gt; map;    <span class="comment">//哈希表&lt;string,小根堆&gt;</span></span><br><span class="line">    vector&lt;string&gt; res;     <span class="comment">//结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">count</span>(cur) &amp;&amp; map[cur].<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;    <span class="comment">//遍历当前结点的所有下一个结点</span></span><br><span class="line">            string tmp = map[cur].<span class="built_in">top</span>();    <span class="comment">//取出下一个结点</span></span><br><span class="line">            map[cur].<span class="built_in">pop</span>();                 <span class="comment">//删除</span></span><br><span class="line">            <span class="built_in">dfs</span>(tmp);                       <span class="comment">//以下一个结点：dfs</span></span><br><span class="line">        &#125; </span><br><span class="line">        res.<span class="built_in">emplace_back</span>(cur);              <span class="comment">//将当前结点加入结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tk:tickets) map[tk[<span class="number">0</span>]].<span class="built_in">push</span>(tk[<span class="number">1</span>]); <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());	<span class="comment">//由于递归，结果集需要反转</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;String,PriorityQueue&lt;String&gt;&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(map.containsKey(cur) &amp;&amp; map.get(cur).size() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            String tmp = map.get(cur).poll();</span><br><span class="line">            dfs(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets == <span class="keyword">null</span> || tickets.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; tk:tickets)&#123;</span><br><span class="line">            String src=tk.get(<span class="number">0</span>),des=tk.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(src))&#123;</span><br><span class="line">                map.put(src,<span class="keyword">new</span> PriorityQueue&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(src).offer(des);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="785-判断二分图💣"><a href="#785-判断二分图💣" class="headerlink" title="785. 判断二分图💣"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a>💣</h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929190037482.png" alt="image-20210929190037482"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(m+n) S:O(n)</span></span><br><span class="line"><span class="comment">二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。(转化为图着色问题：连接的2点着色不同)</span></span><br><span class="line"><span class="comment">输入：graph = [[1,3],[0,2],[1,3],[0,2]]</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment">解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="keyword">int</span>&gt;&amp; color)</span> </span>&#123;</span><br><span class="line">        color[node] = c;<span class="comment">//u</span></span><br><span class="line">        <span class="keyword">int</span> next = (c == RED ? GREEN : RED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor: graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[neighbor] == UNCOLORED) &#123;  <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(neighbor, next, graph,color);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;   <span class="comment">//提前退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (color[neighbor] != next) &#123; <span class="comment">//当前节点不是设定好next</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(n,UNCOLORED)</span></span>;</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == UNCOLORED) &#123;    <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(i, RED, graph,color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="60-排列序列-第k个排列"><a href="#60-排列序列-第k个排列" class="headerlink" title="60. 排列序列 第k个排列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a> 第k个排列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N^2) S:O(N) </span></span><br><span class="line"><span class="comment">//思路：剪枝（已访问，k&gt;叶子结点数）+DFS</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）访问过，剪枝</span></span><br><span class="line"><span class="comment">2）当前分支叶子节点数cnt&lt;k，则不在当前分支，直接剪枝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; f;	<span class="comment">//每一层的叶子节点数</span></span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = f[n<span class="number">-1</span>-x]; <span class="comment">//⚠️叶子结点个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;    <span class="comment">//（1）剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; cnt) &#123; k -= cnt;<span class="keyword">continue</span>;&#125;   <span class="comment">//（2）剪枝</span></span><br><span class="line">            res += <span class="built_in">to_string</span>(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(n,k,x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不回溯，没有回头的过程</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//后面的数没有必要遍历去尝试了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vis = vector&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>);</span><br><span class="line">        f = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i] = f[i<span class="number">-1</span>]*i;</span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="254-因子的组合"><a href="#254-因子的组合" class="headerlink" title="254.因子的组合"></a><a href="https://leetcode-cn.com/problems/factor-combinations/">254.因子的组合</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211211110937828.png" alt="image-20211211110937828"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS+剪枝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dfs</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(n));         <span class="comment">//(1)剪枝点，遍历终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;           </span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;i,n/i&#125;);</span><br><span class="line">                vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; next = <span class="built_in">dfs</span>(i,n/i);  <span class="comment">//(2)剪枝点,从i，不从1开始，避免重复</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sub:next)&#123;</span><br><span class="line">                    sub.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">getFactors</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">2</span>,n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="444-序列重建"><a href="#444-序列重建" class="headerlink" title="444. 序列重建"></a><a href="https://leetcode-cn.com/problems/sequence-reconstruction/">444. 序列重建</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n); <span class="comment">//列表存储边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : relation) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>], dst = edge[<span class="number">1</span>];</span><br><span class="line">            edges[src].<span class="built_in">push_back</span>(dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> index, <span class="keyword">int</span> steps) &#123; <span class="comment">//匿名函数</span></span><br><span class="line">            <span class="keyword">if</span> (steps == k &amp;&amp; index == n - <span class="number">1</span>)) &#123;</span><br><span class="line">                ++ways;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> to : edges[index]) </span><br><span class="line">                <span class="built_in">dfs</span>(to, steps + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> color, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= image.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= image[<span class="number">0</span>].<span class="built_in">size</span>() || image[x][y] != color )<span class="keyword">return</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            <span class="built_in">dfs</span>(image, mx, my, color, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> currColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (currColor != newColor) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>「力扣」第 684 题：<a href="https://leetcode-cn.com/problems/redundant-connection">冗余连接</a>（中等）；<br>「力扣」第 1319 题：<a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected">连通网络的操作次数</a>（中等）；<br>「力扣」第 1631 题：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort">最小体力消耗路径</a>（中等）；<br>「力扣」第 959 题：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes">由斜杠划分区域</a>（中等）；<br>「力扣」第 1202 题：<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps">交换字符串中的元素</a>（中等）；<br>「力扣」第 947 题：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column">移除最多的同行或同列石头</a>（中等）；<br>「力扣」第 721 题：<a href="https://leetcode-cn.com/problems/accounts-merge">账户合并</a>（中等）；<br>「力扣」第 803 题：<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit">打砖块</a>（困难）；<br>「力扣」第 1579 题：<a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable">保证图可完全遍历</a>（困难）;<br>「力扣」第 778 题：<a href="https://leetcode-cn.com/problems/swim-in-rising-water">水位上升的泳池中游泳</a>（困难）。</p>
<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS+回溯"></a>DFS+回溯</h3><h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929211741751.png" alt="image-20210929211741751"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数独首先行，列，还有 3*3 的方格内数字是 1~9 不能重复。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> line[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> column[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.<span class="built_in">size</span>()) &#123; <span class="comment">//递归出口 </span></span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [i, j] = spaces[pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">              	board[i][j] = digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;  <span class="comment">//x+1 转换为int</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>; <span class="comment">//标志</span></span><br><span class="line">                <span class="built_in">dfs</span>(board, pos + <span class="number">1</span>);	<span class="comment">//递归</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(column, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(column));</span><br><span class="line">        <span class="built_in">memset</span>(block, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(block));</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">      <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;  <span class="comment">//x-1</span></span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后-🀄️"><a href="#51-N-皇后-🀄️" class="headerlink" title="51. N 皇后 🀄️"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; g;</span><br><span class="line">    <span class="keyword">bool</span> col[N],gd[N*<span class="number">2</span>],rgd[N*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用 </span></span><br><span class="line">  <span class="comment">//N=10,x+y最大为18</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">           res.<span class="built_in">push_back</span>(g);	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// x+y=b 正对角线 -x+y(+n)=b&gt;=0负对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[x+y] &amp;&amp; !rgd[y-x+n])&#123;</span><br><span class="line">                g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                g[x][y] = <span class="string">&#x27;.&#x27;</span>;	<span class="comment">//恢复现场，回溯</span></span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;	<span class="comment">//初始化棋盘</span></span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) tmp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            g.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0行开始 第n列开始</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上一题改一改就可以了</span></span><br><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 按行放，再按列放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">10</span>],gd[<span class="number">10</span>*<span class="number">2</span>],rgd[<span class="number">10</span>*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">            res++;	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b =x+y 反对角线 b=y-x (+n) &gt;=0对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[y-x+n] &amp;&amp; !rgd[x+y])&#123;</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">false</span>;<span class="comment">//恢复现场，回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0个位置开始搜索</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(|s|*3^SEG_COUNT) S:O(SEG_COUNT)  ,每一段的位数不会超过 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>; <span class="comment">//ip段数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( segStart == s.<span class="built_in">size</span>())&#123; <span class="comment">//(1)</span></span><br><span class="line">                string ipAddr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                ipAddr += <span class="built_in">to_string</span>(segs[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;   <span class="comment">//不是最后一个都加&#x27;.&#x27;</span></span><br><span class="line">                        ipAddr += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">move</span>(ipAddr));    <span class="comment">//move()只是转移,提高利用效率</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//(2)4 段 IP 地址达到了，但是字符串没有遍历完，直接回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// (3)如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4)由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s[segStart] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segs[segId] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.<span class="built_in">size</span>(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s[segEnd] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转化为int</span></span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;<span class="comment">//在0-255范围内就加入</span></span><br><span class="line">                segs[segId] = addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segs.<span class="built_in">resize</span>(SEG_COUNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h4><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(min(L,MN))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,string &amp;word,<span class="keyword">int</span> k,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//不同</span></span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">length</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;               <span class="comment">//选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir: dirs) &#123;       <span class="comment">//递归搜索</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = <span class="built_in">dfs</span>(board, x, y, word, k + <span class="number">1</span>,visited);</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;	<span class="comment">//有一个符合就返回</span></span><br><span class="line">                        res = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;              <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">visited</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m)); <span class="comment">//二维</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> falg = <span class="built_in">dfs</span>(board,i,j,word,<span class="number">0</span>,visited);</span><br><span class="line">                <span class="keyword">if</span>(falg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211002001203923.png" alt="image-20211002001203923"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀树+DFS+回溯</span></span><br><span class="line"><span class="comment">//用字典树剪枝</span></span><br><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(k×L)，其中 k 是字典 words列表 的长度，L 是最长单词的长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    string word;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,TrieNode *&gt; children;</span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children.<span class="built_in">count</span>(c)) &#123;	<span class="comment">//没有，加入</span></span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];<span class="comment">//当前指向child</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool searchPrefix(TrieNode* root,string prefix) &#123;</span></span><br><span class="line"><span class="comment">  TrieNode* node = root;</span></span><br><span class="line"><span class="comment">  for (char ch : prefix) &#123;</span></span><br><span class="line"><span class="comment">    if (!node-&gt;children.count(ch)) &#123;</span></span><br><span class="line"><span class="comment">      return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    node = node-&gt;children[ch];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = board[i][j];        </span><br><span class="line">      	<span class="comment">//如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">count</span>(ch)) &#123;    <span class="comment">//字典words中没有该ch前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = root-&gt;children[ch];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;word.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;    <span class="comment">//加入当前ch</span></span><br><span class="line">            res.<span class="built_in">insert</span>(root-&gt;word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;      <span class="comment">//选择(标志)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir:dirs) &#123;   <span class="comment">//搜素</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>],y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">dfs</span>(board, x, y, root,res);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = ch;   <span class="comment">//撤销选择</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp; board, vector&lt;string&gt; &amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode * root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        set&lt;string&gt; res;    <span class="comment">//去重</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造字典树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: words)&#123;</span><br><span class="line">            <span class="built_in">insertTrie</span>(root,word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, root, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: res) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h4 id="934-最短的桥-🀄️"><a href="#934-最短的桥-🀄️" class="headerlink" title="934. 最短的桥 🀄️"></a><a href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a> 🀄️</h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/1638328692-YrAjMu-1.png" alt="1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="126-单词接龙-II-🀄️-BFS-图的构建"><a href="#126-单词接龙-II-🀄️-BFS-图的构建" class="headerlink" title="126. 单词接龙 II 🀄️  BFS+图的构建"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a> 🀄️  BFS+图的构建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="127-单词接龙-BFS-图的构建"><a href="#127-单词接龙-BFS-图的构建" class="headerlink" title="127. 单词接龙  BFS+图的构建"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a>  BFS+图的构建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="286-墙与门-BFS-去重"><a href="#286-墙与门-BFS-去重" class="headerlink" title="286.墙与门 BFS+去重"></a><a href="https://leetcode-cn.com/problems/walls-and-gates/">286.墙与门</a> BFS+去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="301-删除无效的括号-不错"><a href="#301-删除无效的括号-不错" class="headerlink" title="301. 删除无效的括号 不错"></a><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a> 不错</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="310-最小高度树-不错"><a href="#310-最小高度树-不错" class="headerlink" title="310. 最小高度树 不错"></a><a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a> 不错</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="317-离建筑物最近的距离"><a href="#317-离建筑物最近的距离" class="headerlink" title="317.离建筑物最近的距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/">317.离建筑物最近的距离</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="133-克隆图-BFS-哈希"><a href="#133-克隆图-BFS-哈希" class="headerlink" title="133. 克隆图 BFS+哈希"></a><a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a> BFS+哈希</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="261-以图判树-BFS-并查集"><a href="#261-以图判树-BFS-并查集" class="headerlink" title="261.以图判树 BFS+并查集"></a><a href="https://leetcode-cn.com/problems/graph-valid-tree/">261.以图判树</a> BFS+并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="323-无向图中连通分量的数目-BFS-二维数组"><a href="#323-无向图中连通分量的数目-BFS-二维数组" class="headerlink" title="323.无向图中连通分量的数目 BFS+二维数组"></a><a href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/">323.无向图中连通分量的数目</a> BFS+二维数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="490-迷宫"><a href="#490-迷宫" class="headerlink" title="490. 迷宫"></a><a href="https://leetcode-cn.com/problems/the-maze/">490. 迷宫</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//一直走，直到遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;		<span class="comment">//没有访问过</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="505-迷宫-II"><a href="#505-迷宫-II" class="headerlink" title="505. 迷宫 II"></a><a href="https://leetcode-cn.com/problems/the-maze-ii/">505. 迷宫 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="499-迷宫-III"><a href="#499-迷宫-III" class="headerlink" title="499. 迷宫 III"></a><a href="https://leetcode-cn.com/problems/the-maze-iii/">499. 迷宫 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="HJ43-迷宫问题"><a href="#HJ43-迷宫问题" class="headerlink" title="HJ43 迷宫问题"></a><a href="https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc">HJ43 迷宫问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(m*n) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//pair 默认对first升序，当first相同时对second升序；</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;PII&gt;&gt; &amp;path,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;              <span class="comment">//用于遍历</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="comment">// d[0][0] = 0;                    //移动次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())        <span class="comment">//队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();   <span class="comment">//出队</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">          <span class="comment">//if(x == n-1 &amp;&amp; y == m-1 &amp;&amp; g[x][y] == 0) cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl; //判断是否到达出口  </span></span><br><span class="line">          <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp;y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//d[x][y] = d[t.first][t.second] + 1;   //之前的距离加上又走的一步</span></span><br><span class="line">                g[x][y] = <span class="number">1</span>;</span><br><span class="line">                path[x][y] = t;        <span class="comment">//从t点到(x,y)</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x,y));   <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    vector&lt;PII&gt;  res;          <span class="comment">//res用于逆序输出</span></span><br><span class="line">    <span class="keyword">int</span> x = n<span class="number">-1</span>,y=m<span class="number">-1</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">    <span class="keyword">while</span>(x || y)&#123;  <span class="comment">//同时为0时退出</span></span><br><span class="line">        <span class="keyword">auto</span> t = path[x][y];</span><br><span class="line">        x = t.first,y=t.second;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,res[i].first,res[i].second); <span class="comment">//(2)路径逆序输出</span></span><br><span class="line">    <span class="comment">//return d[n - 1][m - 1]; //（1）最少移动的次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));   <span class="comment">//g存储的是图  </span></span><br><span class="line">        <span class="comment">//d = vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(m,0)); //d存储的是移动次数 </span></span><br><span class="line">        vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">path</span>(n*m,vector&lt;PII&gt;(n*m));   <span class="comment">//pre保存点映射点 注意这里需要n*m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                cin&gt;&gt;g[i][j];    <span class="comment">//存入地图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(path,g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1926-迷宫中离入口最近的出口"><a href="#1926-迷宫中离入口最近的出口" class="headerlink" title="1926. 迷宫中离入口最近的出口"></a><a href="https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">是边界且不是墙提前返回（出口相对入口的最短距离）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestExit</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; entrance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;           <span class="comment">//(x,y,d)   d是相对入口的距离</span></span><br><span class="line">        q.<span class="built_in">emplace</span>(entrance[<span class="number">0</span>],entrance[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        maze[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="string">&#x27;+&#x27;</span>;   <span class="comment">//遍历过了，防止重复访问</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [mx,my,d] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=mx+dir[<span class="number">0</span>],y=my+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt;m &amp;&amp; maze[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">0</span> || x == n<span class="number">-1</span> || y== <span class="number">0</span> || y == m <span class="number">-1</span> ) <span class="keyword">return</span> d+<span class="number">1</span>;<span class="comment">//边界时返回答案</span></span><br><span class="line">                    maze[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(x,y,d+<span class="number">1</span>); <span class="comment">//emplace=&gt;push</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="PDD4迷宫寻路-💣"><a href="#PDD4迷宫寻路-💣" class="headerlink" title="PDD4迷宫寻路 💣"></a><a href="https://www.nowcoder.com/practice/e3fc4f8094964a589735d640424b6a47?tpId=182&gioEnter=menu">PDD4迷宫寻路</a> 💣</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC代码:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> G[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">105</span>][<span class="number">105</span>][<span class="number">1200</span>],N,M;</span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,k,step;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k,<span class="keyword">int</span> step):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">k</span>(k),<span class="built_in">step</span>(step)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,G[i]);</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(book));</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">                <span class="keyword">if</span>(G[i][j]==<span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    book[i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">bfs</span>(i,j));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX,<span class="keyword">int</span> startY)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">node</span>(startX,startY,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node head=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(G[head.x][head.y]==<span class="string">&#x27;3&#x27;</span>) <span class="keyword">return</span> head.step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=head.x+Next[i][<span class="number">0</span>],ny=head.y+Next[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=N||nx&lt;<span class="number">0</span>||ny&gt;=M||ny&lt;<span class="number">0</span>||G[nx][ny]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> key=head.k;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;z&#x27;</span>) key=key|(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;Z&#x27;</span>&amp;&amp;(key&amp;(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;A&#x27;</span>)))==<span class="number">0</span>) <span class="keyword">continue</span>;	<span class="comment">//没有该钥匙</span></span><br><span class="line">            <span class="keyword">if</span>(!book[nx][ny][key])&#123;</span><br><span class="line">                book[nx][ny][key]=<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx,ny,key,head.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//这题就是普通的bfs多了‘钥匙’这个状态 </span></span><br><span class="line"> <span class="comment">//所以book[x][y][key]的意义就是 横坐标为x,纵坐标为y,钥匙状态为key的点是否访问过 </span></span><br><span class="line"> <span class="comment">//钥匙的状态 就用二进制数表示 最多10 把钥匙 那就是1024</span></span><br><span class="line"> <span class="comment">//比如我现在有第二把钥匙和第四把钥匙  那么我的钥匙状态就是 0101000000 也就是 320</span></span><br></pre></td></tr></table></figure>

<h4 id="机器人走迷宫"><a href="#机器人走迷宫" class="headerlink" title="机器人走迷宫"></a><a href="https://www.nowcoder.com/discuss/596162?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7CDE02A66517EFFDE8544F0962A4C635-1639577561411">机器人走迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="走迷宫最小消耗"><a href="#走迷宫最小消耗" class="headerlink" title="走迷宫最小消耗"></a><a href="https://leetcode-cn.com/circle/discuss/cg0ayO/">走迷宫最小消耗</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1036-逃离大迷宫"><a href="#1036-逃离大迷宫" class="headerlink" title="1036. 逃离大迷宫"></a><a href="https://leetcode-cn.com/problems/escape-a-large-maze/">1036. 逃离大迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>3.贪心算法</title>
    <url>/2021/01/02/3.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="2-3-贪心算法"><a href="#2-3-贪心算法" class="headerlink" title="2.3 贪心算法"></a>2.3 贪心算法</h1><blockquote>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的<strong>局部最优解</strong>。 </p>
<p>分配问题</p>
<p>区间问题</p>
</blockquote>
<span id="more"></span>

<h2 id="（1）分配问题"><a href="#（1）分配问题" class="headerlink" title="（1）分配问题"></a>（1）分配问题</h2><h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题意：将字符串构造成最长回文串：例如abb，构造成bab，问最长长度</span></span><br><span class="line"><span class="comment">//思路：字符偶数个则可以构成回文串，最多只有1个字符为奇数个。</span></span><br><span class="line"><span class="comment">//hashmap直接统计字符个数为奇数的字符cnt，s.size()-cnt+1;加1是最多只有一个字符出现了奇数次；cnt为0则表示s.szie()构成最长</span></span><br><span class="line"><span class="comment">//复杂度：T:O(N),S:O(S)  S字符集大小：128</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; map;   <span class="comment">//统计对应字符的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n= s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) map[s[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:map) <span class="keyword">if</span>(it.second % <span class="number">2</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span> ? n : n-cnt+<span class="number">1</span>;   <span class="comment">//cnt等于0表示，所有字符可以构成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><p><img src="/Users/zcz/Desktop/zcz/zczBlog/source/_posts/3.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/14_fig1.png" alt="fig1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：如上图</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">横向扫描：对比完返回前缀，再跟下一个word对比；前缀为空时，跳出循环</span></span><br><span class="line"><span class="comment">复杂度：T:O(N),S:O(S)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getPrefix</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=str1.<span class="built_in">size</span>(),n2=str2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; n1 &amp;&amp; index &lt;n2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[index] == str2[index]) index++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;   <span class="comment">//横向扫描对比</span></span><br><span class="line">            prefix = <span class="built_in">getPrefix</span>(prefix,strs[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == prefix.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：最长且连续递增的子序列：nums[i-1] &lt; nums[i]</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1)i记录结束下标，start记录开始下标；</span></span><br><span class="line"><span class="comment">2)遍历数组：</span></span><br><span class="line"><span class="comment">	nums[i-1] &gt;=  nums[i]：前面&gt;=后面，则更新结束下标i</span></span><br><span class="line"><span class="comment">	更新res</span></span><br><span class="line"><span class="comment">复杂度：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] &gt;= nums[i])&#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            res = <span class="built_in">max</span>(res,i-start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="455-分发饼干-🀄️"><a href="#455-分发饼干-🀄️" class="headerlink" title="455. 分发饼干 🀄️"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：饼干填充饥饿的孩子，问最多满足的孩子数</span></span><br><span class="line"><span class="comment">思路：先对饼干，饥饿感升序排序，最小的饼干给饥饿最小的孩子，依次类推</span></span><br><span class="line"><span class="comment">复杂度：T,S:（Omlogm+nlogn） 主要排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());      <span class="comment">//饼干</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());      <span class="comment">//饥饿</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;    <span class="comment">//1块饼干只能给一个小孩</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; g.<span class="built_in">size</span>() &amp;&amp; s[i] &gt;= g[j])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="135-分发糖果-🀄️"><a href="#135-分发糖果-🀄️" class="headerlink" title="135. 分发糖果 🀄️"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：每个孩子至少分配到 1 个糖果，相邻2个孩子分数高的获得更多糖果。问所需最少糖果数目</span></span><br><span class="line"><span class="comment">思路：先全部赋值为1</span></span><br><span class="line"><span class="comment">从左到右遍历，右边大于左边，则右边= 左边+1</span></span><br><span class="line"><span class="comment">从右到左遍历，左边大于右边，则左边= max(左边,右边+1)</span></span><br><span class="line"><span class="comment">复杂度：T，S:O(N)</span></span><br><span class="line"><span class="comment">考虑：</span></span><br><span class="line"><span class="comment">[1,3,4,5,2]</span></span><br><span class="line"><span class="comment"> 1 1 1 1 1</span></span><br><span class="line"><span class="comment"> 1 2 3 4 1  右边大时，右边= 左边+1</span></span><br><span class="line"><span class="comment"> 1 2 3 4 1  左边大时，左边=max(左边，右边+1)  max(4,1+1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">1</span>)</span></span>;  <span class="comment">//全部初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">-1</span>])&#123;<span class="comment">//右边大于左边，右边= 左边+1</span></span><br><span class="line">                res[i] = res[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &lt; ratings[i<span class="number">-1</span>])&#123;<span class="comment">//左边大于右边，左边= max(左边,右边+1)</span></span><br><span class="line">                res[i<span class="number">-1</span>] = <span class="built_in">max</span>(res[i<span class="number">-1</span>],res[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),<span class="number">0</span>);<span class="comment">//求和，0是初始的累加值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a><a href="https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[3,3,3,3,3,1,3] =&gt; [[5],[0,1,2],[3,4,6]] </span></span><br><span class="line"><span class="comment">第一个元素：3代表下标0所在组大小为3</span></span><br><span class="line"><span class="comment">思路：哈希表&lt;组大小，个数&gt;；然后遍历map，将每个组放进res</span></span><br><span class="line"><span class="comment">复杂度：T,S:O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">groupThePeople</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; g) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; map;	<span class="comment">//&lt;组大小，个数&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            map[g[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:map)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = it.second;</span><br><span class="line">            <span class="keyword">int</span> s = it.first;          <span class="comment">//每组大小</span></span><br><span class="line">            <span class="keyword">int</span> cnt = tmp.<span class="built_in">size</span>()/s;    <span class="comment">//每组放的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;		 <span class="comment">//把每个组放进res</span></span><br><span class="line">                <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(tmp.begin()+i*s,tmp.begin()+(i+<span class="number">1</span>)*s)</span></span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1518-换酒问题"><a href="#1518-换酒问题" class="headerlink" title="1518. 换酒问题"></a><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：比如e个空瓶换1瓶酒。现有b瓶酒，问最多可以喝多少瓶酒。（喝掉的酒就可以成为空酒瓶）</span></span><br><span class="line"><span class="comment">思路：直接兑换酒，兑换完后更新空酒瓶，重复兑换直到兑换不了</span></span><br><span class="line"><span class="comment">复杂度：T:O(b/e),S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=numBottles;</span><br><span class="line">        <span class="keyword">while</span>(numBottles/numExchange)&#123;</span><br><span class="line">            res+=numBottles/numExchange;</span><br><span class="line">            numBottles = numBottles/numExchange+numBottles%numExchange;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：一杯柠檬水5美元，向你付 5 美元、10 美元或 20 美元，问能不能正确找零</span></span><br><span class="line"><span class="comment">思路：钱大的先给，留小的好找零钱；用five,ten标志5，10元的数目</span></span><br><span class="line"><span class="comment">复杂度：T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five=<span class="number">0</span>,ten=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cur:bills) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">5</span>) five++;  <span class="comment">//不需要找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">10</span>)&#123; <span class="comment">//需要找5</span></span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five --;</span><br><span class="line">                ten ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//需要找15</span></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span> )&#123; <span class="comment">//钱大的先给，留小的好找零钱</span></span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/">1111. 有效括号的嵌套深度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：要求划分出使得最大嵌套深度最小的分组</span></span><br><span class="line"><span class="comment">思路：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，</span></span><br><span class="line"><span class="comment">括号序列   ( ( ) ( ( ) ) ( ) )</span></span><br><span class="line"><span class="comment">下标编号   0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">嵌套深度   1 2 2 2 3 3 2 2 2 1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">复杂度：T:O(N),S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(string seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : seq)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++d;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(d % <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(d % <span class="number">2</span>);</span><br><span class="line">                --d;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">861. 翻转矩阵后的得分</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[0,0]  经过行或列的多次翻转[1,1]    b11+b10=5,最大</span></span><br><span class="line"><span class="comment">		 [0,1]  								 [1,0]</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">（1）假设每一行开头都为1；贡献：n*2^(m-1)</span></span><br><span class="line"><span class="comment">（2）按列遍历：计算第j列1的个数one</span></span><br><span class="line"><span class="comment">（3）还可以按列翻转k = max(one,row-one)。 贡献：k*2^(m-j-1).  </span></span><br><span class="line"><span class="comment">复杂度：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> row =grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = row*<span class="built_in">pow</span>(<span class="number">2</span>,col<span class="number">-1</span>);<span class="comment">//假设每一行开头都为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;	<span class="comment">//该列1的个数</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">0</span>) one += (<span class="number">1</span>-grid[i][j]);  <span class="comment">//表明该行翻转了</span></span><br><span class="line">                <span class="keyword">else</span> one += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">max</span>(one,row-one); <span class="comment">//取大的</span></span><br><span class="line">            res += k*<span class="built_in">pow</span>(<span class="number">2</span>,col-j<span class="number">-1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[1,0,0,0,1]：1代表种花，0代表没种，相邻不能同时种花。也就是遇到1,那么下一格子一定是0。给定n花能不能种上，比如n=1，可以种上,n=2不可以。</span></span><br><span class="line"><span class="comment">思路：每次跳两格。如果当前为空地；&#123;下个格子不是1或者当前为最后一个格子，果断填充&#125;。		</span></span><br><span class="line"><span class="comment">复杂度：T:O(N),S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次跳两格</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="comment">// 前提是当前为空地</span></span><br><span class="line">            <span class="keyword">if</span> (f[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是当前i为最后一格或者下一格为空</span></span><br><span class="line">                <span class="keyword">if</span> (i == f.<span class="built_in">size</span>() - <span class="number">1</span> || f[i + <span class="number">1</span>] == <span class="number">0</span>) n--;</span><br><span class="line">                <span class="keyword">else</span> i++; <span class="comment">//下一格子⚠️</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：最多 改变 1 个元素的情况下，使数组变成一个非递减数列（nums[i] &lt;= nums[i + 1]）</span></span><br><span class="line"><span class="comment">思路：nums[i] &gt; nums[i+1] 同时要求 nums[i+1] &lt; nums[i-1]才更新nums[i+1]=nums[i]</span></span><br><span class="line"><span class="comment">复杂度：T:O(N),S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i], y = nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; y &lt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">//⚠️ 3 4 2 4</span></span><br><span class="line">                    nums[i + <span class="number">1</span>] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b b=0,1,2。推导=&gt;最优：把绳子尽可能切为多个长度为3的片段，次优2，最差1</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>; <span class="comment">//n =3a+b b=0,1,2</span></span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> pow(<span class="number">3</span>,a);       <span class="comment">//n=6 a=2 b=0 3^2</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;   <span class="comment">//n=7 a=2 b=1 3^1*4</span></span><br><span class="line">        <span class="keyword">return</span> pow(<span class="number">3</span>,a)*<span class="number">2</span>;                <span class="comment">//n=8 a=2 b=2 3^2*2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，结果取模 1e9+7，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b  快速幂求余</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>,p=<span class="number">1000000007</span>; <span class="comment">//n =3a+b b=0,1,2</span></span><br><span class="line">        <span class="keyword">int</span> a = n/<span class="number">3</span>-<span class="number">1</span>;	<span class="comment">//少一个</span></span><br><span class="line">        <span class="comment">//base,a,p，求 base^a mod p。</span></span><br><span class="line">        <span class="keyword">long</span> base=<span class="number">3</span>,rem=<span class="number">1</span>;     <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;     <span class="comment">//n=9 rem=9</span></span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">1</span>) rem=rem*base%p;	<span class="comment">//有余数</span></span><br><span class="line">            base= base*base%p; <span class="comment">//注意</span></span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//举例子n=6,7,8</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>%p);<span class="comment">//rem^(a+1)%p   </span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">4</span>%p);  <span class="comment">//rem^(a)*4%p</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>*<span class="number">2</span>%p);    <span class="comment">//rem^(a+1)*2%p          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="（2）区间问题"><a href="#（2）区间问题" class="headerlink" title="（2）区间问题"></a>（2）区间问题</h2><h4 id="435-无重叠区间-🀄️"><a href="#435-无重叠区间-🀄️" class="headerlink" title="435. 无重叠区间 🀄️"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</span></span><br><span class="line"><span class="comment">思路：优先保留结尾小且不相交的区间，就越能保留更多的区间。</span></span><br><span class="line"><span class="comment">先排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。</span></span><br><span class="line"><span class="comment">⚠️需要根据实际情况判断按区间开头排序还是按区间结尾排序。</span></span><br><span class="line"><span class="comment">复杂度：T:O(nlogn),S:O(1ogn) 栈排序logn</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; gs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gs.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(gs.<span class="built_in">begin</span>(), gs.<span class="built_in">end</span>(),cmp);<span class="comment">//区间结尾排序，从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, pre = gs[<span class="number">0</span>][<span class="number">1</span>];   <span class="comment">//pre前区间结尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; gs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gs[i][<span class="number">0</span>] &lt; pre) res++;  <span class="comment">// 当前区间开始值 &lt; pre前区间结尾  有重叠</span></span><br><span class="line">            <span class="keyword">else</span>  pre = gs[i][<span class="number">1</span>];       <span class="comment">// &gt;= 无重叠，pre更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[2,3,1,1,4]，值代表能够跳跃的距离，问能不能达到最后一格</span></span><br><span class="line"><span class="comment">思路：每次走最大的距离，如果能超过末尾元素，说明只要调小步伐就一定可以达到最后位置。</span></span><br><span class="line"><span class="comment">复杂度：T:O(N)，S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxPos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(maxPos &gt;= i)&#123;</span><br><span class="line">               maxPos = <span class="built_in">max</span>(maxPos,i+nums[i]);</span><br><span class="line">               <span class="keyword">if</span>(maxPos &gt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[2,3,1,1,4]，值代表能够跳跃的距离，问达到最后一格的最少跳跃次数？</span></span><br><span class="line"><span class="comment">思路：end=0，每次记录能达到的最远下标maxpose，遍历到end时，end=maxpose,steps++</span></span><br><span class="line"><span class="comment">复杂度：T:O(N)，S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;   <span class="comment">//循环n-1次</span></span><br><span class="line">            <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);  <span class="comment">//跳最远的点</span></span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123;     <span class="comment">//此时</span></span><br><span class="line">                    end = maxPos;   <span class="comment">//当end &gt;= n-1时，结束</span></span><br><span class="line">                    ++step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">题意：每个气球=[start,end]，如果箭pos，start=&lt;pos&lt;=end；则可以引爆气球</span></span><br><span class="line"><span class="comment">思路：区间按照结尾升序，循环数组，如果后面一个区间的开始大于前一个区间的结尾 就需要新增一支箭。尽量将箭移到最远的那个</span></span><br><span class="line"><span class="comment">复杂度：T:O(nlogn) S:O(logn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a,vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">//区间结尾</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;  <span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>] &gt; pos)&#123; <span class="comment">//后面区间的开始&gt;前面区间的结尾</span></span><br><span class="line">                pos = p[<span class="number">1</span>]; <span class="comment">//更新pos</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><p><img src="/2021/01/02/3.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1603310324-sXRPmM-image.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：同一字母最多出现在一个片段,&quot;ababcbacadefegdehijhklij&quot;=&gt; &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span></span><br><span class="line"><span class="comment">思路：记录每个字母的最远下标end（分割点），到达分割点后更新下一个分割点</span></span><br><span class="line"><span class="comment">复杂度：：T:O(n) S:O(1)  26个小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">27</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123; <span class="comment">//统计每个字符出现的最远点</span></span><br><span class="line">            cnt[s[i]-<span class="string">&#x27;a&#x27;</span>] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            end = <span class="built_in">max</span>(end,cnt[s[i]-<span class="string">&#x27;a&#x27;</span>]);   <span class="comment">//最远点</span></span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;                   <span class="comment">//到达分割点,更新</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(end-start+<span class="number">1</span>);</span><br><span class="line">                start = end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</span></span><br><span class="line"><span class="comment">思路：先排序(元素1降序，元素2升序);如果res.size()前面个数&gt;当前的k,将当前插入到k位置；否则直接添加到res</span></span><br><span class="line"><span class="comment">复杂度：T,O(n^2),S:O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//降序：保证每个元素，在其之前的元素个数，&gt;=他的k  [7,0],[7,1],[6,1]  对于6，2&gt;1</span></span><br><span class="line"><span class="comment">//升序：如果降序[5,3],[5,2]。3先插入，2后插入，此时3之前就有4个了，出错，因为2的插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a,vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];  <span class="comment">//降序</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; <span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:people)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt;= p[<span class="number">1</span>]) res.<span class="built_in">push_back</span>(p);</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>()+p[<span class="number">1</span>],p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>4.指针类问题</title>
    <url>/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="2-4-指针类问题"><a href="#2-4-指针类问题" class="headerlink" title="2.4 指针类问题"></a>2.4 指针类问题</h1><blockquote>
<p>1.<strong>双指针/滑动窗口</strong>，用快慢指针，遍历方向相同，且不相交</p>
<p>2.<strong>搜索</strong>（往往搜索的数组排好序），遍历方向相反</p>
</blockquote>
<span id="more"></span>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20210629195210802.png" alt="image-20210629195210802"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(target)	S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">int</span> sum = (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                l++;    <span class="comment">//⚠️</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) r++; </span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先整个翻转，再每个单词翻转</span></span><br><span class="line"><span class="comment">//T:O(n),S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != <span class="string">&#x27; &#x27;</span>)&#123;             <span class="comment">//当前不是空格</span></span><br><span class="line">                <span class="keyword">if</span>(r != <span class="number">0</span>) s[r++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//将前面的空格填上</span></span><br><span class="line">                <span class="keyword">int</span> end = l;</span><br><span class="line">                <span class="keyword">while</span>(s[end] != <span class="string">&#x27; &#x27;</span>&amp;&amp; end &lt; n)&#123;<span class="comment">// 遍历到空格停止</span></span><br><span class="line">                    s[r++] = s[end++];</span><br><span class="line">                &#125; <span class="comment">//此时r为单词末尾 单词长度end-l，起始位置 r-(end-l) </span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+r-(end-l),s.<span class="built_in">begin</span>()+r); <span class="comment">//到r-1</span></span><br><span class="line">                l = end;  <span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+r,s.<span class="built_in">end</span>());   <span class="comment">//删除末尾空格</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(m) m字符集大小</span></span><br><span class="line">  <span class="comment">//r指针一直右移，没有就存入，出现过就删除，并将l左移</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; occ;<span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (l &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[r + <span class="number">1</span>])) &#123;    <span class="comment">//当前字符没有出现过</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[r+<span class="number">1</span>]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;         <span class="comment">//已经出现了，删除</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l+ <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举最长子串中的字符种类数目(本题最大为26)</span></span><br><span class="line"><span class="comment">//枚举+滑动窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=<span class="number">26</span>;p++)&#123;</span><br><span class="line">           <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">           <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//total 代表 [left, right] 区间所有的字符种类数量；sum 代表满足「出现次数不少于 k」的字符种类数量</span></span><br><span class="line">           <span class="keyword">int</span> total=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(r &lt; n)&#123;</span><br><span class="line">               <span class="keyword">int</span> index = s[r]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">               cnt[index]++;</span><br><span class="line">               <span class="keyword">if</span>(cnt[index] == <span class="number">1</span>) total++; <span class="comment">//新的字符，直接加1</span></span><br><span class="line">               <span class="keyword">if</span>(cnt[index] == k) sum++;   <span class="comment">//满足加1</span></span><br><span class="line">               <span class="keyword">while</span>(total &gt; p)&#123;    <span class="comment">//一直左移，缩小窗口为p</span></span><br><span class="line">                   index = s[l] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[index] == <span class="number">1</span>) total--;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[index] == k) sum--;</span><br><span class="line">                   cnt[index]--;</span><br><span class="line">                   l++;</span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span>(total == sum) res=<span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">               r++; <span class="comment">//下一个</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(m*n)  S:O(m)   s 的长度是 n，words 里有 m 个单词</span></span><br><span class="line"><span class="comment">//map存words（单词，次数） map2临时统计（单词，次数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">int</span> wordNum = words.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(wordNum == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">       <span class="keyword">int</span> len = words[<span class="number">0</span>].<span class="built_in">size</span>();   <span class="comment">//滑动窗口大小</span></span><br><span class="line">       unordered_map&lt;string,<span class="keyword">int</span>&gt; map;	</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word:words) map[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()-wordNum*len+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            unordered_map&lt;string,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num &lt; wordNum)&#123;   <span class="comment">//不同于java的subString</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i+num*len,len);  <span class="comment">//取出当前word</span></span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(word))&#123;</span><br><span class="line">                    tmp[word]++;</span><br><span class="line">                    <span class="keyword">if</span>(tmp[word] &gt; map[word]) <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                num++;  <span class="comment">//下一个word</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == wordNum)&#123;  <span class="comment">//判断是不是所有的单词都符合条件</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="76-最小覆盖子串🀄️"><a href="#76-最小覆盖子串🀄️" class="headerlink" title="76. 最小覆盖子串🀄️"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>🀄️</h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/76_fig1.gif" alt="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*滑动窗口 遍历方向相同，返回包含t的最小子串</span></span><br><span class="line"><span class="comment">T：O(C*s+t) S:O(C) C字符集大小</span></span><br><span class="line"><span class="comment">思路：r指针不断向右移动，直到包含T字串，此时l指针向右移，尝试找到最短的包含T的子串</span></span><br><span class="line"><span class="comment"> chars 表示T中每个字符的数量，flag 表示每个字符是否在 T 中存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;   </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;        <span class="comment">//哈希表 </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>,<span class="literal">false</span>)</span></span>;   <span class="comment">//是否为T中的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[t[i]]++;</span><br><span class="line">            flag[t[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,min_l=<span class="number">0</span>,min_size = s.<span class="built_in">size</span>()+<span class="number">1</span>;<span class="comment">//min_size最短子串长度</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//T中字符串出现的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[s[r]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--cnt[s[r]] &gt;= <span class="number">0</span>) num++;</span><br><span class="line">                <span class="keyword">while</span>(num == t.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(r-l+<span class="number">1</span> &lt; min_size)&#123;</span><br><span class="line">                        min_l = l;  <span class="comment">//左边起始</span></span><br><span class="line">                        min_size = r-l+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//比如：T:BC，S:ABBACD，l=0,r=4,需要再移动l</span></span><br><span class="line">                    <span class="keyword">if</span>(flag[s[l]] &amp;&amp; ++cnt[s[l]] &gt; <span class="number">0</span>) num--;  <span class="comment">//是T中字符，且要将这个字符移除窗口</span></span><br><span class="line">                    l++;    <span class="comment">//缩小窗口,l=3,cnt=1，跳出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_size &gt; s.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span>: s.<span class="built_in">substr</span>(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159.至多包含两个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/">159.至多包含两个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;  <span class="comment">//找到符合的</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                sum -= nums[l]; <span class="comment">//左移，缩小窗口，直到最小</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="340-至多包含-K-个不同字符的最长子串"><a href="#340-至多包含-K-个不同字符的最长子串" class="headerlink" title="340. 至多包含 K 个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">340. 至多包含 K 个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(k+m) S:O(C) C:26个字母</span></span><br><span class="line"><span class="comment">//当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的排列。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.<span class="built_in">length</span>(), m = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">cnt2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++cnt1[s1[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == cnt2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; m; ++i) &#123;   <span class="comment">//n为窗口大小</span></span><br><span class="line">            --cnt2[s2[i - n] - <span class="string">&#x27;a&#x27;</span>];    <span class="comment">//向右滑动,左边界滑出</span></span><br><span class="line">            ++cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>];        <span class="comment">//右边界++</span></span><br><span class="line">            <span class="keyword">if</span> (cnt1 == cnt2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632. 最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range/">632. 最小区间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="727-最小窗口子序列"><a href="#727-最小窗口子序列" class="headerlink" title="727. 最小窗口子序列"></a><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【快慢指针（多走一步）寻找链表中点 + 反转链表（右半部分） +合并链表（ 左取1个，右边取1个）】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next )&#123;     <span class="comment">//保证前进的2个都不为空</span></span><br><span class="line">            slow =slow-&gt;next;</span><br><span class="line">            fast =fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur =head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tmp=cur-&gt;next;        <span class="comment">//暂存</span></span><br><span class="line">            cur-&gt;next = pre;        <span class="comment">//由于这里next改变了</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1,ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            ListNode*  tmp1 = l1-&gt;next;     <span class="comment">//暂存</span></span><br><span class="line">            ListNode*  tmp2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next=l2;    <span class="comment">//l1指向l2      由于这里next改变了</span></span><br><span class="line">            l1 = tmp1;     <span class="comment">//更新l1</span></span><br><span class="line">            l2-&gt;next=l1;</span><br><span class="line">            l2=tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">getMid</span>(head);</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = mid-&gt;next;   <span class="comment">//l2头结点</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//l1尾结点next置为NULL</span></span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="built_in">mergeList</span>(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快指针先移动n步后，快，慢指针再同步移动</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">//必须要这个，否则删除的是头结点会报错</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* quick = dummy,*slow=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;   <span class="comment">//循环n+1多了个dummy</span></span><br><span class="line">            quick=quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(quick)&#123;</span><br><span class="line">            quick=quick-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;        </span><br><span class="line">        &#125;   <span class="comment">//slow为要删除的结点的前一个结点</span></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(slow &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【快慢指针，同步指针】2次相遇：第1次相遇不清楚位置，第二次相遇为入口结点。重合时 fast 比 slow 多走 环的长度整数倍</span></span><br><span class="line"><span class="comment">//设快慢指针走了f,s步,</span></span><br><span class="line"><span class="comment">//第1次相遇：fast：f=2s(fast 每轮走 2 步) f=s+nb(比slow多走环的长度整数倍) ==&gt; slow:s = nb		a：环外的长度，b：环的长度</span></span><br><span class="line"><span class="comment">//此时：　slow:nb，只要让slow多走a步，就是环的入口。</span></span><br><span class="line"><span class="comment">//而我们只要令fast=head，跟slow同步走，第2次相遇时就是环的入口</span></span><br><span class="line"><span class="comment">//第2次相遇：让slow在a步停下来，让slow和fast在a处相遇，</span></span><br><span class="line"><span class="comment">//slow不变，fast=head，同步移动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//⚠️处理特殊情况</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cur,pre</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p><img src="/Users/zcz/Desktop/images/image-20211227201227099.png" alt="image-20211227201227099"></p>
<p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227201238570.png" alt="image-20211227201238570"></p>
<p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227201258314.png" alt="image-20211227201258314"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三指针</span></span><br><span class="line"><span class="comment">// 1    2    3   4  5 翻转[2,4]</span></span><br><span class="line"><span class="comment">// pre cur next</span></span><br><span class="line"><span class="comment">// 1 3 2 4 5</span></span><br><span class="line"><span class="comment">// 1 4 3 2 5</span></span><br><span class="line"><span class="comment">// 1 5 4 3 2</span></span><br><span class="line"><span class="comment">// 1 4 3 2 5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* pre=dummy;  <span class="comment">//待反转区域的第一个节点的前一个结点  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;left;i++)&#123;<span class="comment">//⚠️</span></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = pre-&gt;next;  <span class="comment">//待反转区域的第一个节点       </span></span><br><span class="line">        ListNode* next;   <span class="comment">//待反转区域的第一个节点的下一个结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=right-left;i++)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;<span class="comment">//头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2 )&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;             <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 != <span class="literal">NULL</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227211706771.png" alt="image-20211227211706771"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助归并排序，分治思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;<span class="comment">//辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;q,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//取分治点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="built_in">merge_sort</span>(q,l,mid)+<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r); <span class="comment">//递归</span></span><br><span class="line">        <span class="comment">/*这里ans存储了左区间和右区间的逆序对总数*/</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//此循环统计不同区间的逆序对</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]&lt;=q[j]) &#123;    <span class="comment">//小的放入数组</span></span><br><span class="line">                tmp[k++]=q[i++]; </span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">/*由于左区间和右区间已经有序当前左区间元素构成逆序,之后的都会构成逆序对*/</span></span><br><span class="line">                <span class="comment">/*所以ans需要加上区间长度*/</span></span><br><span class="line">                ans+=mid-i+<span class="number">1</span>;           </span><br><span class="line">                tmp[k++]=q[j++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;) q[i++]=tmp[j++];<span class="comment">//⚠️需要还原数组  </span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针+烂漫相遇</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* pa=headA,*pb=headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">            pa = pa != <span class="literal">NULL</span> ? pa-&gt;next : headB;</span><br><span class="line">            pb = pb != <span class="literal">NULL</span> ? pb-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：同向遍历链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">//用来保存开始结点</span></span><br><span class="line">        ListNode* node = dummy; <span class="comment">//node循环遍历结点</span></span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;    <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 != <span class="literal">nullptr</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 != <span class="literal">nullptr</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = a+b+c;</span><br><span class="line">            </span><br><span class="line">            c = sum/<span class="number">10</span>; </span><br><span class="line">            <span class="keyword">int</span> cur = sum%<span class="number">10</span>;   </span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur); </span><br><span class="line"></span><br><span class="line">            node = node-&gt;next;      <span class="comment">//移到下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>) node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);<span class="comment">//处理最后一个进位</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227221628897.png" alt="image-20211227221628897"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序+三指针</span></span><br><span class="line"><span class="comment">//T:O(n^2)  S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; len ; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 当前数字大于0，提前结束（因为排序了，后面的都&gt;0）</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保a改变 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = a+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[a] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[a],nums[L],nums[R]&#125;);</span><br><span class="line">                    <span class="comment">// 还要去重，比如: [-2, -1, -1, -1, 3, 3, 3]</span></span><br><span class="line">      <span class="comment">//i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 确保b改变 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R<span class="number">-1</span>]) R--; <span class="comment">// 确保c改变 去重</span></span><br><span class="line">                    L++;    <span class="comment">//继续遍历</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;=len<span class="number">-4</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保a改变 去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a+<span class="number">1</span>; b &lt;=len<span class="number">-3</span> ; b++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保b改变 去重</span></span><br><span class="line">                <span class="keyword">int</span> L = b+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> R = len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target - (nums[a] + nums[b])  == nums[L] + nums[R])&#123;    <span class="comment">//用减法，防止溢出</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[a],nums[b],nums[L],nums[R]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 确保c改变 去重</span></span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R<span class="number">-1</span>]) R--; <span class="comment">// 确保d改变 去重</span></span><br><span class="line">                        L++;    <span class="comment">//继续遍历</span></span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (target - (nums[a] + nums[b])  &gt; nums[L] + nums[R]) L++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (target - (nums[a] + nums[b])  &lt; nums[L] + nums[R]) R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三指针+排序（去重</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = INT_MAX;  <span class="comment">//上一次最接近多少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=a+<span class="number">1</span>,c=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(b &lt; c)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum =  nums[a] + nums[b] + nums[c];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-sum) &lt; pre)&#123;  <span class="comment">//比上次更佳接近</span></span><br><span class="line">                    pre = <span class="built_in">abs</span>(target-sum);  <span class="comment">//更新pre   </span></span><br><span class="line">                    res = sum;              <span class="comment">//保存当前sum</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> sum;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) c--;</span><br><span class="line">                <span class="keyword">else</span> b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259.较小的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/">259.较小的三数之和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快慢指针 遍历方向相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* quick=head,*slow=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            quick =quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(quick)&#123;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="167-两数之和-II-输入有序数组-🀄️"><a href="#167-两数之和-II-输入有序数组-🀄️" class="headerlink" title="167. 两数之和 II - 输入有序数组 🀄️"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 </a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 搜索 遍历方向相反</span></span><br><span class="line"><span class="comment">题意：在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(target == t) <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; t) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="88-合并两个有序数组🀄️"><a href="#88-合并两个有序数组🀄️" class="headerlink" title="88. 合并两个有序数组🀄️"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>🀄️</h4><img width="300" height="200" src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20210308145931744.png">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 逆序双指针</span></span><br><span class="line"><span class="comment">T:O(m+n) S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1=m<span class="number">-1</span>,p2=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2])&#123;</span><br><span class="line">                nums1[end--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[end--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>) nums1[end--] = nums1[p1--];</span><br><span class="line">        <span class="keyword">while</span>(p2&gt;=<span class="number">0</span>) nums1[end--] = nums2[p2--];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="面试题-17-11-单词距离🀄️"><a href="#面试题-17-11-单词距离🀄️" class="headerlink" title="面试题 17.11. 单词距离🀄️"></a><a href="https://leetcode-cn.com/problems/find-closest-lcci/">面试题 17.11. 单词距离</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*双指针 同个方向</span></span><br><span class="line"><span class="comment">题解：用两个指针一直记录两个单词出现的下标，在一次遍历数组的循环中，不断记录两个下标，并取他们差值的最小值，返回结果即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(vector&lt;string&gt;&amp; words, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = words.<span class="built_in">size</span>();      <span class="comment">//最长距离不可能为len</span></span><br><span class="line">        <span class="keyword">int</span> res = len;              </span><br><span class="line">        <span class="keyword">int</span> index1=-len,index2=len; <span class="comment">//⚠️ 2者距离最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1 == words[i]) index1 = i;   <span class="comment">//记录下标</span></span><br><span class="line">            <span class="keyword">if</span>(word2 == words[i]) index2 = i;   <span class="comment">//记录下标</span></span><br><span class="line">            res = <span class="built_in">min</span>(res,<span class="built_in">abs</span>(index2-index1));  <span class="comment">//取最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键思想：从二维数组的右上角开始查找。</span></span><br><span class="line"><span class="comment">//t:O(n+m) S:O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>,col=m-<span class="number">1</span>;row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            cout &lt;&lt; row &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;col &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(M[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(M[row][col] &gt; target) col--;</span><br><span class="line">            <span class="keyword">else</span> row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，搜索  T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*左边搜索偶数，右边搜索奇数；然后交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] %<span class="number">2</span> != <span class="number">0</span>)&#123;<span class="comment">//搜索偶数    ⚠️记得加 l&lt;r</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] %<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//搜索奇数</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l++],nums[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(根号c) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = (<span class="keyword">long</span>) Math.<span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span> (sum == c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; c) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(|s|)</span></span><br><span class="line"><span class="comment">//【首尾双指针】先isalnum(ch)存下来，再用首尾指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string new_s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))</span><br><span class="line">                new_s+=<span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=new_s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(new_s[l] != new_s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="comment">//【首尾双指针】low==high，ow--.high++；否则判断2个区间[low,high-1]，[low+1,high]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++,r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l =<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] == s[r])&#123;</span><br><span class="line">                l++,r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">check</span>(s,l,r<span class="number">-1</span>) || <span class="built_in">check</span>(s,l+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> string &amp;a,<span class="keyword">const</span> string &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();  <span class="comment">//按大到小</span></span><br><span class="line">        <span class="keyword">return</span> a&lt;b;   <span class="comment">//长度相同，比较字典序，从小到大</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(D.<span class="built_in">begin</span>(),D.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word:D) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == word[j]) j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="340-至多包含k个不同字符的最长子串"><a href="#340-至多包含k个不同字符的最长子串" class="headerlink" title="340.至多包含k个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">340.至多包含k个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆序双指针：原地修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;    <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(n+cnt*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[j] = s[i];    <span class="comment">//不为空格，直接赋值给s[j]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[j<span class="number">-2</span>] = <span class="string">&#x27;%&#x27;</span>,s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>,s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>; <span class="comment">//多个2个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> fast=<span class="number">1</span>,slow=<span class="number">1</span>;  <span class="comment">//同起点</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast<span class="number">-1</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【逆序双指针】取决于两端小的那个；左边小移动左边，反之右边；尽可能找大的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,(r-l)*<span class="built_in">min</span>(height[l],height[r]));</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt;= height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先排序+区间指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());    <span class="comment">//⚠️，先排序</span></span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">-2e9</span>,ed=<span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ed &lt; it[<span class="number">0</span>])&#123;  <span class="comment">//上一段的ed &lt; 当前一段的st 没有交集</span></span><br><span class="line">                <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);  <span class="comment">//将上一段放入res</span></span><br><span class="line">                st = it[<span class="number">0</span>],ed=it[<span class="number">1</span>];    <span class="comment">//更新上一段</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//有交集</span></span><br><span class="line">                ed = <span class="built_in">max</span>(ed,it[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);  <span class="comment">//处理最后一个</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同向指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1_size= s1.<span class="built_in">size</span>(),l2_size=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l1_size || j &lt; l2_size) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; l1_size &amp;&amp; s1[i] != <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s1[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//⚠️转为int，恰好去除了前导0</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; l2_size &amp;&amp; s2[j] != <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">                y = y * <span class="number">10</span> + s2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>5.二分查找</title>
    <url>/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="5-二分查找"><a href="#5-二分查找" class="headerlink" title="5.二分查找"></a>5.二分查找</h1><blockquote>
<p>二分查找：每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为 <em>O</em>(<em>n</em>) 的数组，二分查找的时间复杂度为 **<em>O</em>(log <em>n</em>)**。 </p>
<p>双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p>
</blockquote>
<span id="more"></span>

<h3 id="二分查找模板-I"><a href="#二分查找模板-I" class="headerlink" title="二分查找模板 I"></a>二分查找模板 I</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r =nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;	<span class="comment">//每次都有一个结果</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;	</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><h4 id="69-x-的平方根-🀄️"><a href="#69-x-的平方根-🀄️" class="headerlink" title="69. x 的平方根 🀄️"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=x;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid == x) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid &gt; x) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;	<span class="comment">//返回小的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//精度e</span></span><br><span class="line"><span class="keyword">if</span> (mid * mid &lt; x - e)&#123;</span><br><span class="line">  l = mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid * mid &gt; x + e)&#123;</span><br><span class="line">  r = mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  res = mid;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> res =<span class="built_in">guess</span>(mid);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res == <span class="number">-1</span>) r = mid <span class="number">-1</span>;  <span class="comment">// mid &gt; pick </span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="33-搜索旋转排序数组-🀄️"><a href="#33-搜索旋转排序数组-🀄️" class="headerlink" title="33. 搜索旋转排序数组 🀄️"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 🀄️</h4><p><img src="/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/33_fig1.png" alt="fig1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先判断情况1:[l,mid-1]有序，情况2:[mid+1,n-1]有序；再对2种情况进行二分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid])&#123; <span class="comment">//[l,mid-1]有序 </span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; <span class="comment">//target位于前半部分</span></span><br><span class="line">                    r= mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> l= mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//[mid+1,r]有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="number">-1</span>])&#123;   <span class="comment">//target位于后半部分</span></span><br><span class="line">                    l= mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="81-搜索旋转排序数组-II-🀄️"><a href="#81-搜索旋转排序数组-II-🀄️" class="headerlink" title="81. 搜索旋转排序数组 II 🀄️"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">第一类</span></span><br><span class="line"><span class="comment">10111 和 11101这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。</span></span><br><span class="line"><span class="comment">第二类</span></span><br><span class="line"><span class="comment">2 3 4 5 6 7 1  这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；</span></span><br><span class="line"><span class="comment">这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。</span></span><br><span class="line"><span class="comment">第三类</span></span><br><span class="line"><span class="comment">6 7 1 2 3 4 5这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；</span></span><br><span class="line"><span class="comment">这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找。</span></span><br><span class="line"><span class="comment">思路：if(nums[l] == nums[mid]) l++;   // 过滤干扰 改这里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+ (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] == nums[mid]) l++;   <span class="comment">// ⚠️过滤干扰 改这里</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; nums[mid])&#123; <span class="comment">//情况1 [l, mid - 1] 是有序数组 //0改为l</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; r=mid <span class="number">-1</span>; &#125;  <span class="comment">//0改为l</span></span><br><span class="line">                <span class="keyword">else</span> &#123; l = mid + <span class="number">1</span>;&#125;                                      </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;          <span class="comment">//情况2 [mid+1,n-1]是有序数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="number">-1</span>])&#123; l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;r =  mid - <span class="number">1</span>;&#125;                                     </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找模板-II"><a href="#二分查找模板-II" class="headerlink" title="二分查找模板 II"></a>二分查找模板 II</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;		<span class="comment">//满足左边[l...mid]</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid; <span class="comment">// 往左走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; l = mid + <span class="number">1</span>; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>) </span>&#123;		<span class="comment">//满足右边[mid,r] l要+1，避免死循环</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>+<span class="number">1</span>;		</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid; <span class="comment">// 往右走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; r = mid - <span class="number">1</span>; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>	) </span>&#123;		<span class="comment">//左,右边</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;		</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid; <span class="comment">// 往右走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; r = mid; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[0,1,3],返回缺失的2</span></span><br><span class="line"><span class="comment">思路：nums[mid] == mid ==&gt; l=mid+1 ；否则r=mid-1</span></span><br><span class="line"><span class="comment">复杂度：T:O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid) l = mid + <span class="number">1</span>;   </span><br><span class="line">            <span class="keyword">else</span> r = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><h4 id="34-在排序数组中查找元素的第一个和最后一个位置-🀄️"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-🀄️" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 🀄️"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[1,2,3,3,3,4] 查找3，返回[2,4]</span></span><br><span class="line"><span class="comment">思路：搜索target-1，返回第一个target的下标；搜索target，返回第一个target+1的下标，减去1就是最后一个target的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l=mid+<span class="number">1</span>;    <span class="comment">//往右走</span></span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l =<span class="built_in">search</span>(nums,target<span class="number">-1</span>),r=<span class="built_in">search</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>( l == r) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="278-第一个错误的版本-左边"><a href="#278-第一个错误的版本-左边" class="headerlink" title="278. 第一个错误的版本 左边"></a><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r= n;		<span class="comment">//⚠️这里下标是从1到n</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid)) r = mid; <span class="comment">//有问题，往左(更早版本)走</span></span><br><span class="line">            <span class="keyword">else</span>&#123; l = mid + <span class="number">1</span>; &#125;        <span class="comment">//没问题，往后面的版本走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="162-寻找峰值-左边"><a href="#162-寻找峰值-左边" class="headerlink" title="162. 寻找峰值 左边"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：峰值元素是指其值大于左右相邻值的元素。[1,3,2,1]	返回下标1</span></span><br><span class="line"><span class="comment">思路：nums[mid] &gt;= nums[mid+1]；判断峰值在[l,mid]，还是[mid+1,r]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123; <span class="comment">//⚠️邻居比</span></span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[mid+<span class="number">1</span>]) r = mid;   <span class="comment">//峰值在[l,mid]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;     <span class="comment">//峰值在[mid+1,n-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="153-寻找旋转排序数组中的最小值-左边"><a href="#153-寻找旋转排序数组中的最小值-左边" class="headerlink" title="153. 寻找旋转排序数组中的最小值 左边"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r= nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= nums[r]) r = mid;	<span class="comment">//最小值在[l,mid]</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><h4 id="154-寻找旋转排序数组中的最小值-II-🀄️"><a href="#154-寻找旋转排序数组中的最小值-II-🀄️" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II 🀄️"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;    </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r--;   <span class="comment">//加这里，去除r边界,</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[1,3,4,2,2]返回2；只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</span></span><br><span class="line"><span class="comment">思路：定义cnt统计数组中&lt;=当前i的个数</span></span><br><span class="line"><span class="comment">利用了「鸽巢原理」：n+1个元素放到n个集合中，其中必定有一个集合里至少有两个元素。</span></span><br><span class="line"><span class="comment">遍历数组，统计&lt;=4的个数，如果个数&gt;4 ，说明重复的元素一定出现在整数区间 [1..4]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//鸽巢原理 [l..mid]，在左边</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="540-有序数组中的单一元素-右边-变形-🀄️"><a href="#540-有序数组中的单一元素-右边-变形-🀄️" class="headerlink" title="540. 有序数组中的单一元素 右边(变形)🀄️"></a><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a> 右边(变形)🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：[1,1,2,3,3]返回2</span></span><br><span class="line"><span class="comment">思路：对偶数索引进行二分搜索，先mid %2 == 1，保证mid为偶数，再搜索</span></span><br><span class="line"><span class="comment">[1,1,2,3,3]    [1,1,2,2,3,4,4]</span></span><br><span class="line"><span class="comment">	下标mid=2						mid=3 此时mid--，保证前面双的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid %<span class="number">2</span> == <span class="number">1</span>) mid --; <span class="comment">//保证mid为偶数,2个一组出现</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] != nums[mid+<span class="number">1</span>]) r = mid;  <span class="comment">//肯定在左边</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">2</span>;   <span class="comment">//跳过2个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l]; 	<span class="comment">//nums[r]都可以	r=l</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="658-找到-K-个最接近的元素-🀄️左边"><a href="#658-找到-K-个最接近的元素-🀄️左边" class="headerlink" title="658. 找到 K 个最接近的元素  🀄️左边"></a><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a>  🀄️左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - k;	<span class="comment">//这里</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x - nums[mid] &lt;= nums[mid+k] -x ) r = mid;	<span class="comment">//左边差值小,向左侧靠近</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(nums.<span class="built_in">begin</span>()+l,nums.<span class="built_in">begin</span>()+l+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=letters.<span class="built_in">size</span>();   </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;               </span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[l%letters.<span class="built_in">size</span>()];<span class="comment">//如果插入位置是最后一个位置letters.size(),则变为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-寻找两个正序数组的中位数-归并或者二分"><a href="#4-寻找两个正序数组的中位数-归并或者二分" class="headerlink" title="4. 寻找两个正序数组的中位数 归并或者二分"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a> 归并或者二分</h4><p><img src="/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20220122122159534.png" alt="image-20220122122159534"></p>
<p><strong>（归并排序空间复杂度O(1))怎么实现</strong></p>
<p>参考:<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/3chong-jie-fa-qing-xi-jie-shi-ji-jian-cd-jm5p/">极简C++代码</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>(), l = <span class="number">0</span>, r = m;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1); <span class="comment">//保证num1短</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (l + r) / <span class="number">2</span>, j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i; <span class="comment">// +1保证不陷入死循环		//始终保持 i + j 的个数是总数的 1/2</span></span><br><span class="line">            nums1[i] &lt; nums2[j - <span class="number">1</span>] ? l = ++i : r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        r = (m + n + <span class="number">1</span>) / <span class="number">2</span> - l;	<span class="comment">//找到l就是找到r</span></span><br><span class="line">        <span class="comment">//边界情况</span></span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = l &lt;= <span class="number">0</span> ? INT_MIN : nums1[l - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = r &lt;= <span class="number">0</span> ? INT_MIN : nums2[r - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = l &gt;= m ? INT_MAX : nums1[l];</span><br><span class="line">        <span class="keyword">int</span> nums2RightMin = r &gt;= n ? INT_MAX : nums2[r];</span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums1LeftMax,nums2LeftMax);   <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">max</span>(nums1LeftMax,nums2LeftMax) + <span class="built_in">min</span>(nums1RightMin,nums2RightMin)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value">最接近的二叉搜索树值</a>  </p>
<p><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii">最接近的二叉搜索树值 II</a>  </p>
<p><a href="https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size">搜索长度未知的有序数组</a>  </p>
<h4 id="50-Pow-x-n-🀄️"><a href="#50-Pow-x-n-🀄️" class="headerlink" title="50. Pow(x, n)🀄️"></a><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快速幂</span></span><br><span class="line"><span class="comment">1	0	0	1	1	0	1</span></span><br><span class="line"><span class="comment">x^64	x^32	x^16	x^8	x^4	x^2	x^1</span></span><br><span class="line"><span class="comment">最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// x^n</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//x^a</span></span><br><span class="line">       <span class="keyword">long</span> a = n;  <span class="comment">//-n 防溢出</span></span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           a = -a;</span><br><span class="line">           x = <span class="number">1</span>/x; <span class="comment">//如果n小于0， 求1/x的n次方</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">double</span> rem=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(a)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a &amp; <span class="number">1</span>) rem*=x; <span class="comment">//当前二进制位为1</span></span><br><span class="line">           x*=x;</span><br><span class="line">           a/=<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="719-找出第-k-小的距离对🀄️"><a href="#719-找出第-k-小的距离对🀄️" class="headerlink" title="719. 找出第 k 小的距离对🀄️"></a><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设数组元素有n个，那么共有n*(n-1)/2个所谓的距离。这些距离的大小是有范围的，即最小的距离必大于等于0，最大的距离为数组的最大元素减去数组的最小元素。题目中所求的第k个最小距离就在其中。</span></span><br><span class="line"><span class="comment">我们可以用二分查找来找到这个目标距离，初始化l=0，r=最大距离。mid=(l+r)/2，计算出距离小于等于mid的数对的个数count。</span></span><br><span class="line"><span class="comment">    若count&lt;k，则第k个最小距离不会在[mid+1,r]之间，故修改l=mid+1；</span></span><br><span class="line"><span class="comment">    否则，r=mid；(因为第k个最小距离在[l,mid]之间)；</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[1,3,3,4]</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">r l  </span></span><br><span class="line"><span class="comment">1 1   3 3</span></span><br><span class="line"><span class="comment">2 1   3 3</span></span><br><span class="line"><span class="comment">3 1		4 3, 4 3</span></span><br><span class="line"><span class="comment">l:0r:3 mid:1count:3</span></span><br><span class="line"><span class="comment">1 1  3 3</span></span><br><span class="line"><span class="comment">2 1  3 3</span></span><br><span class="line"><span class="comment">3 3  4 4</span></span><br><span class="line"><span class="comment">l:0r:1 mid:0count:1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//nums数组一定要排序</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">back</span>() - nums.<span class="built_in">front</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">countPair</span>(nums, mid)&lt;k)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>; r &lt; nums.<span class="built_in">size</span>(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] - nums[l] &gt; mid) l++;</span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1044-最长重复子串"><a href="#1044-最长重复子串" class="headerlink" title="1044. 最长重复子串"></a><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">1044. 最长重复子串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>6.DP</title>
    <url>/2021/01/02/6.DP/</url>
    <content><![CDATA[<h1 id="6-DP-一"><a href="#6-DP-一" class="headerlink" title="6. DP(一)"></a>6. DP(一)</h1><blockquote>
<p>动态规划：</p>
<p>步骤：</p>
<p>1.确定dp数组以及下标的含义<br>2.确定转移方程<br>3.dp数组初始化<br>4.确定遍历顺序<br>5.举例推导</p>
</blockquote>
<span id="more"></span>

<h3 id="1-滚动数组"><a href="#1-滚动数组" class="headerlink" title="(1)滚动数组"></a>(1)滚动数组</h3><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//sum:f(n) a:f(n-2) b:f(n-1)</span></span><br><span class="line">            sum = (a+b)%<span class="number">100000007</span>;      <span class="comment">//执行n-1次</span></span><br><span class="line">            a = b;</span><br><span class="line">            b =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b =c;</span><br><span class="line">            c =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum=<span class="number">0</span>; <span class="comment">//0阶当作1</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b; </span><br><span class="line">            b = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="746-使用最小花费爬楼梯🀄️"><a href="#746-使用最小花费爬楼梯🀄️" class="headerlink" title="746. 使用最小花费爬楼梯🀄️"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211022223803669.png" alt="image-20211022223803669"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;    <span class="comment">//第0，1阶都可以作为起始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">min</span>(a+cost[i<span class="number">-2</span>],b+cost[i<span class="number">-1</span>]);<span class="comment">//向上爬一个阶梯或者爬两个阶梯</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-打家劫舍系列🀄️"><a href="#2-打家劫舍系列🀄️" class="headerlink" title="(2)打家劫舍系列🀄️"></a>(2)打家劫舍系列🀄️</h3><h5 id="198-打家劫舍🀄️"><a href="#198-打家劫舍🀄️" class="headerlink" title="198. 打家劫舍🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="213-打家劫舍-II🀄️"><a href="#213-打家劫舍-II🀄️" class="headerlink" title="213. 打家劫舍 II🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房子围成一圈</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(),nums.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums2</span><span class="params">(nums.begin()+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">work</span>(nums1),<span class="built_in">work</span>(nums2));<span class="comment">//1.抢头，不抢尾 2.不抢头，抢尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="337-打家劫舍-III🀄️"><a href="#337-打家劫舍-III🀄️" class="headerlink" title="337. 打家劫舍 III🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一棵二叉树</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">动态规划：</span></span><br><span class="line"><span class="comment">我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 下标0 代表不偷，1 代表偷</span></span><br><span class="line"><span class="comment">任何一个节点能偷到的最大钱的状态可以定义为</span></span><br><span class="line"><span class="comment">    当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</span></span><br><span class="line"><span class="comment">    当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;   </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; l=<span class="built_in">dp</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; r=<span class="built_in">dp</span>(root-&gt;right);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="built_in">max</span>(l[<span class="number">0</span>],l[<span class="number">1</span>])+<span class="built_in">max</span>(r[<span class="number">0</span>],r[<span class="number">1</span>]);<span class="comment">//不抢</span></span><br><span class="line">        res[<span class="number">1</span>] = l[<span class="number">0</span>]+r[<span class="number">0</span>]+root-&gt;val;<span class="comment">//抢</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res= <span class="built_in">dp</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数"></a><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) maxVal = <span class="built_in">max</span>(val,maxVal);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(maxVal+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) sum[val] += val; <span class="comment">//按顺序存,统计所有相同元素之和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rob</span>(sum);</span><br><span class="line">        <span class="comment">//若选择了x，则可以获取 sum[x] 的点数，且无法再选择 x−1和 x+1，这与打家劫舍一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-股票系列"><a href="#3-股票系列" class="headerlink" title="(3)股票系列"></a>(3)股票系列</h3><h4 id="121-买卖股票的最佳时机🀄️"><a href="#121-买卖股票的最佳时机🀄️" class="headerlink" title="121. 买卖股票的最佳时机🀄️"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211008224812645.png" alt="image-20211008224812645"></p>
<p><img src="/Users/zcz/Desktop/images/image-20211008225718378.png" alt="image-20211008225718378"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  - prices[i]);<span class="comment">//今天持股：1.今天什么都不做 2.今天买入（只允许1次，所以是第一次买入）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="122-买卖股票的最佳时机-II🀄️"><a href="#122-买卖股票的最佳时机-II🀄️" class="headerlink" title="122. 买卖股票的最佳时机 II🀄️"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以多次交易</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);	<span class="comment">//今天持股：1.昨天持股，今天什么都不做 2.昨天没有持股，今天买入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-最大子数组和系列"><a href="#4-最大子数组和系列" class="headerlink" title="(4)最大子数组和系列"></a>(4)最大子数组和系列</h3><h4 id="53-最大子序和🀄️"><a href="#53-最大子序和🀄️" class="headerlink" title="53. 最大子序和🀄️"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            prev = <span class="built_in">max</span>(prev+it,it); <span class="comment">// f(i) = max(f(i-1)+nums[i],nums[i])</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,prev);    <span class="comment">// max&#123;f(n)&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//maxSum最大和 minSum最小和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum=nums[<span class="number">0</span>],minSum=nums[<span class="number">0</span>],pre1=<span class="number">0</span>,pre2=<span class="number">0</span>,arrSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            arrSum+=num;</span><br><span class="line">            pre1=num&gt;pre1+num?num:pre1+num;</span><br><span class="line">            maxSum=maxSum&gt;pre1?maxSum:pre1;</span><br><span class="line">          </span><br><span class="line">            pre2=num&lt;pre2+num?num:pre2+num;</span><br><span class="line">            minSum=minSum&lt;pre2?minSum:pre2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxSum&lt;<span class="number">0</span>)&#123;      <span class="comment">//第三种情况，全部负数</span></span><br><span class="line">            <span class="keyword">return</span> maxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第2种情况，在两端：arrSum-minSum；第一种情况：在中间maxSum,就跟53题一样</span></span><br><span class="line">        <span class="keyword">return</span> arrSum-minSum&gt;maxSum?arrSum-minSum:maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于第 i 个状态只和第 i−1个状态相关，根据「滚动数组」思想</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = maxF, mn = minF;</span><br><span class="line">            maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>(nums[i], mn * nums[i]));<span class="comment">//三种情况</span></span><br><span class="line">            minF = <span class="built_in">min</span>(mx * nums[i], <span class="built_in">min</span>(nums[i], mn * nums[i]));</span><br><span class="line">            res = <span class="built_in">max</span>(maxF, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1567-乘积为正数的最长子数组长度"><a href="#1567-乘积为正数的最长子数组长度" class="headerlink" title="1567. 乘积为正数的最长子数组长度"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">1567. 乘积为正数的最长子数组长度</a></h4><p><img src="/2021/01/02/6.DP/image-20211006235824952.png" alt="image-20211006235824952"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> positive = (nums[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> negative = (nums[<span class="number">0</span>] &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLength = positive;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;  <span class="comment">//不变</span></span><br><span class="line">                ++positive;</span><br><span class="line">                negative = (negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">//全部取反</span></span><br><span class="line">                <span class="keyword">int</span> newPositive = negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> newNegative = positive + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">tie</span>(positive, negative) = &#123;newPositive, newNegative&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                positive = negative = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, positive);  <span class="comment">//乘积为正数的最长子数组长度</span></span><br><span class="line">            <span class="comment">//maxLength = max(maxLength, negative);//乘积为负数的最长子数组长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mx = values[<span class="number">0</span>] + <span class="number">0</span>;    <span class="comment">//mx = values[i] + i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; values.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mx + values[j] - j); <span class="comment">//values[j] - j是固定不变的</span></span><br><span class="line">            <span class="comment">// 边遍历边维护</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, values[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-单串-LIS-系列🀄️"><a href="#5-单串-LIS-系列🀄️" class="headerlink" title="(5)单串 LIS 系列🀄️"></a>(5)单串 LIS 系列🀄️</h3><h5 id="300-最长递增子序列🀄️"><a href="#300-最长递增子序列🀄️" class="headerlink" title="300. 最长递增子序列🀄️"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210608210105555.png" alt="image-20210608210105555"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不要求连续</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;	<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])	<span class="comment">//i在j之后，严格递增</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);<span class="comment">//没有减，所以下标为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());<span class="comment">//取里面最大的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心+二分</span></span><br><span class="line"><span class="comment">//T:O(nlogn) S:O(n)</span></span><br><span class="line"> <span class="comment">//如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">//d数组单调递增</span></span><br><span class="line">        d[len] = nums[<span class="number">0</span>];           <span class="comment">//d[1] =nums[0]初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;   </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123; <span class="comment">//d数组的数尽可能小</span></span><br><span class="line">                d[++len] = nums[i]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">//所有的数不小于nums[i] ，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123; <span class="comment">//在d数组中寻找比nums[i]小的</span></span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="673-最长递增子序列的个数🀄️"><a href="#673-最长递增子序列的个数🀄️" class="headerlink" title="673. 最长递增子序列的个数🀄️"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210611230159775.png" alt="image-20210611230159775"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)  S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多了个count，记录最长递增子序列个数</span></span><br><span class="line"><span class="comment">循环：</span></span><br><span class="line"><span class="comment">	长度一样的，i的cnt加上j</span></span><br><span class="line"><span class="comment">	dp[j]+1&gt;dp[i]，则更新dp[i]；同时i的cnt跟j一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">      	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;	</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(dp[j]+<span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                      	dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])<span class="comment">//长度一样的</span></span><br><span class="line">                    	cnt[i] += cnt[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">int</span> max_length = *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">      	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == max_length)</span><br><span class="line">          	    res +=cnt[i]; </span><br><span class="line">        <span class="keyword">return</span> res;	</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//贪心 + 前缀和 + 二分查找   T:O(nlogn) S:O(n)</span></span><br></pre></td></tr></table></figure>

<h5 id="354-俄罗斯套娃信封问题🀄️"><a href="#354-俄罗斯套娃信封问题🀄️" class="headerlink" title="354. 俄罗斯套娃信封问题🀄️"></a><a href="https://leetcode-cn.com/problems/russian-doll-es/">354. 俄罗斯套娃信封问题</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// ⚠️重点：因为我们在找第 i 件物品的前一件物品时，会对前面的 i - 1 件物品都遍历一遍，因此第二维（高度）排序与否都不影响</span></span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;	<span class="comment">//找下界</span></span><br><span class="line">                <span class="keyword">if</span> (es[j][<span class="number">1</span>] &lt; es[i][<span class="number">1</span>]) &#123;	<span class="comment">//递增</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法2:二分+动态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;es[<span class="number">0</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> num = es[i][<span class="number">1</span>]; num &gt; dp.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), num);</span><br><span class="line">                *it = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-贪心数组"><a href="#6-贪心数组" class="headerlink" title="(6)贪心数组"></a>(6)贪心数组</h3><h5 id="55-跳跃游戏🀄️"><a href="#55-跳跃游戏🀄️" class="headerlink" title="55. 跳跃游戏🀄️"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历数组：</span></span><br><span class="line"><span class="comment">	维护最远可以达到位置</span></span><br><span class="line"><span class="comment">	如果&gt;=n-1，则可以到达</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;  <span class="comment">//实时维护 最远可以到达的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;   <span class="comment">// x+nums[x]≥y, x本身可以到达</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);    </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="45-跳跃游戏-II🀄️"><a href="#45-跳跃游戏-II🀄️" class="headerlink" title="45. 跳跃游戏 II🀄️"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</span></span><br><span class="line"><span class="comment">在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123; <span class="comment">//当前i可以到达r</span></span><br><span class="line">                    end = r;	<span class="comment">//更新边界</span></span><br><span class="line">                    ++step;<span class="comment">//每过一个边界+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-带维度单串-dp-i-k"><a href="#7-带维度单串-dp-i-k" class="headerlink" title="(7)带维度单串 dp[i] [k]"></a>(7)带维度单串 dp[i] [k]</h3><h4 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="1478-安排邮筒"><a href="#1478-安排邮筒" class="headerlink" title="1478. 安排邮筒"></a><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">1478. 安排邮筒</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数，前缀和维护状态转移时的查询</span><br></pre></td></tr></table></figure>



<h4 id="1230-抛掷硬币"><a href="#1230-抛掷硬币" class="headerlink" title="1230. 抛掷硬币"></a><a href="https://leetcode-cn.com/problems/toss-strange-coins/">1230. 抛掷硬币</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是份数</span></span><br></pre></td></tr></table></figure>

<h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是次数，k 上有二分</span></span><br></pre></td></tr></table></figure>

<h4 id="975-奇偶跳"><a href="#975-奇偶跳" class="headerlink" title="975. 奇偶跳"></a><a href="https://leetcode-cn.com/problems/odd-even-jump/">975. 奇偶跳</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示当前的奇偶状态</span></span><br></pre></td></tr></table></figure>



<h4 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示上一步的跳的步数</span></span><br></pre></td></tr></table></figure>

<h4 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256. 粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">256. 粉刷房子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265. 粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">265. 粉刷房子 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— 有两个指标 k 颜色；t 街区数</span></span><br></pre></td></tr></table></figure>

<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)</span></span><br><span class="line"><span class="comment">/*暴力 O(n^3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	for(n)</span></span><br><span class="line"><span class="comment">		for(n)&#123;</span></span><br><span class="line"><span class="comment">			isVaild(n)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">//()()相邻匹配，</span></span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">// ()(()) 2:自身   dp[i - dp[i - 1] - 2]：外部  dp[i-1]：内部</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211019170438187.png" alt="image-20211019170438187"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n));  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;       <span class="comment">//每个字符的最大长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-双串"><a href="#8-双串" class="headerlink" title="(8)双串"></a><strong>(8)双串</strong></h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211009202901971.png" alt="image-20211009202901971"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）二维DP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp"><a href="#712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp" class="headerlink" title="712. 两个字符串的最小ASCII删除和 —— LCS，len 和 ascii 各一个 dp"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a> —— LCS，len 和 ascii 各一个 dp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别</p>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1923-最长公共子路径-718题的扩展"><a href="#1923-最长公共子路径-718题的扩展" class="headerlink" title="1923. 最长公共子路径 718题的扩展"></a><a href="https://leetcode-cn.com/problems/longest-common-subpath/">1923. 最长公共子路径</a> 718题的扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">dp[i][j]表示s[i,j]是否为回文串</span></span><br><span class="line"><span class="comment">当且仅当 s[i] == s[j] &amp;&amp; dp[i+1][j-1]也为回文串=&gt;dp[i][j]是回文串</span></span><br><span class="line"><span class="comment">边界：</span></span><br><span class="line"><span class="comment">1）越界，break</span></span><br><span class="line"><span class="comment">2）单个字符串，true；两个，相同时为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>; <span class="comment">//最大长度</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;  <span class="comment">//最大长度时的左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) dp[i][i] = <span class="keyword">true</span>;    <span class="comment">//单个为true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">2</span>;L&lt;=len;L++)&#123;</span><br><span class="line">            <span class="comment">//遍历左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = L+i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len) <span class="keyword">break</span>; <span class="comment">//越界</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;   <span class="comment">//不等</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//s[i] == s[j]</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i +<span class="number">1</span> &lt;= <span class="number">3</span>)&#123;     <span class="comment">//长度小于等于3,此时为回文串</span></span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新结果</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span>&gt; maxLen)&#123;</span><br><span class="line">                    maxLen = j-i+<span class="number">1</span>; </span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双串问题：字符串匹配系列"><a href="#双串问题：字符串匹配系列" class="headerlink" title="双串问题：字符串匹配系列"></a>双串问题：字符串匹配系列</h3><h4 id="72"><a href="#72" class="headerlink" title="[72. )"></a>[72. )</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通配符匹配</li>
</ul>
<h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h4><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双串问题：其它双串-dp-i-j-问题"><a href="#双串问题：其它双串-dp-i-j-问题" class="headerlink" title="双串问题：其它双串 dp[i] [j] 问题"></a>双串问题：其它双串 dp[i] [j] 问题</h3><ul>
<li>交错字符串</li>
<li>不同的子序列</li>
</ul>
<h3 id="双串问题：带维度双串-dp-i-j-k"><a href="#双串问题：带维度双串-dp-i-j-k" class="headerlink" title="双串问题：带维度双串 dp[i] [j] [k]"></a>双串问题：带维度双串 dp[i] [j] [k]</h3><ul>
<li>扰乱字符串</li>
</ul>
<h3 id="9-矩阵"><a href="#9-矩阵" class="headerlink" title="(9)矩阵"></a><strong>(9)矩阵</strong></h3><p>矩阵 dp[i] [j]</p>
<ul>
<li>三角形最小路径和</li>
<li>最小路径和</li>
<li>地下城游戏</li>
<li>下降路径最小和</li>
<li>最大正方形</li>
<li>下降路径最小和  II</li>
</ul>
<p>矩阵 dp[i] [j] [k]</p>
<p>最大矩形</p>
<ul>
<li>矩形区域不超过 K 的最大数值和 —— k 为宽度</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移</li>
</ul>
<p>无串线性问题</p>
<ul>
<li>只有两个键的键盘</li>
<li>丑数 II</li>
<li>完全平方数</li>
<li>整数拆分</li>
</ul>
<h3 id="10-前缀和-区间求和、子矩形求和"><a href="#10-前缀和-区间求和、子矩形求和" class="headerlink" title="(10)前缀和(区间求和、子矩形求和)"></a>(10)前缀和(区间求和、子矩形求和)</h3><p><strong>求区间和</strong></p>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></p>
<p><strong>实现前缀和问题</strong></p>
<ul>
<li>区域和检索 - 数组不可变</li>
<li>二维区域和检索 - 矩阵不可变</li>
</ul>
<p><strong>数据结构维护前缀和</strong></p>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p>
<p>数据结构维护前缀和问题：HashMap 维护（1）<br>HashMap 维护（1），键是前缀和（状态）的值，值为第一次出现时的索引。</p>
<ul>
<li>和等于 k 的最长子数组长度</li>
<li>连续数组</li>
<li>每个元音包含偶数次的最长子字符串 —— 前缀状态为 a,e,i,o,u 的个数的奇偶</li>
</ul>
<p>HashMap 维护（2），键是前缀和（前缀状态）的值，值为出现次数。</p>
<ul>
<li>和为 K 的子数组</li>
<li>统计优美子数组 —— 前缀状态为奇数的个数</li>
</ul>
<p>HashMap 维护（3），键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）。</p>
<ul>
<li>连续的子数组和 —— 值为第一次出现时的索引</li>
<li>和可被 K 整除的子数组 —— 值为出现次</li>
</ul>
<p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，例如下面这几道题。</p>
<ul>
<li>除自身以外数组的乘积</li>
<li>寻找数组的中心索引</li>
<li>找两个和为目标值且不重叠的子数组 —— 前缀和后缀和分别推一次，推的时候保存信息（DP），枚举分割点</li>
</ul>
<p>二维前缀和</p>
<ul>
<li>元素和为目标值的子矩阵数量</li>
<li>矩阵区域和</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K</li>
</ul>
<p>前缀积</p>
<ul>
<li>乘积最大子数组</li>
<li>乘积小于K的子数组</li>
<li>最后 K 个数的乘积 —— 若乘法的前缀积会溢出，可以用对数的前缀和防溢出，但是结果转回整数需要用四舍五入而不是下取整</li>
</ul>
<p>前缀异或</p>
<ul>
<li>子数组异或查询</li>
<li>形成两个异或相等数组的三元组数目 —— 哈希表维护前缀异或结果，类似 「560. 和为 K 的子数组」</li>
</ul>
<p>差分问题</p>
<ul>
<li>区间加法 —— 用差分维护区间加法模板</li>
</ul>
<h1 id="6-DP-二"><a href="#6-DP-二" class="headerlink" title="6.DP(二)"></a>6.DP(二)</h1><h2 id="1-背包DP"><a href="#1-背包DP" class="headerlink" title="(1)背包DP"></a><strong>(1)背包</strong>DP</h2><blockquote>
<p>背包问题是一种组合优化的 NP 完全问题：有 <em>N</em> 个物品和容量为<em>V</em> 的背包，每个物品都有自己的体积 v 和价值 w，求拿哪些物品可以使得背包所装下物品的总价值最大。<br>如果限定每种物品只能选择 0 个或 1 个，则问题称为 <u>0-1 背包问题</u>；<br>如果不限定每种物品的数量，则问题称为无界背包问题或<u>完全背包问题</u>。<br>如果每种物品的数量不一样，则问题称为<u>多重背包问题</u>。<br>如果每组有多种物品，每组只能选择1种，则问题称为<u>分组背包问题</u>。</p>
</blockquote>
<!--more-->

<p><strong>背包问题的分析步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析是否为背包问题。</span><br><span class="line">1)是背包问题三种问法中的哪一种。</span><br><span class="line">2)0-1 背包问题还是完全背包问题，即求最值。</span><br><span class="line">也就是题目给的 nums 数组中的元素是否可以重复使用。</span><br><span class="line">3)如果是组合问题，即求方案数，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法，需要注意。</span><br></pre></td></tr></table></figure>

<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html">背包问题总结篇</a></p>
<p><img src="/2021/01/02/6.DP/20210117171307407.png" alt="416.分割等和子集1"></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="/2021/01/02/6.DP/image-20210330110645464.png" alt="image-20210330110645464"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], 前i个物品且体积&lt;=j时的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">             <span class="comment">// 能装，需要决策选与不选第 i 个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];	<span class="comment">// 体积,价值</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//先遍历物品，再遍历背包</span></span><br><span class="line">      <span class="comment">//如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙保证物品i只被放入一次，防止dp[i]加上计算过的dp[i-1]</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么一维情况下枚举背包容量需要逆序？</span></span><br><span class="line"><span class="comment">一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题理论基础二维dp数组</a></p>
<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题理论基础一维dp数组（滚动数组）</a></p>
<h4 id="416-分割等和子集🀄️"><a href="#416-分割等和子集🀄️" class="headerlink" title="416. 分割等和子集🀄️"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1)dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123; </span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<span class="comment">//(2)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有两个维度的01背包</span></span><br><span class="line"><span class="comment">//(1)dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// (3)默认初始化0</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// (4)遍历物品</span></span><br><span class="line">            <span class="keyword">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeroNum; i--) &#123; <span class="comment">// 遍历背包容量且从后向前遍历！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>###完全背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:朴素做法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k*v[i]&lt;=j ; k++)	<span class="comment">//体积最大j</span></span><br><span class="line">              f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/6.DP/image-20210330125318496.png" alt="image-20210330125318496"></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:优化</span></span><br><span class="line"><span class="comment">先遍历物品，后遍历背包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i] ; j&lt;=m ;j++) <span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">              f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换🀄️"><a href="#322-零钱兑换🀄️" class="headerlink" title="322. 零钱兑换🀄️"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题 T:O(amount*coins)  S:O(amount)   amount:总金额，coins为硬币数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;    <span class="comment">//dp[i]代表金额i所需最少的硬币个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;                          <span class="comment">//金额0所需要的0个硬币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=amount;i++)&#123;	<span class="comment">//⚠️先遍历金额</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;<span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)&#123;  <span class="comment">//当前金额i必须&gt;=j，才可以兑换</span></span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II🀄️"><a href="#518-零钱兑换-II🀄️" class="headerlink" title="518. 零钱兑换 II🀄️"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案问题 T:O(amount*coins)  S:O(amount)   amount:总金额(背包)，coins为硬币数</span></span><br><span class="line"><span class="comment">//同原始 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;   <span class="comment">//dp[i]代表金额i的方案数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;                    <span class="comment">//金额0所需要的0个硬币,1个方案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;     <span class="comment">//⚠️先遍历面额，这样内循环遍历的金额都是按顺序的，不会重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin ; i&lt;=amount;i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><p><img src="/2021/01/02/6.DP/image-20211022230148139.png" alt="image-20211022230148139"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题  T:O(n∗sqrt(n))</span></span><br><span class="line"><span class="comment">//(1)dp[i]代表i用最少的平方数的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">// (3)默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;         <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;  <span class="comment">// (4)顺序遍历</span></span><br><span class="line">                dp[i] =<span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// (2)动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><p><img src="/2021/01/02/6.DP/image-20211022221506617.png" alt="image-20211022221506617"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="comment">//拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123; <span class="comment">//哈希表</span></span><br><span class="line">            dict.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// dp[i]表示字符串 s 前 i 个字符组成的字符串 s[0..i−1]是否能被空格拆分成若干个字典中出现的单词</span></span><br><span class="line">        vector &lt;<span class="keyword">bool</span>&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 前i个字符串[0..j-1] 子串：[j,i]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案数问题	T:O(targer*n) S:O(targer)</span></span><br><span class="line"><span class="comment">//（1）用 dp[i]表示选取的元素之和等于 i 的方案数</span></span><br><span class="line"><span class="comment">//nums数组就是物品，target就是背包，数字能否组成targer，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="进阶爬楼梯"><a href="#进阶爬楼梯" class="headerlink" title="进阶爬楼梯"></a>进阶爬楼梯</h4><p><strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html">动态规划：关于多重背包，你该了解这些！</a></p>
<p><a href="https://www.acwing.com/problem/content/description/4/">4.多重背包问题 I</a></p>
<blockquote>
<p>一个基本思路是，将此问题转换为01背包求解！</p>
<p>比如物品1有3件，每件价值为2，我们不妨创建3个物品1，存在数组v和数组w中</p>
<p>最终更新一下总物品数n即可，然后套用01背包问题进行求解。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">朴素版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,n,m,dp[<span class="number">10005</span>]=&#123; &#125;,w,v,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s--)</span><br><span class="line">    &#123;a[++t]=v;</span><br><span class="line">    b[t]=w;&#125;<span class="comment">//死拆，把多重背包拆成01背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a[i];j--)</span><br><span class="line">    dp[j]=<span class="built_in">max</span>(dp[j-a[i]]+b[i],dp[j]);<span class="comment">//直接套01背包的板子</span></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优化版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>],n,m,v,w,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v;j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.acwing.com/problem/content/5/">5. 多重背包问题 II</a></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7z0e5ghloj31150fw0ub.png" alt="image.png"></p>
<p>思路和多重背包问题I一样，但这题的数据范围变成1000了，非优化写法时间复杂度O(n^3) 接近 1e9</p>
<p>必超时。</p>
<p><img src="/2021/01/02/6.DP/image-20210330214658423.png" alt="image-20210330214658423"></p>
<p><img src="/2021/01/02/6.DP/image-20210330214742786.png" alt="image-20210330214742786"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N],n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;good&gt; Good;</span><br><span class="line">    good tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="comment">//坑,k &lt;= s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= s ; k*=<span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            Good.<span class="built_in">push_back</span>(&#123;k*w,k*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) Good.<span class="built_in">push_back</span>(&#123;s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包优化+二进制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : Good)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= t.v ; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j] , dp[j-t.v]+t.w ); <span class="comment">//这里就是dp[j]</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/problem/content/6/">6. 多重背包问题 III</a></p>
<p><strong>(单调队列优化) O(NV)</strong></p>
<p>一共 n 类物品，背包的容量是 m</p>
<p>每类物品的体积为v, 价值为w，个数为s</p>
<p>我们先来回顾一下传统的dp方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(不放入物品 i，放入<span class="number">1</span>个物品 i，放入<span class="number">2</span>个物品 i, ... , 放入k个物品 i)</span><br><span class="line">这里 k 要满足：k &lt;= s, j - k*v &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">不放物品  i = dp[i<span class="number">-1</span>][j]</span><br><span class="line">放k个物品 i = dp[i<span class="number">-1</span>][j - k*v] + k*w</span><br><span class="line"></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v] + w, dp[i<span class="number">-1</span>][j<span class="number">-2</span>*v] + <span class="number">2</span>*w,..., dp[i<span class="number">-1</span>][j-k*v] + k*w)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">实际上我们并不需要二维的dp数组，适当的调整循环条件，我们可以重复利用dp数组来保存上一轮的信息</span><br><span class="line"></span><br><span class="line">我们令 dp[j] 表示容量为j的情况下，获得的最大价值</span><br><span class="line">那么，针对每一类物品 i ，我们都更新一下 dp[m] --&gt; dp[<span class="number">0</span>] 的值，最后 dp[m] 就是一个全局最优值</span><br><span class="line"></span><br><span class="line">dp[m] = <span class="built_in">max</span>(dp[m], dp[m-v] + w, dp[m<span class="number">-2</span>*v] + <span class="number">2</span>*w, dp[m<span class="number">-3</span>*v] + <span class="number">3</span>*w, ...)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">显而易见，m 一定等于 k*v + j，其中  <span class="number">0</span> &lt;= j &lt; v</span><br><span class="line">所以，我们可以把 dp 数组分成 j 个类，每一类中的值，都是在同类之间转换得到的</span><br><span class="line">也就是说，dp[k*v+j] 只依赖于 &#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125;</span><br><span class="line"></span><br><span class="line">因为我们需要的是&#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125; 中的最大值，</span><br><span class="line">可以通过维护一个单调队列来得到结果。这样的话，问题就变成了 j 个单调队列的问题</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">所以，我们可以得到</span><br><span class="line">dp[j]    =     dp[j]</span><br><span class="line">dp[j+v]  = <span class="built_in">max</span>(dp[j] +  w,  dp[j+v])</span><br><span class="line">dp[j+<span class="number">2</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">2</span>w,  dp[j+v] +  w, dp[j+<span class="number">2</span>v])</span><br><span class="line">dp[j+<span class="number">3</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">3</span>w,  dp[j+v] + <span class="number">2</span>w, dp[j+<span class="number">2</span>v] + w, dp[j+<span class="number">3</span>v])</span><br><span class="line">...</span><br><span class="line">但是，这个队列中前面的数，每次都会增加一个 w ，所以我们需要做一些转换</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">单调队列问题，最重要的两点</span><br><span class="line"><span class="number">1</span>）维护队列元素的个数，如果不能继续入队，弹出队头元素</span><br><span class="line"><span class="number">2</span>）维护队列的单调性，即：尾值 &gt;= dp[j + k*v] - k*w</span><br><span class="line"></span><br><span class="line">本题中，队列中元素的个数应该为 s+<span class="number">1</span> 个，即 <span class="number">0</span> -- s 个物品 i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], pre[N], q[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= m; k += v) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - s*v &gt; q[head])</span><br><span class="line">                    ++head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] - (q[tail] - j)/v * w &lt;= pre[k] - (k - j)/v * w)</span><br><span class="line">                    --tail;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head])/v * w);</span><br><span class="line"></span><br><span class="line">                q[++tail] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><a href="https://www.acwing.com/problem/content/9/">9. 分组背包问题</a></p>
<p><img src="/2021/01/02/6.DP/image-20210330215834022.png" alt="image-20210330215834022"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];  <span class="comment">//只从前i组物品中选，当前体积小于等于j的最大值</span></span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];   <span class="comment">//v为体积，w为价值，s代表第i组物品的个数</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123; <span class="comment">//第i组的第k个物品</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一维优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;    <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最值问题</strong></p>
<ul>
<li>零钱兑换（完全背包）</li>
<li>一和零（二维费用背包）</li>
<li>最后一块石头的重量 II —— 转换为01背包问题，使得背包剩余容量最小</li>
</ul>
<p>这道题是要求<strong>恰好取到背包容量</strong>的背包问题。</p>
<ul>
<li>分割等和子集（01 背包 - 要求恰好取到背包容量）</li>
</ul>
<p><strong>方案数问题</strong></p>
<p>这四道题是背包问题求方案数的题目，涉及到 01背包，完全背包的方案数问题。以及考虑顺序和不考虑顺序的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组合总和 Ⅳ —— 顺序不同的序列被视作不同的组合</span><br><span class="line">目标和 —— 01背包-求方案数</span><br><span class="line">零钱兑换 II —— 完全背包-求方案数</span><br><span class="line">盈利计划 —— 01背包-求方案数总价值有要求：有下限</span><br></pre></td></tr></table></figure>

<h2 id="2-状态压缩DP"><a href="#2-状态压缩DP" class="headerlink" title="(2)状态压缩DP"></a>(2)状态压缩DP</h2><p>安卓系统手势解锁<br>我能赢吗<br>不同路径 III —— 状态压缩 DP + 记忆化<br>划分为 k 个相等的子集 —— 状态压缩 DP + 记忆化<br>访问所有节点的最短路径 —— Floyd + 状态压缩 DP 求最短哈密顿路<br>最短超级串 —— 状态压缩 DP + DP 过程记录路径<br>优美的排列<br>骑士拨号器<br>参加考试的最大学生数<br>大礼包<br>贴纸拼词<br>按位与为零的三元组</p>
<h2 id="3-树形DP"><a href="#3-树形DP" class="headerlink" title="(3)树形DP"></a>(3)树形DP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-区间DP"><a href="#4-区间DP" class="headerlink" title="(4)区间DP"></a>(4)区间DP</h2><p><strong>回文相关问题</strong></p>
<ul>
<li>最长回文子串</li>
<li>回文子串</li>
<li>最长回文子序列</li>
<li>段式回文</li>
<li>统计不同回文子字符串</li>
<li>让字符串成为回文串的最少插入次数 —— 最长回文子序列</li>
</ul>
<p><strong>区间动态规划其它问题</strong></p>
<p>戳气球<br>移除盒子 —— 戳气球升级版，[i][j] 基础上加了一维 k 状态，k 是 j 右侧与 j 相同的元素个数, 记忆化<br>多边形三角剖分的最低得分<br>奇怪的打印机<br>合并石头的最低成本<br>预测赢家<br>编码最短长度的字符串</p>
<h2 id="5-计数DP"><a href="#5-计数DP" class="headerlink" title="(5)计数DP"></a>(5)计数DP</h2><p><a href="https://leetcode-cn.com/problems/unique-paths">62. 不同路径</a></p>
<p><a href="https://leetcode-cn.com/problems/paint-fence/">276. 栅栏涂色</a></p>
<p><strong>计数问题相关练习题</strong></p>
<ol>
<li>路径问题</li>
<li>卡特兰数</li>
<li>铺砖问题</li>
<li>斐波那契</li>
<li>隐晦的递推关系</li>
</ol>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></p>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p>
<h2 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="(6)数位DP"></a>(6)数位DP</h2><p><a href="https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p>
<p>以下 9 道题是力扣上数位 DP 相关的题目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满足某些条件的数字个数</span><br><span class="line">    最大为 N 的数字组合</span><br><span class="line">    中心对称数 III</span><br><span class="line">    计算各个位数不同的数字个数</span><br><span class="line">    不含连续 1 的非负整数</span><br><span class="line">    至少有 1 位重复的数字</span><br><span class="line">    易混淆数 II</span><br><span class="line"></span><br><span class="line">将 x∈[L,R]x \in [L, R]x∈[L,R] 代到一个函数 f(x) 中, 一个数字 x 的 f(x) 值为一次贡献的量, 求总的贡献</span><br><span class="line">    数字 1 的个数</span><br><span class="line">    范围内的数字计数</span><br><span class="line">    2 出现的次数</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-10-II-青蛙跳台阶问题🀄️"><a href="#剑指-Offer-10-II-青蛙跳台阶问题🀄️" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题🀄️"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20210813162608191.png" alt="image-20210813162608191"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="进阶跳台阶"><a href="#进阶跳台阶" class="headerlink" title="进阶跳台阶"></a><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">进阶跳台阶</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.动态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">        <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.数学</span></span><br><span class="line">f(n-<span class="number">1</span>) = f(n-<span class="number">2</span>) + f(n-<span class="number">3</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = <span class="number">2</span>*f(n-<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162640327.png" alt="image-20210813162640327"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(x,pre+x);	<span class="comment">//⚠️当前x 或者 x加上之前</span></span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-46-把数字翻译成字符串-🀄️"><a href="#剑指-Offer-46-把数字翻译成字符串-🀄️" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串 🀄️"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210812100300618.png" alt="image-20210812100300618"></p>
<p><img src="/2021/01/02/6.DP/image-20210812101125269.png" alt="image-20210812101125269"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T：O(n)</span></span><br><span class="line"><span class="comment">//S：用了滚动数组O(1)，但是这里用了一个临时变量把数字转化成了字符串，故渐进空间复杂度也是 O(log⁡n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            p =q;</span><br><span class="line">            q =r;</span><br><span class="line">            r =<span class="number">0</span>;</span><br><span class="line">            r += q; <span class="comment">//f(i-1)贡献</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String pre = str.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);    <span class="comment">//取i-1到i的子串</span></span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">                r+=p;   <span class="comment">//f(i-2)贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p><img src="/Users/zcz/Desktop/images/image-20210812101713646.png" alt="image-20210812101713646"></p>
<p><img src="/2021/01/02/6.DP/image-20210812102323894.png" alt="image-20210812102323894"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN)</span></span><br><span class="line"><span class="comment">//S:O(1) grid作为dp使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length; <span class="comment">//m行，n列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];              <span class="comment">//从左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];           <span class="comment">//从上</span></span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);<span class="comment">//从上或从左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设动态规划列表dp ，dp[i]代表第 i+1 个丑数；（下标从0开始的）</span></span><br><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="comment">//S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=dp[a]*<span class="number">2</span>,n2=dp[b]*<span class="number">3</span>,n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(n1,Math.min(n2,n3));</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字-约瑟环"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-约瑟环" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> 约瑟环</h4><p><img src="/2021/01/02/6.DP/image-20210813162901260.png" alt="image-20210813162901260"></p>
<p><img src="/2021/01/02/6.DP/image-20210813162843069.png" alt="image-20210813162843069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T:O(N) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;		<span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上往下推</span></span><br><span class="line">        <span class="keyword">return</span> (m + f(n - <span class="number">1</span>, m)) % n;		<span class="comment">//下一个删除的数   等价关系式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态 T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;		<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f = (m + f) % i;	<span class="comment">//⚠️从下往上推，从2开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162930157.png" alt="image-20210813162930157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);	<span class="comment">//min(prices[0:i])</span></span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-19-正则表达式匹配-困难"><a href="#剑指-Offer-19-正则表达式匹配-困难" class="headerlink" title="剑指 Offer 19. 正则表达式匹配  困难"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>  困难</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p><img src="/2021/01/02/6.DP/image-20210701155141042.png" alt="image-20210701155141042"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划+哈希</span></span><br><span class="line"><span class="comment">//由于返回值是取 dp列表最大值，因此可借助变量 tmp 存储 dp[j]</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>8.基础</title>
    <url>/2021/01/02/8.%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="8-基础"><a href="#8-基础" class="headerlink" title="8.基础"></a>8.基础</h1><blockquote>
<p>模拟</p>
<p>位运算</p>
<p>排序</p>
<p>前缀和，差分，离散化</p>
</blockquote>
<span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="400-第-N-位数字"><a href="#400-第-N-位数字" class="headerlink" title="400. 第 N 位数字"></a><a href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 位数字</a></h4><h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20210830173325392.png" alt="image-20210830173325392"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logn) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;	<span class="comment">//位数digit</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;	 <span class="comment">//digit位数的最小值 </span></span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;		<span class="comment">//数位数量count</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.计算n所在的数位数量count  </span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;	<span class="comment">//（n:11  n=2 count=180 start=10 digit=2 num=10 ）</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.计算n所在的数字num </span></span><br><span class="line">        <span class="keyword">return</span> to_string(num)[(n - <span class="number">1</span>)%digit]- <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.确定 n 是num 中的哪一数位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摩尔投票法</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> votes=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x?<span class="number">1</span>:<span class="number">-1</span>; <span class="comment">//当前num是否等于之前的众数x，是的加1，否则减1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//验证x是否为众数,本题不需要，因为总是存在众数</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == num) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; nums.<span class="built_in">size</span>()/<span class="number">2</span> ? x : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/54_fig1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层遍历</span></span><br><span class="line"><span class="comment">//T:O(mn) S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> row=M.<span class="built_in">size</span>(),col=M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> || col == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,bottom=row<span class="number">-1</span>,left=<span class="number">0</span>,right=col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &lt;= bottom &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) res.<span class="built_in">push_back</span>(M[top][i]); </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++) res.<span class="built_in">push_back</span>(M[i][right]);</span><br><span class="line">            <span class="keyword">if</span>(left &lt;right &amp;&amp; top &lt;bottom)&#123; <span class="comment">//注意</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=left;i--) res.<span class="built_in">push_back</span>(M[bottom][i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom<span class="number">-1</span>;i&gt;top;i--) res.<span class="built_in">push_back</span>(M[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++,right--,top++,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在1的基础上给矩阵M赋值num</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/1599920669-zaVZDZ-Picture7.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表格分区</span></span><br><span class="line"><span class="comment">//T:O(N)	S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>]; <span class="comment">//下三角乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];<span class="comment">//上三角乘积</span></span><br><span class="line">            b[i] *= tmp;    <span class="comment">//上x下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/0be9098b13047fe3e07f3c4e51c612244ace01a023ed010bce43940408334f2a-Picture1.png" alt="img"></p>
<p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220119173541415.png" alt="image-20220119173541415"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：处理空格，符号处理，非数字处理，越界处理(2种情况)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, bndry = INT_MAX / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sign = <span class="number">1</span>, len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//1.处理空格</span></span><br><span class="line">            <span class="keyword">if</span>(++i == len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>; <span class="comment">//2.符号处理</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>) i++;  <span class="comment">//开始下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] &lt; <span class="string">&#x27;0&#x27;</span> || str[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;         <span class="comment">//3.不是数字直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; str[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="comment">//4.越界处理(2种情况)</span></span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            res = res * <span class="number">10</span> + (str[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中文数字转阿拉伯数字"><a href="#中文数字转阿拉伯数字" class="headerlink" title="中文数字转阿拉伯数字"></a>中文数字转阿拉伯数字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阿拉伯数字转中文数字"><a href="#阿拉伯数字转中文数字" class="headerlink" title="阿拉伯数字转中文数字"></a>阿拉伯数字转中文数字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T:O(max(len(num1),len(num2)))，S:O(1)</span></span><br><span class="line"><span class="comment">思路：对两个大整数模拟竖式加法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;	<span class="comment">//add进位</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;	<span class="comment">//&lt;0，赋值为0</span></span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T:O(mn+n^2),S:O(m+n)</span></span><br><span class="line"><span class="comment">思路：每一位：模拟竖式加法；最后将结果相加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.<span class="built_in">size</span>()<span class="number">-1</span>, n = num2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">//倒序遍历num2每一位</span></span><br><span class="line">            string curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; i; j--) curr.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">//除最低位，其他需要补0。123，2补0，1补00</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//num2的每一位与num1相乘</span></span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;    <span class="comment">//进位</span></span><br><span class="line">            <span class="keyword">int</span> y = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1[j]- <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+add % <span class="number">10</span>);</span><br><span class="line">                add /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(curr.<span class="built_in">begin</span>(), curr.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">            res = <span class="built_in">addStrings</span>(res, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string &amp;num1, string &amp;num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;	<span class="comment">//add进位</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;	<span class="comment">//&lt;0，赋值为0</span></span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:哈希，左边小于右边时，记得减去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = map[s[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&lt; s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; val &lt; map[s[i+<span class="number">1</span>]]) res -= val;</span><br><span class="line">            <span class="keyword">else</span> res+=val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220119171122030.png" alt="image-20220119171122030"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将前面的「较小数」与后面的「较大数」交换</span></span><br><span class="line"><span class="comment">1.先找出最大的索引 i 满足 nums[i] &lt; nums[i+1]，如果不存在，就翻转整个数组；</span></span><br><span class="line"><span class="comment">2.再找出另一个最大索引 j 满足 nums[j] &gt; nums[i]；</span></span><br><span class="line"><span class="comment">交换 nums[i] 和 nums[j]；</span></span><br><span class="line"><span class="comment">3.最后翻转 nums[i+1:]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;    <span class="comment">//倒数第2个</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;  <span class="comment">//从后向前找，大于nums[i],找较小数的下标</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;   <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;    <span class="comment">//最后一个</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<span class="comment">//从后向前找，大于nums[i]，较大数的下标</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());  <span class="comment">//翻转后，(i+1,n)升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(log|x|)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || rev &gt; INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            res = res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> ) &#123; <span class="comment">// 例如:-1,10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220119160011746.png" alt="image-20220119160011746"></p>
<p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220119160104838.png" alt="image-20220119160104838"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T：O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">当 cur = 0 时:此位 1 的出现次数:high×digit</span></span><br><span class="line"><span class="comment">当 cur = 1 时:high×digit+low+1</span></span><br><span class="line"><span class="comment">当 cur &gt; 1 时： (high+1)×digit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>, res = <span class="number">0</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;<span class="comment">//当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            low += cur * digit;      <span class="comment">//将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">            cur = high % <span class="number">10</span>;        </span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365. 水壶问题"></a><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365. 水壶问题</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20211215152432707.png" alt="image-20211215152432707"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(xy)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(z &gt; (x + y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Math.<span class="built_in">min</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> max = Math.<span class="built_in">max</span>(x, y);</span><br><span class="line"></span><br><span class="line">        boolean[] app = <span class="keyword">new</span> boolean[max];   <span class="comment">//记录是否出现一个周期，是则说明永远达不到目标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!app[remain])&#123;</span><br><span class="line">            app[remain] = <span class="literal">true</span>;</span><br><span class="line">            remain = (remain + min) % max;</span><br><span class="line">            <span class="keyword">if</span>(remain == z || remain + max == z) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220122104354890.png" alt="image-20220122104354890"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：使用图的思想=&gt;总剩余汽油量 &gt;= 0；找出最低的剩余量的下标</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> spare = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minSpare = INT_MAX; <span class="comment">//最小剩余油量</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            spare += gas[i] - cost[i];  <span class="comment">//剩余油量</span></span><br><span class="line">            <span class="keyword">if</span> (spare &lt; minSpare) &#123;</span><br><span class="line">                minSpare = spare;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spare &lt; <span class="number">0</span> ? <span class="number">-1</span> : (minIndex + <span class="number">1</span>) % len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p><strong>从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。</strong></p>
<p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20220119164551553.png" alt="image-20220119164551553"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//约瑟夫环：f(n, m)= [f(n - 1, m)+m]%n</span></span><br><span class="line"><span class="comment">//f(n, m)该函数的返回值为最终留下的元素的下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (n == <span class="number">1</span>)     <span class="comment">/* 递归返回条件 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">lastRemaining</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表-1"><a href="#25-K-个一组翻转链表-1" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*快排：最坏O(n^2)</span></span><br><span class="line"><span class="comment">归并：O(nlogn)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并</span></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="comment">//T:O(NlogN) ，最差为 O(N^2) 	S:O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//(1)内置</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string&amp; x, string&amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y &lt; y + x;   <span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">//quickSort(strs, 0, strs.size() - 1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res+=strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//快排</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;string&gt;&amp;  q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>	<span class="comment">//默认从小到大排序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        string x = q[l];	<span class="comment">//l-1, r+1，由于do while先-,+， x基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] + x &gt; x + q[j]);    <span class="comment">/*  从后向前找比基准值小的 */</span></span><br><span class="line">            <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] + x &lt; x +q[i]);	<span class="comment">/*  从前向后找比基准值大的 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">//quick_sort(q, l, i-1), quick_sort(q, i, r);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T:O(nlogn),S:O(n)</span></span><br><span class="line"><span class="comment">归并排序，加了个计数器；在第2个数组元素归并上去时，计数，计数后的元素不再计算*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;<span class="comment">//辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;q,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//取分治点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="built_in">merge_sort</span>(q,l,mid)+<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r); <span class="comment">//递归</span></span><br><span class="line">        <span class="comment">/*这里ans存储了左区间和右区间的逆序对总数*/</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//此循环统计不同区间的逆序对</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]&lt;=q[j]) &#123;    <span class="comment">//小的放入数组</span></span><br><span class="line">                tmp[k++]=q[i++]; </span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">/*由于左区间和右区间已经有序当前左区间元素构成逆序,之后的都会构成逆序对*/</span></span><br><span class="line">                <span class="comment">/*所以ans需要加上区间长度*/</span></span><br><span class="line">                ans+=mid-i+<span class="number">1</span>;           </span><br><span class="line">                tmp[k++]=q[j++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;) q[i++]=tmp[j++];<span class="comment">//⚠️需要还原数组  </span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排划分思想：设置哨兵k  T：O(n) S:O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= arr.<span class="built_in">size</span>()) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quick_sort</span>(arr,k,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;  q,<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>	<span class="comment">//默认从小到大排序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>,x = q[l];	<span class="comment">//l-1, r+1，由于do while先-,+， x基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);    <span class="comment">/*  从后向前找比基准值小的 */</span></span><br><span class="line">            <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);	  <span class="comment">/*  从前向后找比基准值大的 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; k) <span class="built_in">quick_sort</span>(q, k, l, j);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k) <span class="built_in">quick_sort</span>(q, k, j + <span class="number">1</span>, r);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">assign</span>(q.<span class="built_in">begin</span>(),q.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求<strong>O(1)空间</strong>和O(n)时间。</p>
</blockquote>
<p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/2-9657443.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GOOGLE面试题  </span></span><br><span class="line"><span class="comment">//一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求O(1)空间和O(n)时间。  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NO_REPEAT_FLAG = <span class="number">-1</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t = x;  </span><br><span class="line">    x = y;  </span><br><span class="line">    y = t;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//类似于基数排序，找出数组中第一个重复元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  &#123;  </span><br><span class="line">        <span class="keyword">while</span> (i != a[i])  &#123;  </span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[a[i]])  <span class="keyword">return</span> a[i];  <span class="comment">//重复</span></span><br><span class="line">            <span class="built_in">Swap</span>(a[i], a[a[i]]);  <span class="comment">//不等,交换</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> NO_REPEAT_FLAG;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);  </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">int</span> a[MAXN] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>,  <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">    <span class="comment">//int a[MAXN] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组为: \n&quot;</span>);  </span><br><span class="line">    <span class="built_in">PrintfArray</span>(a, MAXN);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> nRepeatNumber = <span class="built_in">RadixSort</span>(a, MAXN);  </span><br><span class="line">    <span class="keyword">if</span> (nRepeatNumber != NO_REPEAT_FLAG)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该数组有重复元素，此元素为%d\n&quot;</span>, nRepeatNumber);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该数组没有重复元素\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(M):M二进制1的个数 S：O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组异或：(2,1,3,2)     其他2次，找2个</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//全员异或后得到这个只出现一次的数（本题需要找到2个）</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">//结果,0与任何数异或还是自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//找到第一位不是0的 是1</span></span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;	<span class="comment">//判断该位是否为0进行分组 （2，1，2）=&gt;1</span></span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//(3)</span></span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20210830112644359.png" alt="image-20210830112644359"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 333 的倍数。</span></span><br><span class="line"><span class="comment">//因此，统计所有数字的各二进制位中 1 的出现次数，并对3求余，结果则为只出现一次的数字。</span></span><br><span class="line"><span class="comment">//其他3次，找1个   (1,0,1,1)</span></span><br><span class="line"><span class="comment">//有限状态自动机 T:O(n)  S:O(1)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;	<span class="comment">//二进制数的2个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算：x ^ 0 = x， x ^ 1 = ~x</span></span><br><span class="line"><span class="comment">// 与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和 </span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">逻辑短路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));   <span class="comment">//A &amp;&amp; B,A为false时，则不执行B</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-II-001-整数除法"><a href="#剑指-Offer-II-001-整数除法" class="headerlink" title="剑指 Offer II 001. 整数除法"></a><a href="https://leetcode-cn.com/problems/xoh6Oh/">剑指 Offer II 001. 整数除法</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="面试题-01-01-判定字符是否唯一"><a href="#面试题-01-01-判定字符是否唯一" class="headerlink" title="面试题 01.01. 判定字符是否唯一"></a><a href="https://leetcode-cn.com/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="高低位交换"><a href="#高低位交换" class="headerlink" title="高低位交换"></a>高低位交换</h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20211216203523340.png" alt="image-20211216203523340"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高低位交换 by MoreWindows( http://blog.csdn.net/MoreWindows )    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfBinary</span><span class="params">(T a)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> i;  </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="built_in"><span class="keyword">sizeof</span></span>(a) * <span class="number">8</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)  </span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">if</span> ((a &gt;&gt; i) &amp; <span class="number">1</span>)  </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);  </span><br><span class="line">       <span class="keyword">else</span>   </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">8</span>)  </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;高低位交换 --- by MoreWindows( http://blog.csdn.net/MoreWindows )  ---\n\n&quot;</span>);  </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前:    &quot;</span>);  </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">3344520</span>;  </span><br><span class="line">   <span class="built_in">PrintfBinary</span>(a);  </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后:    &quot;</span>);  </span><br><span class="line">   a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>);  	<span class="comment">//核心</span></span><br><span class="line">   <span class="built_in">PrintfBinary</span>(a);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="面试题-17-24-最大子矩阵"><a href="#面试题-17-24-最大子矩阵" class="headerlink" title="面试题 17.24. 最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1838-最高频元素的频数"><a href="#1838-最高频元素的频数" class="headerlink" title="1838. 最高频元素的频数"></a><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="862-和至少为-K-的最短子数组"><a href="#862-和至少为-K-的最短子数组" class="headerlink" title="862. 和至少为 K 的最短子数组"></a><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/">862. 和至少为 K 的最短子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>7.数据结构</title>
    <url>/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="7-数据结构"><a href="#7-数据结构" class="headerlink" title="7. 数据结构"></a>7. 数据结构</h2><blockquote>
<p>数据结构：</p>
<p>链表</p>
<p>栈</p>
<p>队列</p>
<p>单调栈</p>
<p>单调队列</p>
<p>优先队列/堆</p>
<p>字符串</p>
<p>哈希</p>
<p>KMP</p>
<p>并查集</p>
<p>字典树</p>
<p>multiSet</p>
<p>组合数据结构：LRU</p>
</blockquote>
<span id="more"></span>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的且比它大/小的数</span><br><span class="line"><span class="comment">/*如何确定是使用严格单调栈还是非严格单调栈？只要根据题意确定我们栈中是否可以存放相同元素即可。</span></span><br><span class="line"><span class="comment">参考：https://blog.csdn.net/qq_17550379/article/details/86519771</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;	<span class="comment">//往左边找 栈顶比当前i比较  top&lt;i,单调递减，top&gt;i单调递增</span></span><br><span class="line">    stk[ ++ tt] = i;		<span class="comment">//将i插入栈中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">830.单调栈</span></span><br><span class="line"><span class="comment">先用暴力破解，再其中挖掘某些特性，每次把没用删除掉，得到单调栈</span></span><br><span class="line"><span class="comment">样例</span></span><br><span class="line"><span class="comment">输入样例：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3 4 2 7 5</span></span><br><span class="line"><span class="comment">输出样例：</span></span><br><span class="line"><span class="comment">-1 3 -1 2 2</span></span><br><span class="line"><span class="comment">3左边没有 返回-1	4左边3，返回3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N],tt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;s[tt]&gt;=x)tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[tt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        s[++tt]=x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题1：比当前元素更大的下一个元素 <strong>单调递减栈</strong></p>
<h4 id="42-接雨水-🀄️"><a href="#42-接雨水-🀄️" class="headerlink" title="42.接雨水 🀄️"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water">42.接雨水</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当后面的柱子高度比前面的低时，是无法接雨水的</span></span><br><span class="line"><span class="comment">当找到一根比前面高的柱子，就可以计算接到的雨水</span></span><br><span class="line"><span class="comment">所以使用单调递减栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们在遍历数组时维护一个栈。</span></span><br><span class="line"><span class="comment">如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。</span></span><br><span class="line"><span class="comment">如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此我们可以弹出栈顶元素并且累加答案到res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">//单调递减栈，存储h的下标</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;h.<span class="built_in">size</span>())&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &gt; h[stk.<span class="built_in">top</span>()])&#123; <span class="comment">//当前i &gt; 栈顶，才进入</span></span><br><span class="line">                <span class="keyword">int</span> top = stk.<span class="built_in">top</span>(); </span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">//空，栈顶前没有元素了</span></span><br><span class="line">                <span class="keyword">int</span> dis = i-stk.<span class="built_in">top</span>()<span class="number">-1</span>;  <span class="comment">// 栈顶前1个 &gt; 栈顶 &lt; 当前i，形成低洼</span></span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(h[stk.<span class="built_in">top</span>()],h[i])-h[top];<span class="comment">//min(栈顶前1个高度，当前i高度)-栈顶高度</span></span><br><span class="line">                res += dis*height;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i++);  <span class="comment">// 加入索引，而不是元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="496-下一个更大元素-I-🀄️"><a href="#496-下一个更大元素-I-🀄️" class="headerlink" title="496.下一个更大元素 I  🀄️"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i">496.下一个更大元素 I</a>  🀄️</h4><p><img src="/Users/zcz/Desktop/images/1598145577-ziwCvD-1.png" alt="ink-image"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nums1和nums2中所有整数 互不相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">倒着入栈，其实是正着出栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; my_map;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 存放答案的数组</span></span><br><span class="line">      	<span class="comment">//下面模板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums2[i]) &#123; <span class="comment">// 判定个子高矮,栈顶&lt;=当前,起开，当前要找大于它的</span></span><br><span class="line">                s.<span class="built_in">pop</span>(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">            my_map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums2[i], x));</span><br><span class="line">            s.<span class="built_in">push</span>(nums2[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums1.<span class="built_in">size</span>(); j++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(my_map[nums1[j]]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503.下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii">503.下一个更大元素 II</a></h4><p><img src="https://pic.leetcode-cn.com/1598145576-qOHCdl-3.png" alt="ink-image (/Users/zcz/Desktop/images/1598145576-qOHCdl-3.png)"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">环形数组：通过%模拟</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>; <span class="comment">// 存放结果</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 假装这个数组长度翻倍了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i % n])</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            res[i % n] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures">739.每日温度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=T.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : s.<span class="built_in">top</span>() - i;   <span class="comment">//索引距离</span></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题2：比当前元素更大的前一个元素 <strong>单调递减栈</strong></p>
<h4 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901.股票价格跨度"></a><a href="https://leetcode-cn.com/problems/online-stock-span">901.股票价格跨度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk,weights; <span class="comment">//stk存储price，</span></span><br><span class="line">  <span class="comment">//weights它离上一个价格之间（即最近的一个大于它的价格之间）的天数  100 80 60 75 (75：2)</span></span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &lt;= price )&#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            w += weights.<span class="built_in">top</span>();</span><br><span class="line">            weights.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(price);</span><br><span class="line">        weights.<span class="built_in">push</span>(w);</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题3：比当前元素更小的下一个元素  <strong>递增单调栈</strong></p>
<h4 id="84柱状图中最大的矩形-好难🀄️"><a href="#84柱状图中最大的矩形-好难🀄️" class="headerlink" title="84柱状图中最大的矩形   好难🀄️"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">84柱状图中最大的矩形</a>   好难🀄️</h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210419215726759.png" alt="image-20210419215726759"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">超时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            <span class="keyword">int</span> minHeight = INT_MAX;</span><br><span class="line">            <span class="comment">// 枚举右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="comment">// 确定高度</span></span><br><span class="line">                minHeight = <span class="built_in">min</span>(minHeight, heights[right]);</span><br><span class="line">                <span class="comment">// 计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先我们枚举某一根柱子 i 作为高 h=heights[i]</span></span><br><span class="line"><span class="comment">随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。 h &lt;=  heights[stk.top()]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = (stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>());</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = (stk.<span class="built_in">empty</span>() ? n : stk.<span class="built_in">top</span>());</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题4：比当前元素更小的前一个元素</p>
<h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><h4 id="剑指-Offer-59-I-滑动窗口的最大值⭐️"><a href="#剑指-Offer-59-I-滑动窗口的最大值⭐️" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值⭐️"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a>⭐️</h4><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(k)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;	  <span class="comment">//先生成1个k大小的窗口</span></span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);	<span class="comment">//元素num在数组中的下标为 index。</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;<span class="comment">//第一个最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;	</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);	<span class="comment">//当然当前元素</span></span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) &#123;<span class="comment">//维护当前窗口大小为k，将前面的删除掉</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。</p>
</blockquote>
<h4 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></h4><h4 id="932-漂亮数组"><a href="#932-漂亮数组" class="headerlink" title="932. 漂亮数组"></a><a href="https://leetcode-cn.com/problems/beautiful-array/">932. 漂亮数组</a></h4><h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球</a></h4><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">长度为0，true</span></span><br><span class="line"><span class="comment">为1，false；</span></span><br><span class="line"><span class="comment">利用栈，左括号的全部进栈；</span></span><br><span class="line"><span class="comment">遇到右括号时，出栈，看栈顶的元素与当前是否相同的，不同直接false；</span></span><br><span class="line"><span class="comment">最后，栈为空，true，不为空，false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Character&gt; stk= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">&#x27;(&#x27;</span> || chars[i] == <span class="string">&#x27;&#123;&#x27;</span> || chars[i] == <span class="string">&#x27;[&#x27;</span>) stk.push(chars[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">char</span> left = stk.pop();</span><br><span class="line">                <span class="keyword">if</span>((chars[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; left != <span class="string">&#x27;(&#x27;</span> ) </span><br><span class="line">                ||(chars[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; left != <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">                || (chars[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; left != <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="堆-amp-amp-优先队列"><a href="#堆-amp-amp-优先队列" class="headerlink" title="堆&amp;&amp;优先队列"></a>堆&amp;&amp;优先队列</h3><h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;   <span class="comment">//删除的是头结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;   <span class="comment">//2个指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) pre.next = cur.next;    <span class="comment">//如果找到了，将当前结点删除</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode l=head,r=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;r = r.next;&#125;</span><br><span class="line">        <span class="keyword">while</span>(r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            r = r.next;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* pre=nullptr;</span><br><span class="line">        <span class="keyword">while</span>(cur != nullptr)&#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//当前指向之前</span></span><br><span class="line">            pre = cur;      <span class="comment">//更新之前</span></span><br><span class="line">            cur = tmp;      <span class="comment">//更新当前结点为下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针+头插法</span></span><br><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">//虚假指针，解决头结点的问题</span></span><br><span class="line">        dummyNode-&gt;next = head; <span class="comment">//这样头结点就不会改了</span></span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;    <span class="comment">//先移动　left个</span></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = head;<span class="comment">//头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;             <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> head.next;       <span class="comment">//⚠️头结点没有存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力：for(k)&#123;两个两个合并&#125; T:O(k^2n) S:O(1)</span></span><br><span class="line"><span class="comment">//分治法：配对，k/2,k/4,k/8,... T:O(kn×logk) S:O(logk)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针  完美偶遇</span></span><br><span class="line"><span class="comment">// T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode node1 =headA,node2=headB;</span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="keyword">null</span> ? node1.next : headB;<span class="comment">//循环遍历A，到null时，变为headB</span></span><br><span class="line">            node2 = node2 != <span class="keyword">null</span> ? node2.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2;<span class="comment">//返回node1也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-20-表示数值的字符串-中等"><a href="#剑指-Offer-20-表示数值的字符串-中等" class="headerlink" title="剑指 Offer 20. 表示数值的字符串  中等"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串 </a> 中等</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode-cn.com/problems/lexicographical-numbers/">386. 字典序排数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="面试题-17-15-最长单词"><a href="#面试题-17-15-最长单词" class="headerlink" title="面试题 17.15. 最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-lcci/">面试题 17.15. 最长单词</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="792-匹配子序列的单词数"><a href="#792-匹配子序列的单词数" class="headerlink" title="792. 匹配子序列的单词数"></a><a href="https://leetcode-cn.com/problems/number-of-matching-subsequences/">792. 匹配子序列的单词数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="616-给字符串添加加粗标签"><a href="#616-给字符串添加加粗标签" class="headerlink" title="616. 给字符串添加加粗标签"></a><a href="https://leetcode-cn.com/problems/add-bold-tag-in-string/">616. 给字符串添加加粗标签</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="588-设计内存文件系统"><a href="#588-设计内存文件系统" class="headerlink" title="588. 设计内存文件系统"></a><a href="https://leetcode-cn.com/problems/design-in-memory-file-system/">588. 设计内存文件系统</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != map.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;<span class="comment">//找到了，直接返回</span></span><br><span class="line">            map[nums[i]] = i;<span class="comment">//没有找到,插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序哈希表</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;	<span class="comment">//初始为0	</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            res[it]++;</span><br><span class="line">            <span class="keyword">if</span>(res[it] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; us&#123; nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>() &#125;;<span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (us.<span class="built_in">find</span>(it) != us.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                us.<span class="built_in">erase</span>(it);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/350_fig1.gif" alt="fig1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">空间复杂度：O(min⁡(m,n))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二分，数组有序*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;	<span class="comment">//从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;	<span class="comment">//下标+1 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*哈希*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><h4 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218. 天际线问题"></a><a href="https://leetcode-cn.com/problems/the-skyline-problem/">218. 天际线问题</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="391-完美矩形"><a href="#391-完美矩形" class="headerlink" title="391. 完美矩形"></a><a href="https://leetcode-cn.com/problems/perfect-rectangle/">391. 完美矩形</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="850-矩形面积-II"><a href="#850-矩形面积-II" class="headerlink" title="850. 矩形面积 II"></a><a href="https://leetcode-cn.com/problems/rectangle-area-ii/">850. 矩形面积 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1851-包含每个查询的最小区间"><a href="#1851-包含每个查询的最小区间" class="headerlink" title="1851. 包含每个查询的最小区间"></a><a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/">1851. 包含每个查询的最小区间</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LCP-09-最小跳跃次数"><a href="#LCP-09-最小跳跃次数" class="headerlink" title="LCP 09. 最小跳跃次数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/">LCP 09. 最小跳跃次数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="850-矩形面积-II-1"><a href="#850-矩形面积-II-1" class="headerlink" title="850. 矩形面积 II"></a><a href="https://leetcode-cn.com/problems/rectangle-area-ii/">850. 矩形面积 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="组合数据结构"><a href="#组合数据结构" class="headerlink" title="组合数据结构"></a>组合数据结构</h3><h4 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b84cf65debb43b28bd212787ca63d34c9962696ed427f638763be71a3cb8f89d.png" alt="HashLinkedList"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map查找O（1）</span></span><br><span class="line"><span class="comment">//双向链表查找，删除O（1）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;  <span class="comment">//LU  最少使用</span></span><br><span class="line">    DLinkedNode* tail;  <span class="comment">//LRU 最近最少使用</span></span><br><span class="line">    <span class="keyword">int</span> size;	<span class="comment">//1.计数法</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="432-全-O-1-的数据结构"><a href="#432-全-O-1-的数据结构" class="headerlink" title="432. 全 O(1) 的数据结构"></a><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>0.绪论</title>
    <url>/2021/01/02/0.%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0.绪论"></a>0.绪论</h2><blockquote>
<p>理想公司=&gt;字节：和优秀的人一起做有挑战的事！</p>
</blockquote>
<p><code>明确：考的不是智商，是熟练度。</code></p>
<p><img src="/2021/01/02/0.%E7%BB%AA%E8%AE%BA/image-20210226104343928.png" alt="image-20210226104343928"></p>
<ul>
<li>代码 </li>
<li><strong>背模型</strong></li>
<li>题目</li>
</ul>
<blockquote>
<p>算法知识点-1.干嘛的，什么时候用，原理是什么 2.积累题型。<strong>参考</strong>：<a href="https://www.bilibili.com/read/cv9904414">郭大神</a>，<a href="https://space.bilibili.com/7836741">Y总</a></p>
</blockquote>
<span id="more"></span>

<h4 id="我刷题总结的笔记"><a href="#我刷题总结的笔记" class="headerlink" title="我刷题总结的笔记"></a><a href="conclusion/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.xlsx">我刷题总结的笔记</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; str;	<span class="comment">//不能接受空格字符串</span></span><br><span class="line"><span class="built_in">gets</span>(str);	<span class="comment">//可以 &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">to_string</span>(a);<span class="comment">//int转string</span></span><br><span class="line">string str;</span><br><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());<span class="comment">//string转int</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>9.图论</title>
    <url>/2021/01/02/9.%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="9-图论"><a href="#9-图论" class="headerlink" title="9.图论"></a>9.图论</h1><blockquote>
<p>图论：</p>
<p>拓扑排序<br>最短路径<br>最小生成树</p>
<p>染色法判别二分图<br>匈牙利算法</p>
</blockquote>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><blockquote>
<p>拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的 N个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。 </p>
</blockquote>
<span id="more"></span>

<h4 id="AcWing-848-有向图的拓扑序列"><a href="#AcWing-848-有向图的拓扑序列" class="headerlink" title="AcWing 848. 有向图的拓扑序列"></a><a href="https://www.acwing.com/problem/content/850/">AcWing 848. 有向图的拓扑序列</a></h4><p><strong>时间复杂度是 O(n+m) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每个顶点出现且只出现一次。</span></span><br><span class="line"><span class="comment">若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面，从前面指向后面</span></span><br><span class="line"><span class="comment">有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">伪代码</span></span><br><span class="line"><span class="comment">queue&lt;=所有入度为0的点</span></span><br><span class="line"><span class="comment">while(queue不空)&#123;</span></span><br><span class="line"><span class="comment">  t&lt;=队头</span></span><br><span class="line"><span class="comment">  枚举t的所有出边t-&gt;j</span></span><br><span class="line"><span class="comment">  删除t-&gt;j，d[j]--;</span></span><br><span class="line"><span class="comment">  if(d[j] == 0) queue&lt;=j;	//入度为0，入队</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])			<span class="comment">//入度为0，插入队列</span></span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];		<span class="comment">//t&lt;=队头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])	<span class="comment">//枚举t-&gt;j</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)		<span class="comment">//入度为0，入队</span></span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802. 找到最终的安全状态"></a><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>

<h4 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a><a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2115-从给定原材料中找到所有可以做出的菜"><a href="#2115-从给定原材料中找到所有可以做出的菜" class="headerlink" title="2115. 从给定原材料中找到所有可以做出的菜"></a><a href="https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/">2115. 从给定原材料中找到所有可以做出的菜</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><img src="/2021/01/02/9.%E5%9B%BE%E8%AE%BA/image-20210305211045316.png" alt="image-20210305211045316"></p>
<h4 id="朴素dijkstra算法-适合稠密图"><a href="#朴素dijkstra算法-适合稠密图" class="headerlink" title="朴素dijkstra算法  适合稠密图"></a><strong>朴素dijkstra算法  适合稠密图</strong></h4><p><a href="https://www.acwing.com/problem/content/851/">AcWing 849. Dijkstra求最短路 I</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dis[1]=0,dis[i]=+MAX</span></span><br><span class="line"><span class="comment">遍历v:</span></span><br><span class="line"><span class="comment">	t&lt;=不在s中的距离最近的点</span></span><br><span class="line"><span class="comment">	s&lt;=t</span></span><br><span class="line"><span class="comment">	用t更新其他点的距离	 dis[x] &gt; dis[t] + w</span></span><br><span class="line"><span class="comment">	1=&gt;x &gt; 1=&gt;t=&gt;x </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	稠密图的边数接近于或等于完全图 m 接近 n^2	  边多</span></span><br><span class="line"><span class="comment">	稀疏图 m 接近 n</span></span><br><span class="line"><span class="comment">	邻接矩阵：稠密图  邻接表：稀疏图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">// 存储每条边 邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//初始化正无穷</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;  <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) <span class="comment">//O(n^2)</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离 O(m)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化图 因为是求最短路径</span></span><br><span class="line">                                <span class="comment">//所以每个点初始为无限大</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        g[x][y]=<span class="built_in">min</span>(g[x][y],z);     <span class="comment">//如果发生重边的情况则保留最短的一条边</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化版dijkstra-适合稀疏图"><a href="#堆优化版dijkstra-适合稀疏图" class="headerlink" title="堆优化版dijkstra 适合稀疏图"></a><strong>堆优化版dijkstra 适合稀疏图</strong></h4><p><a href="https://www.acwing.com/problem/content/852/">850.Dijkstra求最短路 II</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;	<span class="comment">//距离，顶点编号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>; </span><br><span class="line"><span class="keyword">int</span> n,m;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边 </span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">//在a节点之后插入一个b节点，权重为c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><span class="comment">//插入边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;		<span class="comment">//第1点到自身的距离为0</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="comment">//小根堆 (少了寻找寻找距离最小的点)，</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);    <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())		</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); <span class="comment">//堆顶</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();					 </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;	<span class="comment">//已经找过了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;					<span class="comment">//标志找过</span></span><br><span class="line">				</span><br><span class="line">      <span class="comment">//在还未确定最短路的点中，用t更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];<span class="comment">//当前&gt;从t过来的距离</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p><a href="https://www.acwing.com/problem/content/855/">AcWing 853. 有边数限制的最短路</a></p>
<p><strong>时间复杂度是 O(nm) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for n	遍历顶点</span></span><br><span class="line"><span class="comment">	for e 遍历边 a,b,w   松弛操作</span></span><br><span class="line"><span class="comment">			dist[b] = min(dist[b],dist[a]+w)</span></span><br><span class="line"><span class="comment">遍历完</span></span><br><span class="line"><span class="comment">dist[b] &lt;= dist[a]+w</span></span><br><span class="line"><span class="comment">1=&gt;b	1=&gt;a=&gt;b	  </span></span><br><span class="line"><span class="comment">负环则，不存在最短路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 边，<span class="title">a</span>表示出点，<span class="title">b</span>表示入点，<span class="title">w</span>表示边的权重</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);	<span class="comment">//初始化</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] =<span class="built_in">min</span>(dist[b], dist[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 大于0x3f3f3f3f / 2,可能存在负环</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AcWing-851-spfa求最短路"><a href="#AcWing-851-spfa求最短路" class="headerlink" title="AcWing 851. spfa求最短路"></a><a href="https://www.acwing.com/problem/content/853/">AcWing 851. spfa求最短路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dist[b] =min(dist[b], dist[a] + w)</span></span><br><span class="line"><span class="comment">只有a变小，到b才会变小，优化不用每次都遍历所有边</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">queue &lt;= 1</span></span><br><span class="line"><span class="comment">while queue不空</span></span><br><span class="line"><span class="comment">	1.取对头，删除队头</span></span><br><span class="line"><span class="comment">	2.更新t的所有出边,t=&gt;b,   queue &lt;= b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">  	w[idx]=c;</span><br><span class="line">  	ne[idx]=h[a];</span><br><span class="line">  	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">  <span class="comment">//“当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率”</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="built_in">add</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">  <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="AcWing-852-spfa判断负环"><a href="#AcWing-852-spfa判断负环" class="headerlink" title="AcWing 852. spfa判断负环"></a><a href="https://www.acwing.com/problem/content/854/">AcWing 852. spfa判断负环</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组，求的不是距离的绝对值</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;  <span class="comment">//把所有点放到队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AcWing-854-Floyd求最短路"><a href="#AcWing-854-Floyd求最短路" class="headerlink" title="AcWing 854. Floyd求最短路"></a><a href="https://www.acwing.com/problem/content/856/">AcWing 854. Floyd求最短路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="787-K-站中转内最便宜的航班"><a href="#787-K-站中转内最便宜的航班" class="headerlink" title="787. K 站中转内最便宜的航班"></a><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="407-接雨水-II"><a href="#407-接雨水-II" class="headerlink" title="407. 接雨水 II"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h4 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="AcWing 858. Prim算法求最小生成树"></a><a href="https://www.acwing.com/problem/content/860/">AcWing 858. Prim算法求最小生成树</a></h4><p> <strong>时间复杂度是 O(n^2+m) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="keyword">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AcWing-859-Kruskal算法求最小生成树"><a href="#AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="AcWing 859. Kruskal算法求最小生成树"></a><a href="https://www.acwing.com/problem/content/861/">AcWing 859. Kruskal算法求最小生成树</a></h4><p><strong>时间复杂度是 O(mlogm) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1135-最低成本联通所有城市"><a href="#1135-最低成本联通所有城市" class="headerlink" title="1135. 最低成本联通所有城市"></a><a href="https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h2><blockquote>
<p>二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。</p>
</blockquote>
<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h4><p><strong>时间复杂度是 O(n+m) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><strong>时间复杂度是 O(nm) , n 表示点数，m 表示边数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                              </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1Java刷题</title>
    <url>/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>剑指offer，TOP100优先；最后类型题总</p>
</blockquote>
<p>#剑指offer</p>
<h2 id="（1）二叉树"><a href="#（1）二叉树" class="headerlink" title="（1）二叉树"></a>（1）二叉树</h2><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 07. 重建二叉树</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210306175018888.png" alt="image-20210306175018888"></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n) 中序遍历</span></span><br><span class="line"><span class="comment">思路：先序的第一个就是根结点，取出来；</span></span><br><span class="line"><span class="comment">再查找根结点在中序中的位置（hashmap）；</span></span><br><span class="line"><span class="comment">然后递归前序和中序的左区间，右区间来重建树的左子树和右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[preL];</span><br><span class="line">        <span class="keyword">int</span> pIndex = map.get(rootVal);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(pre,preL+<span class="number">1</span>,pIndex-inL+preL,inL,pIndex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(pre,pIndex-inL+preL+<span class="number">1</span>,preR,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen=pre.length,inLen=in.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++) map.put(in[i],i); <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(pre,<span class="number">0</span>,preLen-<span class="number">1</span>,<span class="number">0</span>,inLen-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8.二叉树的下一个结点"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">8.二叉树的下一个结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前驱节点：当前节点左子树的最右节点</span></span><br><span class="line"><span class="comment">后继节点：当前节点右子树的最左节点</span></span><br><span class="line"><span class="comment">（最左节点是中序遍历（左根右）的第一个节点。）</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）当前节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</span></span><br><span class="line"><span class="comment">2）否则，向上找第一个左指针指向的树包含该节点的祖先节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode right = pNode.right;	<span class="comment">//1）右子树</span></span><br><span class="line">            <span class="keyword">while</span>(right.left != <span class="keyword">null</span>)					<span class="comment">//最左节点</span></span><br><span class="line">                right = right.left;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123; <span class="comment">//2）⚠️找出其父结点</span></span><br><span class="line">                TreeLinkNode root = pNode.next;<span class="comment">//pNode是root的子结点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == pNode)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                pNode  = pNode.next;<span class="comment">//继续向上找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN) S:O(M)	M,N 分别为树 A 和 树 B 的节点数量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）只要有一个为空就不是</span></span><br><span class="line"><span class="comment">2）判断B是否为 A的总结构；递归A的左子树和B；A的右子树和B</span></span><br><span class="line"><span class="comment">3）B为空；A为空或者值不等；递归 A的左子树，B的左子树 &amp;&amp; A的右子树，B的右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || HasSubtree(A.left, B) || HasSubtree(A.right, B));	<span class="comment">//⚠️树B 是 树 A 左／右子树 的子结构 ||</span></span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;	<span class="comment">//O(N)   以 节点 A 为根节点的子树 包含树 B</span></span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;				<span class="comment">//1.B为空</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//2.A为空 或者A！=B</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);	<span class="comment">//⚠️AB的左右子树相同才是相同  &amp;&amp;</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="comment">//镜像，递归交换左右子树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210722224510100.png" alt="image-20210722224510100"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归判断左子树是否等于右子树</span></span><br><span class="line"><span class="comment">1）同为空</span></span><br><span class="line"><span class="comment">2）其中一个为空，或者值不同</span></span><br><span class="line"><span class="comment">3）递归左节点的左子树，右节点右子树；</span></span><br><span class="line"><span class="comment">	 递归左节点的右子树，右节点的左子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">true</span> : recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode l,TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;	<span class="comment">//先判断都为空</span></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || r == <span class="keyword">null</span> || r.val != l.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(l.left,r.right) &amp;&amp; recur(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//T：O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先将根节点放入队列中</span></span><br><span class="line"><span class="comment">while（队列不为空）&#123;</span></span><br><span class="line"><span class="comment">  取出对头，删除对头</span></span><br><span class="line"><span class="comment">  将值放入结果集中</span></span><br><span class="line"><span class="comment">  判断该节点的左节点是否空，不为空，放入队列中；</span></span><br><span class="line"><span class="comment">  判断该节点的右节点是否空，不为空，放入队列中；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按层放入结果集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> s = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=s;i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历 + 双端队列</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">奇数层，插入对头（从左到右）</span></span><br><span class="line"><span class="comment">偶数层，放入队尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> s = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.add(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.add(<span class="number">0</span>,node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-💣"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-💣" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列 💣"></a><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 33. 二叉搜索树的后序遍历序列</a> 💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/0b0f77f90c68ecf5d0d154f66971f32fa6feb5d50f01a2b2b627df2029a0a103-Picture10-20220227171019367.png" alt="Picture10.png"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227172451571.png" alt="image-20220227172451571"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历倒序==先序遍历的镜像， 左右根</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调栈 存储值递增</span></span><br><span class="line"><span class="comment">倒序遍历序列</span></span><br><span class="line"><span class="comment">1）左子树大于root，直接false</span></span><br><span class="line"><span class="comment">2）保证左子树&lt;右子树，更新root</span></span><br><span class="line"><span class="comment">3）将当前数据进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;		<span class="comment">//先赋值最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//倒序</span></span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="keyword">false</span>;	<span class="comment">//保证左子树&lt;root</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;postorder[i] &lt; stack.peek()  ) <span class="comment">//保证 左子树 &lt; 右子树</span></span><br><span class="line">                root = stack.pop();	<span class="comment">//更新root</span></span><br><span class="line">            stack.add(postorder[i]);<span class="comment">//单调递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-34-二叉树中和为某一值的路径💣"><a href="#剑指-Offer-34-二叉树中和为某一值的路径💣" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径💣"></a><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 34. 二叉树中和为某一值的路径💣</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减去root.val，递归左右子树</span></span><br><span class="line"><span class="comment">/*T,S:O(N)</span></span><br><span class="line"><span class="comment">思路：1）根左右遍历；选择当前值，更新目标值</span></span><br><span class="line"><span class="comment">2）路径记录（判断是否符合，符合就加入结果集）</span></span><br><span class="line"><span class="comment">3）递归左右子树</span></span><br><span class="line"><span class="comment">4）撤销选择（回溯）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,ArrayList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);	<span class="comment">//(1)选择</span></span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));<span class="comment">//深拷贝⚠️不用return</span></span><br><span class="line">        dfs(root.left,sum,path);</span><br><span class="line">        dfs(root.right,sum,path);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);	<span class="comment">//(2)回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        dfs(root,sum,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-36-二叉搜索树与双向链表💣"><a href="#剑指-Offer-36-二叉搜索树与双向链表💣" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表💣"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30356130386632652d393931342d346137372d393265662d6165626561656366346636362e6a7067.jpeg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span></span><br><span class="line"><span class="comment">排序的双向链表=&gt;中序遍历：</span></span><br><span class="line"><span class="comment">思路：中序遍历</span></span><br><span class="line"><span class="comment">1）递归左子树</span></span><br><span class="line"><span class="comment">2）cur.left = pre ，也构建 pre.right = cur </span></span><br><span class="line"><span class="comment">3）更新pre</span></span><br><span class="line"><span class="comment">4）head指向当前节点cur</span></span><br><span class="line"><span class="comment">5）递归右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(cur.left);</span><br><span class="line">  </span><br><span class="line">    cur.left = pre;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        pre.right = cur;</span><br><span class="line">    pre = cur; 				<span class="comment">//更新pre</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)		<span class="comment">//head记录1次</span></span><br><span class="line">        head = cur;		</span><br><span class="line">  </span><br><span class="line">    inOrder(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-37-序列化二叉树💣"><a href="#剑指-Offer-37-序列化二叉树💣" class="headerlink" title="剑指 Offer 37. 序列化二叉树💣"></a><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 37. 序列化二叉树</a>💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*序列化：二叉树转换为&quot;&#123;1,2,3,#,#,6,7&#125;&quot;；</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">反序列化：&quot;&#123;1,2,3,#,#,6,7&#125;&quot;转换为二叉树</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）取出空格的下标</span></span><br><span class="line"><span class="comment">2）取出deserializeStr空格前的字符串（当前节点），没有空格则是最后一个节点</span></span><br><span class="line"><span class="comment">3）更新deserializeStr（空格后的字符串）</span></span><br><span class="line"><span class="comment">4）创建根节点</span></span><br><span class="line"><span class="comment">5）递归创建左右子树</span></span><br><span class="line"><span class="comment">6）返回根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String deserializeStr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> root.val + <span class="string">&quot; &quot;</span> + Serialize(root.left) + <span class="string">&quot; &quot;</span> + Serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    deserializeStr = str;</span><br><span class="line">    <span class="keyword">return</span> Deserialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">Deserialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deserializeStr.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = deserializeStr.indexOf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    String node = index == -<span class="number">1</span> ? deserializeStr : deserializeStr.substring(<span class="number">0</span>, index);<span class="comment">//空格前的字符串,不包括index</span></span><br><span class="line">    deserializeStr = index == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : deserializeStr.substring(index + <span class="number">1</span>);<span class="comment">//空格后的字符串，更新deserializeStr</span></span><br><span class="line">    <span class="keyword">if</span> (node.equals(<span class="string">&quot;#&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> val = Integer.valueOf(node); <span class="comment">//String转int</span></span><br><span class="line">    TreeNode t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    t.left = Deserialize();</span><br><span class="line">    t.right = Deserialize();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=196&tqId=37117&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=196&page=1&search=%25E7%25AC%25ACk&difficulty=undefined&judgeStatus=undefined&tags=&title=%E7%AC%ACk">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历(⚠️这里是右根左，由于是递归)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>,cnt; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KthNode</span> <span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left,k);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k) res=root.val;</span><br><span class="line">        inOrder(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="comment">//T：O(N) S:O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(TreeDepth(root.left),TreeDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取左右子树的高度，如果abs(right-left) &gt; 1，则不是平衡树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        height(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(right-left) &gt; <span class="number">1</span>) res =<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）root == null，或者q或者p一个等于root，则当前root为最近公共祖先</span></span><br><span class="line"><span class="comment">2）如果 p 和 q 分别在root两个子树l,r中，那么就说明根节点就是最低公共祖先。</span></span><br><span class="line"><span class="comment">3）否则在l或者r</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q== root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode l = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l!=<span class="keyword">null</span>?l:r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-20-表示数值的字符串-中等"><a href="#剑指-Offer-20-表示数值的字符串-中等" class="headerlink" title="剑指 Offer 20. 表示数值的字符串  中等"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串 </a> 中等</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[]  ： 字符集合</span></span><br><span class="line"><span class="comment">()  ： 分组</span></span><br><span class="line"><span class="comment">?   ： 重复 0 ~ 1 次</span></span><br><span class="line"><span class="comment">+   ： 重复 1 ~ n 次</span></span><br><span class="line"><span class="comment">*   ： 重复 0 ~ n 次</span></span><br><span class="line"><span class="comment">.   ： 任意字符</span></span><br><span class="line"><span class="comment">\\. ： 转义后的 .</span></span><br><span class="line"><span class="comment">\\d ： 数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\\d?  0-1个数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">&quot;[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）回溯-amp-DFS-BFS"><a href="#（2）回溯-amp-DFS-BFS" class="headerlink" title="（2）回溯&amp;DFS_BFS"></a>（2）回溯&amp;DFS_BFS</h2><p>//DFS+回溯</p>
<h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://www.nowcoder.com/practice/69fe7a584f0a445da1b6652978de5c38?tpId=13&tqId=11218&tab=answerKey&from=cyc_github">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span></span><br><span class="line"><span class="comment">//T:O(M*N*3^K)不包含往上方向 S:O(M*N) K为word的长度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）遍历整个矩阵，从0开始递归</span></span><br><span class="line"><span class="comment">2）剪枝（越界，是否访问过，是否相等）</span></span><br><span class="line"><span class="comment">3）标志范访问过</span></span><br><span class="line"><span class="comment">4）遍历4个方向</span></span><br><span class="line"><span class="comment">5）回溯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] dirs=&#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] visted, <span class="keyword">char</span>[] word,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length == k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || i &lt;<span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || visted[i][j] || matrix[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        visted[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,dir[<span class="number">0</span>]+i,dir[<span class="number">1</span>]+j,visted,word,k+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        visted[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, idx = <span class="number">0</span>; r &lt; rows; r++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++)</span><br><span class="line">                matrix[r][c] = array[idx++];</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span> <span class="params">(String array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span> || cols ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">        <span class="keyword">this</span>.cols = cols;</span><br><span class="line">        <span class="keyword">char</span>[][] matrix = buildMatrix(array.toCharArray());</span><br><span class="line">        <span class="keyword">boolean</span>[][] visted = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">char</span>[] word = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix,i,j,visted,word,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>//dfs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="comment">//例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始递归</span></span><br><span class="line"><span class="comment">2）剪枝（越界，是否访问过，当前和是否大于k）</span></span><br><span class="line"><span class="comment">3）标志访问过</span></span><br><span class="line"><span class="comment">4）递归4个方向，累加4个方向和当前格子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//所有位数之和</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k,<span class="keyword">boolean</span>[][] vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || getSum(i) + getSum(j) &gt; k || vis[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vis[i][j] = <span class="keyword">true</span>;   <span class="comment">//标志访问过,不回头</span></span><br><span class="line">        <span class="keyword">return</span> dfs(i-<span class="number">1</span>,j,m,n,k,vis)+dfs(i+<span class="number">1</span>,j,m,n,k,vis)+dfs(i,j-<span class="number">1</span>,m,n,k,vis)+dfs(i,j+<span class="number">1</span>,m,n,k,vis)+<span class="number">1</span>;<span class="comment">//4个方向+当前格子(⚠️别忘了当前格子)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">       <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><p>//回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归全排列</span></span><br><span class="line"><span class="comment">//T：O(10^n) S:O(10^n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</span></span><br><span class="line"><span class="comment">1）循环n次</span></span><br><span class="line"><span class="comment">2）当前长度x == len，加入结果集</span></span><br><span class="line"><span class="comment">3）start，最高位不能为0，遍历1-9；其他位遍历0-9</span></span><br><span class="line"><span class="comment">	确定本位数字</span></span><br><span class="line"><span class="comment">	递归下一位数数字</span></span><br><span class="line"><span class="comment">	撤销当前选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">char</span> NUM[<span class="number">10</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成长度为 len 的数字，正在确定第x位（从左往右）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len) &#123;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = x==<span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// ⚠️X=0表示左边第一位数字，不能为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            cur.push_back(NUM[i]); <span class="comment">// 确定本位数字</span></span><br><span class="line">            backtrack(x+<span class="number">1</span>, len); <span class="comment">// 确定下一位数字</span></span><br><span class="line">            cur.pop_back(); <span class="comment">// 删除本位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 数字长度：1~n</span></span><br><span class="line">            backtrack(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_int;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)</span><br><span class="line">            res_int.push_back(stoi(res[i]));</span><br><span class="line">        <span class="keyword">return</span> res_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-38-字符串的排列💣"><a href="#剑指-Offer-38-字符串的排列💣" class="headerlink" title="剑指 Offer 38. 字符串的排列💣"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列💣</a></h4><p>//回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N!N) S:O(N^2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始递归</span></span><br><span class="line"><span class="comment">2）当前x等于字符串长度 加入结果集</span></span><br><span class="line"><span class="comment">循环&#123;</span></span><br><span class="line"><span class="comment">	剪枝：重复继续</span></span><br><span class="line"><span class="comment">	将当前元素放入hashset</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	选择，交换c[i]，固定x位</span></span><br><span class="line"><span class="comment">	递归x+1</span></span><br><span class="line"><span class="comment">	撤销选择</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c));      <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//存放字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);                      <span class="comment">// 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);                      <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x);                      <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（3）贪心"><a href="#（3）贪心" class="headerlink" title="（3）贪心"></a>（3）贪心</h2><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b b=0,1,2。推导=&gt;最优：把绳子尽可能切为多个长度为3的片段，次优2，最差1</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a=n/<span class="number">3</span>;	<span class="comment">//n=3*a+b</span></span><br><span class="line">        <span class="keyword">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a);    <span class="comment">//n=6,a=2 b=0 3^2</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;    <span class="comment">//n=7  a=2 b=1 3^1*4</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;    <span class="comment">//n=8 a=2 b=2 3^2*2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-14-II-剪绳子-II-💣"><a href="#剑指-Offer-14-II-剪绳子-II-💣" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II 💣"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a> 💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将长度为n，剪成m段，将每段绳子的长度相乘，结果取模 1e9+7，问最大乘积</span></span><br><span class="line"><span class="comment">思路：n =3a+b  快速幂求余</span></span><br><span class="line"><span class="comment">复杂度：S,T:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>,p=<span class="number">1000000007</span>; <span class="comment">//n =3a+b b=0,1,2</span></span><br><span class="line">        <span class="keyword">int</span> a = n/<span class="number">3</span>-<span class="number">1</span>;	<span class="comment">//少一个</span></span><br><span class="line">        <span class="comment">//base,a,p，求 base^a mod p。</span></span><br><span class="line">        <span class="keyword">long</span> base=<span class="number">3</span>,rem=<span class="number">1</span>;     <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;     <span class="comment">//n=9 rem=9</span></span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">1</span>) rem=rem*base%p;	<span class="comment">//有余数</span></span><br><span class="line">            base= base*base%p; <span class="comment">//注意</span></span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//举例子n=6,7,8</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>%p);<span class="comment">//rem^(a+1)%p   </span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">4</span>%p);  <span class="comment">//rem^(a)*4%p</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(rem*<span class="number">3</span>*<span class="number">2</span>%p);    <span class="comment">//rem^(a+1)*2%p          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="（4）双指针"><a href="#（4）双指针" class="headerlink" title="（4）双指针"></a>（4）双指针</h2><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 04. 二维数组中的查找</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键思想：从二维数组的右上角开始查找。</span></span><br><span class="line"><span class="comment">//T:O(n+m) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span> || M == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows=M.length, cols = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,c=cols-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= rows -<span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = M[r][c];</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; target) c--;</span><br><span class="line">            <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tqId=11155&tab=answerKey&from=cyc_github">剑指 Offer 05. 替换空格</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组扩展为原来3倍</span></span><br><span class="line"><span class="comment">遇到空格，替换为%20</span></span><br><span class="line"><span class="comment">没有直接放入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;  <span class="comment">//String是个对象</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>*len]; <span class="comment">//1个字符替换为3个字符，长度变为原来3倍</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);  </span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                arr[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[size++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = <span class="keyword">new</span> String(arr,<span class="number">0</span>,size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，搜索  T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*定义头指针 left ，尾指针 right .</span></span><br><span class="line"><span class="comment">left 一直往右移，直到它指向的值为偶数</span></span><br><span class="line"><span class="comment">right 一直往左移， 直到它指向的值为奇数</span></span><br><span class="line"><span class="comment">交换 nums[left] 和 nums[right] .</span></span><br><span class="line"><span class="comment">重复上述操作，直到 left==right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r= nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;r &amp;&amp; nums[l]%<span class="number">2</span>!=<span class="number">0</span>) l++;    <span class="comment">//往右寻找偶数(最左的偶数)</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;r &amp;&amp; nums[r]%<span class="number">2</span>==<span class="number">0</span>) r--;    <span class="comment">//往左寻找奇数</span></span><br><span class="line">            <span class="keyword">int</span> t=nums[l];</span><br><span class="line">            nums[l]=nums[r];</span><br><span class="line">            nums[r]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  ListNode l=pHead,r=pHead;</span><br><span class="line">  <span class="keyword">while</span>(r!=<span class="keyword">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) r=r.next;	<span class="comment">//顺序不能换</span></span><br><span class="line">  <span class="keyword">if</span>(k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//链表长度 &lt; k</span></span><br><span class="line">  <span class="keyword">while</span>(r!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    l=l.next;</span><br><span class="line">    r=r.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23.链表中环的入口结点"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">23.链表中环的入口结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//【快慢指针，同步指针】2次相遇：第1次相遇不清楚位置，第二次相遇为入口结点。重合时 fast 比 slow 多走 环的长度整数倍</span></span><br><span class="line"><span class="comment">//设快慢指针走了f,s步,</span></span><br><span class="line"><span class="comment">//第1次相遇：fast：f=2s(fast 每轮走 2 步) f=s+nb(比slow多走环的长度整数倍) ==&gt; slow:s = nb		a：环外的长度，b：环的长度</span></span><br><span class="line"><span class="comment">//此时：　slow:nb，只要让slow多走a步，就是环的入口。</span></span><br><span class="line"><span class="comment">//而我们只要令fast=head，跟slow同步走，第2次相遇时就是环的入口</span></span><br><span class="line"><span class="comment">//第2次相遇：让slow在a步停下来，让slow和fast在a处相遇，</span></span><br><span class="line"><span class="comment">//slow不变，fast=head，同步移动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode fast=pHead,slow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//无环⚠️</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;	<span class="comment">//第1次相遇 有环</span></span><br><span class="line">        &#125;</span><br><span class="line">  		<span class="comment">//第2次相遇</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = head;<span class="comment">//⚠️头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;             <span class="comment">//⚠️更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> head.next;       <span class="comment">//⚠️头结点没有存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对💣💣"><a href="#剑指-Offer-51-数组中的逆序对💣💣" class="headerlink" title="剑指 Offer 51. 数组中的逆序对💣💣"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对💣💣</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(nlogn),S:O(n)</span></span><br><span class="line"><span class="comment">//归并排序，加了个计数器</span></span><br><span class="line"><span class="comment">//在第2个数组元素归并上去时，计数，计数后的元素不再计算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//1.计数器</span></span><br><span class="line">    <span class="keyword">int</span>[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        </span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = nums[k];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = lo;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid || j &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)                 nums[index++] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)             nums[index++] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &lt;= aux[j])   nums[index++] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[index++] = aux[j++];  </span><br><span class="line">                count += mid - i + <span class="number">1</span>; <span class="comment">//2.累计逆序对</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 57. 和为s的两个数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针：搜索</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：sum = l +r;</span></span><br><span class="line"><span class="comment">sum&gt;target，r--;</span></span><br><span class="line"><span class="comment">else l++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="comment">//数组是递增排序好的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[l]+nums[r];</span><br><span class="line">            <span class="keyword">if</span>(t == sum) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[l],nums[r]));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; sum) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210629195210802.png" alt="image-20210629195210802"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针：滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(target)	S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：sum = (l+r)*(r-l+1)/2</span></span><br><span class="line"><span class="comment">sum == target，[l,r]</span></span><br><span class="line"><span class="comment">sum &gt; target,l++</span></span><br><span class="line"><span class="comment">sum &lt; target,r++</span></span><br><span class="line"><span class="comment">返回多个区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">       <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;	<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> sum = (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">//区间[l,r]的和</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)   tmp.add(i);   <span class="comment">//i-l从0开始放</span></span><br><span class="line">                res.add(tmp);</span><br><span class="line">                l++;                       <span class="comment">//开启新的区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) l++;    <span class="comment">//⚠️大了，l右移，减数</span></span><br><span class="line">            <span class="keyword">else</span> r++;                      <span class="comment">//小了，r右移，加数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）二分"><a href="#（5）二分" class="headerlink" title="（5）二分"></a>（5）二分</h3><h4 id="剑指-Offer-11-旋转数组的最小数字-同154-寻找旋转排序数组中的最小值-II"><a href="#剑指-Offer-11-旋转数组的最小数字-同154-寻找旋转排序数组中的最小值-II" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字 同154.寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a> 同154.寻找旋转排序数组中的最小值 II</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分法：</span></span><br><span class="line"><span class="comment">//与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：与右端元素比较</span></span><br><span class="line"><span class="comment">大于右端,则r =mid，最小值在左边</span></span><br><span class="line"><span class="comment">小于右端，则l = mid+1，最小值在右边</span></span><br><span class="line"><span class="comment">等于右端r--;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;        <span class="comment">//最小值在左边[l,mid]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l=mid+<span class="number">1</span>;   <span class="comment">//最小值在右边[mid+1,r]</span></span><br><span class="line">            <span class="keyword">else</span> r--;                               <span class="comment">//⚠️加这里，去除r边界,最小值在[l,r)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-16-数值的整数次方-快速幂"><a href="#剑指-Offer-16-数值的整数次方-快速幂" class="headerlink" title="剑指 Offer 16. 数值的整数次方 快速幂"></a><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 16. 数值的整数次方</a> 快速幂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">//base^a</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//处理0</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>)&#123;	<span class="comment">//处理负数</span></span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">            a = -a;a</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">1</span>) res=res*base;</span><br><span class="line">            base*=base;</span><br><span class="line">            a/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I⭐️"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I⭐️" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I⭐️"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>⭐️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="comment">//时间复杂度 O(logN) ： 二分法为对数级别复杂度。</span></span><br><span class="line"><span class="comment">//空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">与target比，</span></span><br><span class="line"><span class="comment">l &lt; = r;</span></span><br><span class="line"><span class="comment">hleper(nums,target)-hleper(nums,target-1);</span></span><br><span class="line"><span class="comment">寻找多个nums[mid] &lt;= target</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hleper(nums,target)-hleper(nums,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hleper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//target的右边界（边界不包括target）</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123; <span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l=mid+<span class="number">1</span>;    <span class="comment">//在[mid+1,r]	⚠️</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;                   <span class="comment">//在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字⭐️"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字⭐️" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字⭐️"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字⭐️</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logN) S:O(1)</span></span><br><span class="line"><span class="comment">//与中间下标比较</span></span><br><span class="line"><span class="comment">//相等，缺失值表明在右边；不等，表明在左边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;		<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)    l=mid+<span class="number">1</span>;<span class="comment">//相等，在[mid+1,r]</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;   <span class="comment">//不等，在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（6）DP"><a href="#（6）DP" class="headerlink" title="（6）DP"></a>（6）DP</h2><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, sum;	<span class="comment">//sum:f(n+1)   a:f(n-1) b:f(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	<span class="comment">//此时，b赋值给了a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">矩阵覆盖</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303863366535322d396639332d343465642d623662392d6536393035306531343830372e6a7067.jpeg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-10-II-青蛙跳台阶问题🀄️"><a href="#剑指-Offer-10-II-青蛙跳台阶问题🀄️" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题🀄️"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🀄️</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162608191.png" alt="image-20210813162608191"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进阶跳台阶"><a href="#进阶跳台阶" class="headerlink" title="进阶跳台阶"></a><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">进阶跳台阶</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.动态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">        <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.数学</span></span><br><span class="line">f(n-<span class="number">1</span>) = f(n-<span class="number">2</span>) + f(n-<span class="number">3</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>) + ... + f(<span class="number">0</span>)</span><br><span class="line">f(n) = <span class="number">2</span>*f(n-<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-19-正则表达式匹配-💣"><a href="#剑指-Offer-19-正则表达式匹配-💣" class="headerlink" title="剑指 Offer 19. 正则表达式匹配  💣"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>  💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 42. 连续子数组的最大和</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162640327.png" alt="image-20210813162640327"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">pre = max（当前数，上一个数+当前数）</span></span><br><span class="line"><span class="comment">res = max（上一次结果，pre）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,res = nums[<span class="number">0</span>];	<span class="comment">//⚠️初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(x,pre+x);	<span class="comment">//⚠️当前x 或者 x加上之前</span></span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-46-把数字翻译成字符串-🀄️"><a href="#剑指-Offer-46-把数字翻译成字符串-🀄️" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串 🀄️"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a> 🀄️</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812100300618.png" alt="image-20210812100300618"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101125269.png" alt="image-20210812101125269"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403222407023.png" alt="image-20220403222407023"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T：O(n)</span></span><br><span class="line"><span class="comment">//S：用了滚动数组O(1)，但是这里用了一个临时变量把数字转化成了字符串，故渐进空间复杂度也是 O(log⁡n)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意： 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”，有多少种不同的翻译方法。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">滚动数组：</span></span><br><span class="line"><span class="comment">1）单独一个数字q:f(n-1)</span></span><br><span class="line"><span class="comment">2）2个数字p:f(n-2)  r:f(n) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">1</span>; <span class="comment">//p:f(n-2) q:f(n-1) r:f(n) ⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            p =q;</span><br><span class="line">            q =r;</span><br><span class="line">            r =<span class="number">0</span>;	<span class="comment">//复原⚠️</span></span><br><span class="line">            r += q; <span class="comment">//f(i-1)贡献</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String pre = str.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);    <span class="comment">//取i-1到i的子串</span></span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">                r+=p;   <span class="comment">//f(i-2)贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812101713646.png" alt="image-20210812101713646"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210812102323894.png" alt="image-20210812102323894"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN)</span></span><br><span class="line"><span class="comment">//S:O(1) grid作为dp使用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）i，j都为0，直接跳过</span></span><br><span class="line"><span class="comment">2）从边界从左到右，从上到下，直接加；</span></span><br><span class="line"><span class="comment">3）中间元素，max（左边，上边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length; <span class="comment">//m行，n列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];              <span class="comment">//从左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];           <span class="comment">//从上</span></span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);<span class="comment">//从上或从左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210701155141042.png" alt="image-20210701155141042"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220310102655370.png" alt="image-20220310102655370"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划+哈希</span></span><br><span class="line"><span class="comment">//由于返回值是取 dp列表最大值，因此可借助变量 tmp 存储 dp[j]</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）获取当前j的索引下标（上次存过的），没有返回-1</span></span><br><span class="line"><span class="comment">2）tmp &lt; j-i（表明s[i]在字符串tmp之外） ,则 tmp+1；否则tmp = j-i</span></span><br><span class="line"><span class="comment">3）保存中间结果最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j),-<span class="number">1</span>);   <span class="comment">//获取i的索引,-1位默认值，与s.charAt(j)最左同字符的下标</span></span><br><span class="line">            dic.put(s.charAt(j),j); <span class="comment">//更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j-i ? tmp+<span class="number">1</span>:j-i;<span class="comment">//dp[j-1] &lt; j-i，则最长长度为tmp+1，否则有重复的，j-i</span></span><br><span class="line">            res = Math.max(res,tmp);    <span class="comment">//保存中间结果最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220403224922110.png" alt="image-20220403224922110"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</span></span><br><span class="line"><span class="comment">//设动态规划列表dp ，dp[i]代表第 i+1 个丑数；（下标从0开始的）</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）设置指针 a,b,c指向首个丑数（即 1 ）</span></span><br><span class="line"><span class="comment">2）当前dp[i] 赋值(n1,n2,n3)</span></span><br><span class="line"><span class="comment">3）判断当前dp[i]属于哪个，对应a，b，c加1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;	<span class="comment">//首个丑数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=dp[a]*<span class="number">2</span>,n2=dp[b]*<span class="number">3</span>,n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(n1,Math.min(n2,n3));	<span class="comment">//最小因子</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-60-n个骰子的点数💣"><a href="#剑指-Offer-60-n个骰子的点数💣" class="headerlink" title="剑指 Offer 60. n个骰子的点数💣"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a>💣</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162930157.png" alt="image-20210813162930157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）所有花费= min(当前价格,历史花费)  低价买入</span></span><br><span class="line"><span class="comment">2）max（当前利润，当前价格-所有花费） 高价卖出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;<span class="comment">//⚠️初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);	<span class="comment">//min(prices[0:i])</span></span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（7）数据结构"><a href="#（7）数据结构" class="headerlink" title="（7）数据结构"></a>（7）数据结构</h2><h3 id="7-1-模拟"><a href="#7-1-模拟" class="headerlink" title="7.1 模拟"></a>7.1 模拟</h3><h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&tqId=11203&tab=answerKey&from=cyc_github">剑指 Offer 03. 数组中重复的数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原地交换</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）从0开始遍历到n-1</span></span><br><span class="line"><span class="comment">2）while 发现当前数字不等于当前下标</span></span><br><span class="line"><span class="comment">	再判断当前数字 是否与 以当前数字为下标的数字是否一样，是的话就是重复的数，直接返回；不是就替换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 29. 顺时针打印矩阵</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟、</span></span><br><span class="line"><span class="comment">//先设定边界，再遍历边界并判断边界是否超出</span></span><br><span class="line"><span class="comment">//T:O(mn) S:O(mn)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）设定边界l=0,r=arr[0].length-1,t=0,b=arr.length-1;</span></span><br><span class="line"><span class="comment">2）遍历边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] arr) &#123;</span><br><span class="line">      	ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=arr[<span class="number">0</span>].length-<span class="number">1</span>,t=<span class="number">0</span>,b=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)    res.add(arr[t][i]);   <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=b;i++)    res.add(arr[i][r]);   <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--)    res.add(arr[b][i]);   <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&gt;=t;i--)    res.add(arr[i][l]);   <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改进版：先顺时针再逆时针打印"><a href="#改进版：先顺时针再逆时针打印" class="headerlink" title="改进版：先顺时针再逆时针打印"></a>改进版：先顺时针再逆时针打印</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">node</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.x - b.x != <span class="number">0</span>) <span class="keyword">return</span> a.x - b.x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> a.y - b.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(s,<span class="number">0</span>,n,<span class="keyword">new</span> cmp());  对s数组排序</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="comment">//T:O(NlogN) ，最差为 O(N^2) 	S:O(N)</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">自定义排序</span></span><br><span class="line"><span class="comment">a+b 或者 b+a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];							<span class="comment">//存储成字符串数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">      </span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x)); <span class="comment">//x+y &gt;y+x，则x&gt;y,x放后面</span></span><br><span class="line">      <span class="comment">//Arrays.sort(Integernum, (a, b)-&gt;b - a); 降序</span></span><br><span class="line">       <span class="comment">//quickSort(strs, 0, strs.length - 1);            //排序</span></span><br><span class="line">      </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();							<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    		String tmp = strs[l];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//j + l &gt; l + j，说明j&gt;l</span></span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">//先翻转每个单词，再翻转整个字符串。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt;= n) &#123;<span class="comment">//⚠️</span></span><br><span class="line">            <span class="keyword">if</span> (end == n || chars[end] == <span class="string">&#x27; &#x27;</span>) &#123;	<span class="comment">//j遇到空格或者结尾</span></span><br><span class="line">                reverse(chars, start, end- <span class="number">1</span>);		<span class="comment">//翻转[start,end-1]</span></span><br><span class="line">                start = end + <span class="number">1</span>;  <span class="comment">//更新i</span></span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            swap(c, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="58-2左旋转字符串"><a href="#58-2左旋转字符串" class="headerlink" title="58.2左旋转字符串"></a><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">58.2左旋转字符串</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先将 &quot;abc&quot; 和 &quot;XYZdef&quot; 分别翻转，得到 &quot;cbafedZYX&quot;，然后再把整个字符串翻转得到 &quot;XYZdefabc&quot;。*/</span></span><br><span class="line"><span class="comment">//去重；先翻转前半部分，再翻转后半部分；最后整体翻转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">int</span> k = n%str.length();<span class="comment">//去重</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    reverse(chars, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, k, chars.length - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars); <span class="comment">//String.valueOf(chars);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(chars, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220404204345098.png" alt="image-20220404204345098"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表格分区</span></span><br><span class="line"><span class="comment">//T:O(N)	S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先计算下三角</span></span><br><span class="line"><span class="comment">计算上三角</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;    <span class="comment">//先计算下三角</span></span><br><span class="line">            tmp *= a[i-<span class="number">1</span>];</span><br><span class="line">          	b[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//先计算上三角 ⚠️从倒数第二行开始</span></span><br><span class="line">            tmp *= a[i+<span class="number">1</span>];  <span class="comment">//i+1最后一列开始</span></span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N)	S：O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">去除空格</span></span><br><span class="line"><span class="comment">符号处理</span></span><br><span class="line"><span class="comment">循环</span></span><br><span class="line"><span class="comment">	非字符处理</span></span><br><span class="line"><span class="comment">	越界处理</span></span><br><span class="line"><span class="comment">	结果计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = str.trim().toCharArray();    <span class="comment">//1.去除首尾空格</span></span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>; <span class="comment">//2.符号处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] &lt; <span class="string">&#x27;0&#x27;</span> || c[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//3.非字符处理</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;  <span class="comment">//4.越界处理：最大值与最小值处理</span></span><br><span class="line">            res = res * <span class="number">10</span> + (c[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-栈和队列"><a href="#7-2-栈和队列" class="headerlink" title="7.2 栈和队列"></a>7.2 栈和队列</h3><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 06. 从尾到头打印链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用栈</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*1.递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.addAll(printListFromTailToHead(listNode.next));<span class="comment">//⚠️</span></span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.栈*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode tmp= head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;   <span class="comment">//进栈</span></span><br><span class="line">            stack.push(tmp);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;    <span class="comment">//出栈</span></span><br><span class="line">            res[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2个栈</span></span><br><span class="line"><span class="comment">//栈1：进  栈2：删除(当第2个栈不为空时直接删除，为空时，将第一个栈的所有元素添加到栈2，再删除)</span></span><br><span class="line"><span class="comment">//T:O(1) S:O(N)</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;	<span class="comment">//不为空，直接删除</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;					<span class="comment">//栈2为空，⚠️将栈1的所有元素添加到栈2，再删除</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.isEmpty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 30. 包含min函数的栈</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助栈：存储非严格递减的序列，min就是栈顶</span></span><br><span class="line"><span class="comment">//T:O(1) S:O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();<span class="comment">//最小栈维护最小值  </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || stack2.peek() &gt;= x) <span class="comment">//为空或者栈顶大于等于x，⚠️非严格递减，一定要&gt;=</span></span><br><span class="line">            stack2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;	<span class="comment">//⚠️ 栈1弹出的是跟栈2栈顶一样，栈2才弹出</span></span><br><span class="line">        <span class="keyword">if</span>(stack1.pop().equals(stack2.peek())) stack2.pop();</span><br><span class="line">      <span class="comment">//防止栈1弹出的不是最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 31. 栈的压入、弹出序列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟:T:O(N) S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）不断进栈</span></span><br><span class="line"><span class="comment">2）然后循环判断栈顶是否与与出栈序列相同，是的话，出栈</span></span><br><span class="line"><span class="comment">3）直到栈为空，则是符合的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);  <span class="comment">//进栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;   <span class="comment">//循环判断并出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210630225352435.png" alt="image-20210630225352435"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(k)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">先用堆维护一个窗口（并把第一个堆顶加入结果）</span></span><br><span class="line"><span class="comment">遍历数组（移动窗口）</span></span><br><span class="line"><span class="comment">	将第一个元素移除</span></span><br><span class="line"><span class="comment">	并把最后一个元素添加进去</span></span><br><span class="line"><span class="comment">	把堆顶加入结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>)	<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  <span class="comment">/* 大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heap.add(num[i]);</span><br><span class="line">    ret.add(heap.peek());	<span class="comment">//第1个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + size; j &lt; num.length; i++, j++) &#123;            <span class="comment">/* heap维护一个大小为 size 的大顶堆 */</span></span><br><span class="line">        heap.remove(num[i]);</span><br><span class="line">        heap.add(num[j]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）A是原始序列；B维护单调递减序列（链头是最大值）</span></span><br><span class="line"><span class="comment">2）插入：一直判断链尾是否 &lt; 当前 x，不是则删除；没有了，则将当前x插入A，B</span></span><br><span class="line"><span class="comment">3）删除：删除A；先判断删除的值是否与B的最大值（链头）相同，是的话，才删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!B.isEmpty() &amp;&amp; B.peekLast() &lt; x) &#123;  <span class="comment">//将B中所有小于x，全部删除，严格递减</span></span><br><span class="line">            B.removeLast(); <span class="comment">//removeLast()返回空，pollLast()返回boolean，</span></span><br><span class="line">        &#125;</span><br><span class="line">        B.addLast(x);     <span class="comment">//插入到B后面</span></span><br><span class="line">        A.addLast(x);     <span class="comment">//插入到A后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = A.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (ans == B.peekFirst()) &#123;</span><br><span class="line">            B.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 41. 数据流中的中位数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="comment">//查找 T:O(1) 插入O(logn) ； S：O(n)</span></span><br><span class="line"><span class="comment">//优先队列,堆</span></span><br><span class="line"><span class="comment">//如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）2个堆，大顶堆，小顶堆</span></span><br><span class="line"><span class="comment">2）插入元素，当前为偶数个则插入右边（小顶堆，插入前先插入到左边，因为不知道插入的数字是多大）；奇数，插入左边（同理先插入右边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">             * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span></span><br><span class="line"><span class="comment">             * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-2字符流中第一个不重复的字符"><a href="#41-2字符流中第一个不重复的字符" class="headerlink" title="41.2字符流中第一个不重复的字符"></a><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">41.2字符流中第一个不重复的字符</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1）使用队列来存储到达的字符，记录次数</span></span><br><span class="line"><span class="comment">2）移除队列头部那些出现次数不再是一次的元素。</span></span><br><span class="line"><span class="comment">因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        cnts[ch]++;</span><br><span class="line">        queue.add(ch);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; <span class="number">1</span>)</span><br><span class="line">            queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? <span class="string">&#x27;#&#x27;</span> : queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-哈希表"><a href="#7-3-哈希表" class="headerlink" title="7.3 哈希表"></a>7.3 哈希表</h3><h4 id="剑指-Offer-50-第一个只出现一次的字符-⚠️"><a href="#剑指-Offer-50-第一个只出现一次的字符-⚠️" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符 ⚠️"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a> ⚠️</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序哈希表</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1）先存储每个字符的次数</span></span><br><span class="line"><span class="comment">2）再遍历一遍，次数为1的就是</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">      cnts[str.charAt(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">      <span class="keyword">if</span> (cnts[str.charAt(i)] == <span class="number">1</span>)	<span class="comment">//传的是str.charAt(i)</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最优</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    BitSet bs1 = <span class="keyword">new</span> BitSet(<span class="number">128</span>);</span><br><span class="line">    BitSet bs2 = <span class="keyword">new</span> BitSet(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs1.set(c);     <span class="comment">// bs1存在  bs2不存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs2.set(c);     <span class="comment">// 存在2次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c)) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/df03847e2d04a3fcb5649541d4b6733fb2cb0d9293c3433823e04935826c33ef-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N)	S:O(N)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">遍历数组</span></span><br><span class="line"><span class="comment">	跳过大小王</span></span><br><span class="line"><span class="comment">	保存最大值，最小值</span></span><br><span class="line"><span class="comment">	重复，直接返回false</span></span><br><span class="line"><span class="comment">	否则存入哈希</span></span><br><span class="line"><span class="comment">最大值-最小值 &lt; 5  5-1&lt;=4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过大小王</span></span><br><span class="line">            max = Math.max(max, num); <span class="comment">// 最大牌</span></span><br><span class="line">            min = Math.min(min, num); <span class="comment">// 最小牌</span></span><br><span class="line">            <span class="keyword">if</span>(repeat.contains(num)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num); <span class="comment">// 添加此牌至 Set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-链表"><a href="#7-4-链表" class="headerlink" title="7.4 链表"></a>7.4 链表</h3><h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(1) </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2,因此该算法的平均时间复杂度为 O(1)。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）先判断删除的是不是头结点</span></span><br><span class="line"><span class="comment">2）不是的，找到删除的结点</span></span><br><span class="line"><span class="comment">3）找到了，将其删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;   <span class="comment">//删除的是头结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;   <span class="comment">//2个指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) pre.next = cur.next;    <span class="comment">//如果找到了，将当前结点删除</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-2删除链表中重复的结点"><a href="#18-2删除链表中重复的结点" class="headerlink" title="18.2删除链表中重复的结点"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">18.2删除链表中重复的结点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当前指针和头指针是否相同，是相同删除，直到不同，递归；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode cur =pHead.next;</span><br><span class="line">        <span class="keyword">if</span> (pHead.val == cur.val) &#123;    <span class="comment">//相同</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; pHead.val == cur.val)    <span class="comment">//⚠️直到不相同为止</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pHead.next = deleteDuplication(pre.next); </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 24. 反转链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);	<span class="comment">//新建1个头结点 </span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next; <span class="comment">//保存下一个结点</span></span><br><span class="line">        head.next = newList.next;</span><br><span class="line">        newList.next = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-35-复杂链表的复制💣"><a href="#剑指-Offer-35-复杂链表的复制💣" class="headerlink" title="剑指 Offer 35. 复杂链表的复制💣"></a><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 35. 复杂链表的复制</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20220227133912093.png" alt="image-20220227133912093"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 插入新节点</span></span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立 random 链接</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = cur.next;	<span class="comment">//clone</span></span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">                clone.random = cur.random.next; <span class="comment">//clone-&gt;cur</span></span><br><span class="line">          </span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （跳1个）拆分</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next; <span class="comment">//1 -&gt;2;1&#x27;-&gt;2&#x27;,2-&gt;3,2&#x27;-&gt;3&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode tmp = cur.next;    <span class="comment">//⚠️中间临时结点tmp</span></span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针  完美偶遇</span></span><br><span class="line"><span class="comment">// T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  	 <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1,node2 =pHead2;</span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="keyword">null</span> ? node1.next:pHead2;<span class="comment">//循环遍历1，到null时，变为head2</span></span><br><span class="line">            node2 = node2 != <span class="keyword">null</span> ? node2.next:pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;<span class="comment">//返回node2也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-位运算"><a href="#7-5-位运算" class="headerlink" title="7.5 位运算"></a>7.5 位运算</h3><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(M):M二进制1的个数 S：O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= （n - <span class="number">1</span>）; <span class="comment">//去除最高位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-I-数组中数字出现的次数💣"><a href="#剑指-Offer-56-I-数组中数字出现的次数💣" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数💣"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a>💣</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/1614836837-oygHyk-Picture2.png" alt="Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组异或：(2,1,3,2)     其他出现2次，找2个出现1次</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//全员异或后得到这个只出现一次的数（本题需要找到2个）</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">//结果,0与任何数异或还是自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//找到ret第一位不是0的 是1</span></span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;	<span class="comment">//判断该位是否为0进行分组 （2，1，2）=&gt;1</span></span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//(3)</span></span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830112644359.png" alt="image-20210830112644359"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。</span></span><br><span class="line"><span class="comment">//因此，统计所有数字的各二进制位中 1 的出现次数，并对3求余，结果则为只出现一次的数字。</span></span><br><span class="line"><span class="comment">//其他3次，找1个   (1,0,1,1)</span></span><br><span class="line"><span class="comment">//有限状态自动机 T:O(n)  S:O(1)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;	<span class="comment">//二进制数的2个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算：x ^ 0 = x， x ^ 1 = ~x</span></span><br><span class="line"><span class="comment">// 与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件与 &amp;&amp; 具有短路原则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">boolean</span> b = (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3+4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">011</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> (a &amp; b) &lt;&lt;  1</span></span><br><span class="line"><span class="comment">^= 111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// &amp;取最高位，c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和 </span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-排序"><a href="#7-6-排序" class="headerlink" title="7.6 排序"></a>7.6 排序</h3><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">剑指 Offer 40. 最小的k个数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210912114146128.png" alt="image-20210912114146128"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排  T：O(n) S:O(1)</span></span><br><span class="line"><span class="comment">//快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//⚠️ 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt;  <span class="title">quickSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) ret.add(nums[i]);<span class="comment">//0到k</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];	<span class="comment">//基准</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;	<span class="comment">//j为什么+1？</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);	<span class="comment">//注意先++</span></span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大根堆  T:O(nlog⁡k) S:O(k), n为数组的长度，k为大根堆里最多k个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123; <span class="comment">// 排除 0 的情况</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1, Integer num2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num2 - num1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;   <span class="comment">//首先插入k个数</span></span><br><span class="line">            queue.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; ++i) &#123;<span class="comment">//维护前k个数</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peek() &gt; arr[i]) &#123;    <span class="comment">//比堆顶小，插入</span></span><br><span class="line">                queue.poll();           <span class="comment">//堆顶弹出</span></span><br><span class="line">                queue.offer(arr[i]);    <span class="comment">//插入当前数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;   <span class="comment">//将堆的数据赋值给res</span></span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-45-把数组排成最小的数-1"><a href="#剑指-Offer-45-把数组排成最小的数-1" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(NlogN),S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a));<span class="comment">//排序</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（8）数学"><a href="#（8）数学" class="headerlink" title="（8）数学"></a>（8）数学</h2><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摩尔投票法</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,votes=<span class="number">0</span>;		<span class="comment">// 票数统计 votes = 0 ， 众数 x  众数是指一组数据中出现次数最多的那个数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字-约瑟环"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-约瑟环" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> 约瑟环</h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162901260.png" alt="image-20210813162901260"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210813162843069.png" alt="image-20210813162843069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)     <span class="comment">/* 递归返回条件 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160011746.png" alt="image-20220119160011746"></p>
<p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/zczBlog/source/_posts/8.%E5%9F%BA%E7%A1%80/image-20220119160104838.png" alt="image-20220119160104838"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T：O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">当 cur = 0 时:此位 1 的出现次数:high×digit</span></span><br><span class="line"><span class="comment">当 cur = 1 时:high×digit+low+1</span></span><br><span class="line"><span class="comment">当 cur &gt; 1 时： (high+1)×digit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>, res = <span class="number">0</span>;<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;<span class="comment">//当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            low += cur * digit;      <span class="comment">//将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">            cur = high % <span class="number">10</span>;        </span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p><img src="/2021/01/02/1.1Java%E5%88%B7%E9%A2%98/image-20210830173325392.png" alt="image-20210830173325392"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;	<span class="comment">//位数digit</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;		<span class="comment">//数位数量count</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.计算n所在的数位数量count  </span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;	<span class="comment">//（n:11  n=2 count=180 start=10 digit=2 num=10 ）</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.计算n所在的数字num </span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.确定 n 是num 中的哪一数位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TOT100"><a href="#TOT100" class="headerlink" title="TOT100"></a><a href="https://leetcode-cn.com/problem-list/2cktkvj/">TOT100</a></h2><h2 id="HOP150"><a href="#HOP150" class="headerlink" title="HOP150"></a><a href="https://leetcode-cn.com/problem-list/2ckc81c/">HOP150</a></h2>]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.3JVM</title>
    <url>/2021/01/02/1.3JVM/</url>
    <content><![CDATA[<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>这边的全称是叫 Java 虚拟机。有2个作用：第一个，运行并管理 Java 源码文件所生成的 class 文件。第二个，在不同的操作系统上安装不同的 jvm 从而去实现跨平台的一个保障。一般情况下，对于开发者而言，即使不熟悉 jvm 的运行机制，也不影响业务代码的一个开发。因为在安装完 gdk 或者 jre 之后，其中就已经内置了 jvm 所以只需要将 class 文件交给 jvm 运行就可以了。但当程序运行的过程中出现的问题，而这个问题发生在 jvm 层面的时候，我们就需要去熟悉 jvm 的运行机制，才能够去迅速排查并解决 jvm 的新的问题。</p>
<span id="more"></span>

<p><img src="/2021/01/02/1.3JVM/image-20220418194052664.png" alt="image-20220418194052664"></p>
<p>这个图是 jvm hotspot 的一个架构图，它也是现在主流的一个java虚拟机。通过这个图中我们可以看出 jvm 的大致流程，它把一个 class 文件通过类加载机制装载到 jvm 里面，然后放到不同的运行时数据区，通过编译器来编译。<br>第一个部分， class files 在 Java 中 class 文件是由源码文件构成的。至于源码文件的内容，是每一个 Java 开发者在 Java SE 的阶段必备的知识，这里就不做过多的一个赘述。我们可以关注一下 class 文件的格式，比如说其中的常量池、成员变量方法等等，这样就能够知道java源码内容在 class 文件中的表示方式。<br>第二个部分是 classloader subsystem 也就是类加载机制。 class 文件加载到内存中需要接触 Java 中的类加载机制分为装载，链接和初始化，它主要就是对类进行查找、验证以及分配对相关内存空间和赋值。<br>第三个部分，runtime data area 也就是我们通常所说的运行时数据区，它解决的问题是 class 文件进入到内存之后该如何进行存储不同的数据以及数据该如何进行流转？比如 method area 通常会存储由 class 文件常量池所对应的运行时常量池，字段和方法的元数据信息、类的模板信息等等。Heap是存储各种 Java 中的对象实例， Java threads 通过线程以栈的方式去运行加载各个方法。 native interface 可以理解为是加载运行 native 类型的方法。 PC Registers 则是保存每个线程执行方法的实时地址。这样通过运行时数据区的五个部分就能很好地去把数据存储和运行起来。<br>第四个部分就是我们的垃圾回收器就是对运行的数据池中的数据进行管理和回收。回收机制可以基于不同的垃圾收集器，比如说 serial， parallel，CMS，GI，ZGC 等等，可以针对不同业务场景去选择不同的收集器，只需要通过 jvm 参数设置即可。如果我们去打开 hotspot 的一个源码，可以发现这些收集器其实就是对于不同垃圾收集算法的实现。核心的算法有三个，第一个是复制，第二个是标记清除，第三个是标记整理。<br>第五个部分是 JIT compiler 和 interpreter 通俗的理解就是编译器。 class 的字节码指令通过  JIT compiler 和 interpreter 翻译成对应操作系统的 CPU 指令。只不过可以选择解释执行或者编译执行。在 hotspot 虚拟机中默认采用的是这两种方式的组合。<br>第六种是 JNI 的技术。如果我们想去找到 Java 中的某个 native 方法，如何通过 C 或者 C++实现的，那么可以通过 native method 的 interface 来去进行查找。也就是我们所谓的 JNI 技术。通过官网给出的 hotspot 架构图，我们就能够知道 jvm 的底层是如何运行的？当然在实际的操作过程中，我们可以去借助一些 jvm 参数和一些常见的 JDK 常见命令。我们就可以去优雅地分析 JVM 出现的常见问题，并对其进行优雅的调优。</p>
<h2 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h2><blockquote>
<p>JVM =&gt; 操作系统 =&gt;硬件</p>
</blockquote>
<p><img src="/2021/01/02/1.3JVM/image-20220331095358052.png" alt="image-20220331095358052"></p>
<p>类加载器：</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>1.方法区（线程共享）：</p>
<ul>
<li>线程共享区域，因此这是线程不安全的区域。</li>
<li>它用于存储已被<strong>虚拟机加载的类信息、常量、静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</li>
<li>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</li>
</ul>
<p>2.堆区（线程共享，JVM调优）：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p>
<p>Java堆区具有下面几个特点：</p>
<ul>
<li><p>线程共享区域，因此是<strong>线程不安全</strong>的。</p>
</li>
<li><p>存储的是我们new来的对象，<strong>不存放基本类型和对象引用</strong>。</p>
</li>
<li><p>能够发生<strong>OutOfMemoryError</strong>。</p>
</li>
</ul>
<p>其实，Java堆区还可以划分为<strong>新生代和老年代</strong>，新生代又可以进一步划分为Eden区、Survivor 1区、Survivor 2区。</p>
<p>3.虚拟机栈区：</p>
<ul>
<li><strong>线程私有</strong>，它的生命周期与线程相同</li>
<li>每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息（存放基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象的引用）</li>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError异常</strong>；如果虚拟机栈可以动态扩，当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError异常</strong>。</li>
</ul>
<p>4.本地方法栈：</p>
<p>与虚拟机栈类似。其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>
<p>5.程序计数器：</p>
<p>记录当前线程所执行的位置。 这样，当线程重新获得CPU的执行权的时候，就直接从记录的位置开始执行，分支、循环、跳转、异常处理也都依赖这个程序计数器来完成。</p>
<p>6.执行引擎：</p>
<p>7.JNI：扩展java的使用，融合不同的编程语言为Java所用</p>
<blockquote>
<p>Java早期，C，C++主流，想要立足，必须调用C，C++的程序<br>它在内存中专门开启开辟一块标记区域：本地方法栈，登记native方法<br>在最终执行的时候，通过JNI加载本地方法库的方法。</p>
</blockquote>
<p>8.本地方法库：</p>
<h3 id="Java类与对象"><a href="#Java类与对象" class="headerlink" title="Java类与对象"></a>Java类与对象</h3><h3 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM( Java内存模型)"></a>JMM( Java内存模型)</h3><p>1.<strong>概念</strong></p>
<p>Java内存模型</p>
<p>Java内存模型的三大特性：原子性、可见性、有序性</p>
<p>2.<strong>干嘛</strong></p>
<p><img src="/2021/01/02/1.3JVM/image-20220331205403615.png" alt="image-20220331205403615"></p>
<p>3.<strong>怎么用</strong></p>
<p>规则</p>
<p><img src="/2021/01/02/1.3JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81Mzk0NjYzMA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/2021/01/02/1.3JVM/640-8695219.png" alt="图片"></p>
<p><img src="/2021/01/02/1.3JVM/image-20220331102213547.png" alt="image-20220331102213547"></p>
<blockquote>
<p>类是模板，实例是具体的。<br>实例的地址在栈区（值引用），具体数据在堆区。</p>
</blockquote>
<h3 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h3><p>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 </p>
<p>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。 </p>
<p>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和 class类。 </p>
<p>AppClassLoader是<strong>自定义类加载器的父类</strong>，负责加载classpath下的类文件。是系统类加载器，还是线程上下文加载器 </p>
<p>继承ClassLoader实现<strong>自定义类加载器</strong></p>
<h3 id="双亲委托模型-⭐️"><a href="#双亲委托模型-⭐️" class="headerlink" title="双亲委托模型 ⭐️"></a><strong>双亲委托模型</strong> ⭐️</h3><p><img src="/2021/01/02/1.3JVM/image-20220211144544569.png" alt="image-20220211144544569">   </p>
<p>双亲委派模型的好处： </p>
<ul>
<li>主要是为了<strong>安全性</strong>，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。 （自定义Java开头的类不会加载）</li>
<li>同时也<strong>避免了类的重复加载</strong>，因为 JVM中区分不同类，不仅仅是根据类名，<strong>相同的 class文件被不同的 ClassLoader加载就是不同的两个类</strong> </li>
</ul>
<blockquote>
<p>要是向下查找到AppCLassLoader还是没有，会报没有找到类</p>
</blockquote>
<h5 id="能不能自己写个类，也叫java-lang-String？"><a href="#能不能自己写个类，也叫java-lang-String？" class="headerlink" title="能不能自己写个类，也叫java.lang.String？"></a>能不能自己写个类，也叫java.lang.String？</h5><p><strong>可以，但是即使你写了这个类，也没有用。</strong>这个问题涉及到加载器的委托机制，在类加载器的结构图（在下面）中，BootStrap是顶层父类，ExtClassLoader是BootStrap类的子类，ExtClassLoader又是AppClassLoader的父类这里以java.lang.String为例，当我是使用到这个类时，Java虚拟机会将java.lang.String类的字节码加载到内存中。</p>
<p><strong>为什么只加载系统通过的java.lang.String类而不加载用户自定义的java.lang.String类呢？</strong></p>
<p>因加载某个类时，优先使用父类加载器加载需要使用的类。如果我们自定义了java.lang.String这个类，加载该自定义的String类，该自定义String类使用的加载器是AppClassLoader，根据优先使用父类加载器原理，AppClassLoader加载器的父类为ExtClassLoader，所以这时加载String使用的类加器是ExtClassLoader，<br>但是类加载器ExtClassLoader在jre/lib/ext目录下没有找到String.class类。然后使用ExtClassLoader父类的加载器BootStrap，父类加载器BootStrap在JRE/lib目录的rt.jar找到了String.class，将其加载到内存中。这就是类加载器的委托机制。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="JVM堆内存"><a href="#JVM堆内存" class="headerlink" title="JVM堆内存"></a>JVM堆内存</h3><h4 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h4><p>一个JVM只有一个堆内存</p>
<p><img src="/2021/01/02/1.3JVM/image-20220331152942432.png" alt="image-20220331152942432"></p>
<blockquote>
<p>幸存0区，幸存1区会动态交换</p>
</blockquote>
<p><strong>永久区</strong>（不存在垃圾回收）</p>
<blockquote>
<p>方法区和永久代的关系很像Java中接口和类的关系</p>
</blockquote>
<p><img src="/2021/01/02/1.3JVM/image-20220331154042600.png" alt="image-20220331154042600"></p>
<blockquote>
<p>永久代是在JVM分配的内存中，本身是设置好的固定大小上限，无法改变，所以溢出的可能性比较大。Java8开始把这一部分（永久区）移到了本机内存，也就是元空间的大小只受本机内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<p>逻辑上存在，物理上不存在（JVM内存 = 新生代+老年代，不包括元空间）</p>
</blockquote>
<h4 id="GC类型"><a href="#GC类型" class="headerlink" title="GC类型"></a>GC类型</h4><ul>
<li>Minor GC/Young GC：针对<strong>新生代</strong>的垃圾收集；</li>
<li>Major GC/Old GC：针对<strong>老年代</strong>的垃圾收集。</li>
<li>Full GC：针对整个<strong>Java堆以及方法区</strong>的垃圾收集。</li>
</ul>
<h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>通常情况下，初次被创建的对象存放在新生代的Eden区，当第一次触发Minor GC(当Eden区满了)，Eden区存活的对象被转移到Survivor区的某一块区域。以后再次触发Minor GC的时候，Eden区的对象连同一块Survivor区的对象一起，被转移到了另一块Survivor区。可以看到，这两块Survivor区我们每一次只使用其中的一块，这样也仅仅是浪费了一块Survivor区。</p>
<ul>
<li>死亡</li>
<li>进入幸存区</li>
<li>达到15次GC后，进入养老区</li>
</ul>
<p><img src="/2021/01/02/1.3JVM/640-20220331153318930.png" alt="图片"></p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>老年代是存储长期存活的对象的，<strong>养老区占满</strong>时就会触发我们最常听说的Full GC，期间<strong>会停止所有线程，直到GC的完成</strong>。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p>
<h4 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h4><p>内存抖动:指在短时间内有大量的对象被创建或者被回收的现象。</p>
<p>内存抖动产生<strong>原因</strong>:主要是频繁(很重要)在循环里创建对象(导致大量对象在短时间内被创建；</p>
<p>频繁内存抖动会导致垃圾回收频繁运行,造成系统卡顿。</p>
<h3 id="GC如何判断对象可以被回收⭐️"><a href="#GC如何判断对象可以被回收⭐️" class="headerlink" title="GC如何判断对象可以被回收⭐️"></a>GC如何判断对象可以被回收⭐️</h3><p>（1）引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收， </p>
<p>（2）可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。 </p>
<p> GC Roots =&gt; A =&gt; B，A，B不能回收</p>
<blockquote>
<p>引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 ，计数器=1 永远无法被回收。</p>
</blockquote>
<p>GC Roots的对象有： </p>
<ul>
<li><p>方法区中类静态属性引用的对象 ，常量引用的对象 </p>
</li>
<li><p>虚拟机栈(栈帧中的本地变量表）中引用的对象 ,add(){new user}</p>
</li>
<li><p><strong>本地方法栈中</strong>JNI(即一般说的Native方法)引用的对象</p>
</li>
</ul>
<p>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡<strong>至少要经历两次标记过程</strong>：第一次是经过可达性分析发现没有与<strong>GC Roots相连接的引用链</strong>，第二次是在由 虚拟机自动建立的<strong>Finalizer队列中判断是否需要执行finalize()方法</strong>。</p>
<blockquote>
<p>当对象变成(GC Roots)<strong>不可达时</strong>，GC会判断该对象是否覆盖了finalize方法，<strong>若未覆盖，则直接将其回收</strong>。否则，若对象未执行过finalize方法，将其<strong>放入F-Queue队列</strong>，由一<strong>低优先级线程</strong>执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会<strong>再次判断该对象是否可达</strong>，若不可达，则进行回收，否则，对象“复活” 。</p>
</blockquote>
<p>每个对象只能触发一次finalize()方法 </p>
<p>由于finalize()方法<strong>运行代价高昂，不确定性大，无法保证各个对象的调用顺序</strong>，不推荐大家使用，建议遗忘它。`</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><blockquote>
<p>优点：没有内存碎片。优化了标记/清除算法的效率低、内存碎片多，假设对象100%存活（极端）</p>
<p>缺点：浪费了一半的内存空间，代价太高</p>
<p>场景：对象存活度较低；新生区～</p>
</blockquote>
<p><img src="/2021/01/02/1.3JVM/image-20220331163523705.png" alt="image-20220331163523705"></p>
<p><img src="/2021/01/02/1.3JVM/image-20220331164110027.png" alt="image-20220331164110027"></p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><blockquote>
<p>优点：不需要额外空间</p>
<p>缺点：2次扫描，浪费时间；会产生内存碎片</p>
</blockquote>
<p><img src="/2021/01/02/1.3JVM/image-20220331202940107.png" alt="image-20220331202940107"></p>
<h4 id="标记（清除）整理"><a href="#标记（清除）整理" class="headerlink" title="标记（清除）整理"></a>标记（清除）整理</h4><p><img src="/2021/01/02/1.3JVM/image-20220331203159832.png" alt="image-20220331203159832"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内存效率：复制算法&gt;标记清除&gt;标记整理</p>
<p>内存整齐度：复制算法=标记整理&gt;标记清除</p>
<p>内存利用率：标记整理 = 标记清除 &gt; 复制算法</p>
<blockquote>
<p>没有最好的算法，只有最合适的算法</p>
</blockquote>
<p>GC：分代收集算法</p>
<p>新生代：复制算法</p>
<p>老年代：标记整理（标记清除几次，再一次整理）</p>
<h3 id="7种垃圾收集器"><a href="#7种垃圾收集器" class="headerlink" title="7种垃圾收集器"></a>7种垃圾收集器</h3><h4 id="（1）Serial收集器"><a href="#（1）Serial收集器" class="headerlink" title="（1）Serial收集器"></a>（1）Serial收集器</h4><p>Serial收集器是最基础、历史最悠久的收集器，是一个单线程工作的收集器，使用 Serial收集器，无论是进行 Minor gc 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331211858226.png" alt="图片"></p>
<h4 id="（2）ParNew收集器"><a href="#（2）ParNew收集器" class="headerlink" title="（2）ParNew收集器"></a>（2）ParNew收集器</h4><p>ParNew  收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial  收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331211858184.png" alt="图片"></p>
<h4 id="（3）Parallel-Scavenge收集器"><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款新生代收集器，基于标记——复制算法实现，能够并行收集的多线程收集器和 ParNew 非常相似。</p>
<p>Parallel  Scavenge  收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<blockquote>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX：MaxGCPauseMillis 参数和直接设置吞吐量大小的**-XX：GCTimeRatio** 参数。</p>
</blockquote>
<h4 id="（4）Serial-Old收集器"><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLH1sibhR8TTTyfnDtlcUfyyVPbYKIfzXN2A3h5trdoVBLxqdxBzjxmqIkibMQYXRGQn1qzbxNVeXPuw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="（5）Parallel-Old收集器"><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331211858439.png" alt="图片"></p>
<h4 id="（6）CMS收集器"><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h4><p>CMS 收集器设计的初衷是为了消除 Parallel 收集器和 Serial 收集器 Full gc 周期中的长时间停顿。CMS收集器在 Minor gc 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331211858231.png" alt="图片"></p>
<h4 id="（7）Garbage-First收集器（G1）"><a href="#（7）Garbage-First收集器（G1）" class="headerlink" title="（7）Garbage First收集器（G1）"></a>（7）Garbage First收集器（G1）</h4><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么为整个新生代（MinorGC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1垃圾收集器使用Mixed GC模式可以面向堆内存任何部分来组成回收集（Collection Set，一般简称为Cset）进行回收，衡量标准不再是它属于哪个年代，而是哪块内存中存放的垃圾数最多，回收收益最大。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331215404794.png" alt="图片"></p>
<h4 id="垃圾收集器对比"><a href="#垃圾收集器对比" class="headerlink" title="垃圾收集器对比"></a>垃圾收集器对比</h4><p><img src="/2021/01/02/1.3JVM/640-20220331201759663.png" alt="图片"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>新生代用“复制算法”，老年代基本用“标记-整理”算法，有的也用“标记-清除”算法（新生代因为有surive区域，所以肯定使用的“复制算法”，老年代不可能划分成2个区域，所以肯定不会使用“复制算法”）；</li>
<li>单线程垃圾回收器：Serial、Serial Old；</li>
<li>多线程垃圾回收器：ParNew、Parallel Old、Pararrel Scavenge和G1；</li>
<li>适用新生代的垃圾回收器：Serial、ParNew、Pararrel Scavenge和G1；</li>
<li>适用老年代的垃圾回收器：Serial Old、Parallel Old和G1。</li>
</ul>
<h4 id="G1与CMS的区别"><a href="#G1与CMS的区别" class="headerlink" title="G1与CMS的区别"></a>G1与CMS的区别</h4><h2 id="JDK监控和故障处理工具"><a href="#JDK监控和故障处理工具" class="headerlink" title="JDK监控和故障处理工具"></a>JDK监控和故障处理工具</h2><h4 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h4><p>从java5开始，在JDK中自带的java监控和管理控制台，<strong>用于对JVM中内存，线程和类等的监控</strong>。</p>
<p>概览：包括堆内存使用情况、线程、类、CPU使用情况四项信息的曲线图。</p>
<p><img src="/2021/01/02/1.3JVM/640-20220331174309743.png" alt="图片"></p>
<p>线程：相当于可视化的jstack命令，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。</p>
<blockquote>
<p>jstack用于生成java虚拟机当前时刻的线程快照。<strong>线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合</strong>，生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间等待等。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。    </p>
</blockquote>
<p><img src="/2021/01/02/1.3JVM/640-20220331174309812.png" alt="图片"></p>
<h4 id="OOM异常怎么解决（Jprofiler）"><a href="#OOM异常怎么解决（Jprofiler）" class="headerlink" title="OOM异常怎么解决（Jprofiler）"></a>OOM异常怎么解决（Jprofiler）</h4><blockquote>
<p>JVM堆内存。默认情况：分配内存是电脑内存的1/4，初始内存是1/64</p>
</blockquote>
<p>1.手动扩大堆内存，查看结果</p>
<blockquote>
<p>-Xms1024m  初始内存是1/64</p>
<p>-Xmx1024m 分配最大内存默认是电脑内存的1/4</p>
<p>-XX:+PrintGCDetails</p>
<p>-XX:+PrintGCOnOutOfMemoryError</p>
</blockquote>
<p>2.分析heapDump文件，看下那个地方出现问题</p>
<p><img src="/2021/01/02/1.3JVM/image-20220331161816382.png" alt="image-20220331161816382"></p>
<p>1）查看最大对象</p>
<p><img src="/2021/01/02/1.3JVM/image-20220331161850413.png" alt="image-20220331161850413"></p>
<p>2）查看ThreadDump，查看哪一行代码有问题。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h4 id="选择合适的垃圾回收器"><a href="#选择合适的垃圾回收器" class="headerlink" title="选择合适的垃圾回收器"></a>选择合适的垃圾回收器</h4><ul>
<li>CPU单核，那么毫无疑问Serial 垃圾收集器是你唯一的选择。</li>
<li>CPU多核，关注吞吐量 ，那么选择PS+PO组合。</li>
<li>CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。</li>
<li>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。</li>
</ul>
<p>参数配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置Serial垃圾收集器（新生代）</span></span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMS垃圾收集器（老年代）</span></span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置G1垃圾收集器</span></span><br><span class="line">开启 -XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<h4 id="调整内存大小"><a href="#调整内存大小" class="headerlink" title="调整内存大小"></a>调整内存大小</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置堆初始值</span></span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置堆区最大值</span></span><br><span class="line">指令<span class="number">1</span>：-Xmx2g</span><br><span class="line"></span><br><span class="line"><span class="comment">//新生代内存配置</span></span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br></pre></td></tr></table></figure>

<p>设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NewSize：新生代大小</span><br><span class="line">-XX:NewRatio 新生代和老生代占比</span><br><span class="line">-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</span><br></pre></td></tr></table></figure>



<h2 id="JVM调试实战"><a href="#JVM调试实战" class="headerlink" title="JVM调试实战"></a>JVM调试实战</h2><h3 id="网站流量浏览量暴增后，网站反应页面响很慢"><a href="#网站流量浏览量暴增后，网站反应页面响很慢" class="headerlink" title="网站流量浏览量暴增后，网站反应页面响很慢"></a>网站流量浏览量暴增后，网站反应页面响很慢</h3><p>1、问题推测：在测试环境测速度比较快，但是一到生产就变慢，所以推测可能是因为垃圾收集导致的业务线程停顿。</p>
<p>2、定位：为了确认推测的正确性，在线上通过jstat -gc 指令 看到JVM进行GC 次数频率非常高，GC所占用的时间非常长，所以基本推断就是因为GC频率非常高，所以导致业务线程经常停顿，从而造成网页反应很慢。</p>
<p>3、解决方案：因为网页访问量很高，所以对象创建速度非常快，导致堆内存容易填满从而频繁GC，所以这里问题在于新生代内存太小，所以这里可以增加JVM内存就行了，所以初步从原来的2G内存增加到16G内存。</p>
<p>4、第二个问题：增加内存后的确平常的请求比较快了，但是又出现了另外一个问题，就是不定期的会间断性的卡顿，而且单次卡顿的时间要比之前要长很多。</p>
<p>5、问题推测：练习到是之前的优化加大了内存，所以推测可能是因为内存加大了，从而导致单次GC的时间变长从而导致间接性的卡顿。</p>
<p>6、定位：还是通过jstat -gc 指令 查看到 的确FGC次数并不是很高，但是花费在FGC上的时间是非常高的,根据GC日志 查看到单次FGC的时间有达到几十秒的。</p>
<p>7、解决方案： 因为JVM默认使用的是PS+PO的组合，PS+PO垃圾标记和收集阶段都是STW，所以内存加大了之后，需要进行垃圾回收的时间就变长了，所以这里要想避免单次GC时间过长，所以需要更换并发类的收集器，因为当前的JDK版本为1.7，所以最后选择CMS垃圾收集器，根据之前垃圾收集情况设置了一个预期的停顿的时间，上线后网站再也没有了卡顿问题。</p>
<h3 id="后台导出数据引发的OOM"><a href="#后台导出数据引发的OOM" class="headerlink" title="后台导出数据引发的OOM"></a>后台导出数据引发的OOM</h3><p><strong>问题描述：</strong>公司的后台系统，偶发性的引发OOM异常，堆内存溢出。</p>
<p>1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，所以单方面的加大了堆内存从4G调整到8G。</p>
<p>2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。</p>
<p>3、VisualVM  对   堆dump文件进行分析，通过VisualVM查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p>
<p>4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，发现有个引起我注意的方法，导出订单信息。</p>
<p>5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p>
<p>6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现到处订单的按钮前端居然没有做点击后按钮置灰交互事件，结果按钮可以一直点，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，结果就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p>
<p>7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击，然后减少了查询订单信息的非必要字段来减少生成对象的体积，然后问题就解决了。</p>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.4数据结构</title>
    <url>/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h5 id="B-树和红黑树"><a href="#B-树和红黑树" class="headerlink" title="B+树和红黑树"></a>B+树和红黑树</h5><p>​        <a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>和一般的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a>，增、删、改、查的过程和效率、时间复杂度      </p>
<p>​       <a href="https://www.cnblogs.com/ArleneZhangfj/articles/10067570.html">https://www.cnblogs.com/ArleneZhangfj/articles/10067570.html</a>      </p>
<p>md5哈希函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简述一下vector内存机制？（不够扩充两倍）</span><br><span class="line">map的实现？（红黑树）</span><br><span class="line">unondered_map的实现？（哈希）</span><br><span class="line">哈希碰撞了怎么办？</span><br><span class="line">（开放寻址法</span><br><span class="line">1.1. di=1,2,3，…，m-1，称线性探测再散列；</span><br><span class="line">1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；</span><br><span class="line">1.3. di=伪随机数序列，称伪随机探测再散列</span><br><span class="line">、再哈希、</span><br><span class="line">链式）</span><br></pre></td></tr></table></figure>

<p>哈希表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</span><br><span class="line">这个映射函数叫做散列函数，存放记录的数组叫做散列表</span><br></pre></td></tr></table></figure>

<p>哈希表和平衡二叉树的适用场合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希表：哈希表查找速度比较快，但是要耗比较多的内存。所以比较适用于对查找速度要求比较高、且内存空间足够的时候</span><br><span class="line">，数据元素之间无逻辑关系要求的情况。</span><br><span class="line">平衡二叉树：如果想在以后用二分法查找的时候查找速度比较快的话用建立平衡二叉树的方法（）</span><br></pre></td></tr></table></figure>

<p>树中节点查找过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（递进的方式简述每种树的概念和思想 二分查找 -&gt; 折半二叉树 -&gt; 平衡二叉树 -&gt; 红黑树 -&gt; B/B+树）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一致性哈希（环输出域）</span><br><span class="line">其中一个节点挂了怎么做（扔给下一个） </span><br><span class="line">如何实现负载均衡（每个机器无限多  id再hash）</span><br></pre></td></tr></table></figure>

<p>哈希表大小设置多少合理 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（和vector一样吧，动态调整大小）</span><br><span class="line"></span><br><span class="line">如果不考虑rehash怎么做（应该是质数，因为避免冲突，另外大小设置和输入数据有关，具体应该是查表，表是科学家实践得出的参考值）</span><br></pre></td></tr></table></figure>

<p>红黑树比平衡二叉树和好在哪儿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">牺牲部分平衡性，换来时间复杂度的优化</span><br></pre></td></tr></table></figure>

<p>空间时间互换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间换空间的典型应用是查表，比如我要你求出100以内所有的质数并输出，你可能会动态求出这些质数，</span><br><span class="line">但是更快的是先求出这些质数并存到一个数组里面，然后直接输出这个数组即可。这就是空间换时间。</span><br></pre></td></tr></table></figure>

<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="数组VS链表"><a href="#数组VS链表" class="headerlink" title="数组VS链表"></a>数组VS链表</h4><p>数组是一段连续的存储空间；链表不要求连续</p>
<p>数组支持随机访问，而链表不支持。</p>
<p>数组的大小固定，而链表则天然支持动态扩容。</p>
<p>需要经常添加和删除数据的话，使用链表比较合适。</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p><strong>栈和队列的区别</strong></p>
<p>队列：先进先出<br>栈：先进后出 </p>
<p>队列和栈的遍历数据速度<br>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快<br>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，遍历数据时需要微数据开辟临时空间，保持数据在遍历前的一致性</p>
<p><strong>应用场景</strong></p>
<p>逆序输出（将一个非负的十进制整数N转换成其他D进制数），括号匹配，迷宫求解，二叉树遍历，表达式求值</p>
<p>回文判断：利用队列和栈的特性，一个是先进先出，一个是先进后出，迷宫问题，广度优先遍历</p>
<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><h5 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h5><p>树转二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左孩子右兄弟</span><br><span class="line">//连接兄弟节点，砍掉非第一个左孩子，左旋45度</span><br></pre></td></tr></table></figure>

<p>二叉树转树（二叉树有右孩子则转换为森林）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y是x的双亲 则将x的右孩子,x的右右孩子...与y连接，</span><br><span class="line">砍掉兄弟的连接，以及双亲y的右孩子</span><br></pre></td></tr></table></figure>

<p>树 森林的遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">森林的先序遍历和中序遍历分别对应该树转换成的二叉树的先序遍历和中序遍历  森林无后序遍历的定</span><br><span class="line">树的先序遍历和后序遍历分别对应该树转换成的二叉树的先序遍历和中序遍历    树没有中序遍历的定义。</span><br></pre></td></tr></table></figure>



<h5 id="2-二叉树基本概念"><a href="#2-二叉树基本概念" class="headerlink" title="2.二叉树基本概念"></a>2.二叉树基本概念</h5><h5 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3.二叉查找树"></a>3.二叉查找树</h5><h5 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4.平衡二叉树"></a>4.平衡二叉树</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5.红黑树"></a>5.红黑树</h5><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前序，中序，后序都可以看作是DFS，用栈实现，因为他们都是在找到叶子节点前一直遍历。 </span><br><span class="line">层序遍历属于BFS，用堆实现，因为它们是一层一层遍历。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.nowcoder.com/discuss/346845?order=0&amp;page=1&amp;pos=6&amp;type=0</span><br><span class="line">面试常见智力题和概率题目及部分答案</span><br><span class="line"></span><br><span class="line">1.在一个公交车站等公交车，等一分钟等到车的概率为p，那么等三分钟等到车的概率是多少（p+(1-p)p+(1-p)(1-p)p，典型的二分概率）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不论哈希表中数据有多少，增加，删除，改写数据的复杂度平均都是O(1)，效率非常高</span><br><span class="line">哈希表原理:根据关键码值(Key value)而直接进行访问的数据结构。</span><br><span class="line"></span><br><span class="line">解决哈希冲突</span><br><span class="line">1.开放定址法</span><br><span class="line">    线性探测再散列		缺点：集聚</span><br><span class="line">    二次探测再散列</span><br><span class="line">    伪随机探测再散列</span><br><span class="line"></span><br><span class="line">2.再哈希法</span><br><span class="line"></span><br><span class="line">3.链地址法</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/hunternet/p/11324945.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">STL中hash_map扩容发生什么？</span><br><span class="line">(1) 创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除2到sqrt(n)sqrt(n)范围内的数) ；</span><br><span class="line">(2) 将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)</span><br><span class="line">(3) 通过swap函数将新桶和旧桶交换，销毁新</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/tong-yuan/p/Heap.html</span><br><span class="line">https://blog.csdn.net/Answer2333333/article/details/100988379</span><br><span class="line">堆排序的原理、怎么建堆和排序。</span><br></pre></td></tr></table></figure>

<h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><p>快速排序=冒泡+分治+递归</p>
<ul>
<li>先从数量中取出一个数作为基准数（简单起见可以取第一个数）</li>
<li>分区过程，将比这个数大的数全放到他的右边，小于或者等于他的数放到左边（分区）</li>
<li>再对左右区间重复第一步、第二步，直到各区间只有一个数.（递归）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（快排原理是二分法，已经排序好序列复杂度最高，partion函数使用随机定位）</span><br><span class="line">快排的最坏时间复杂度O（N2） 如何避免？（随机寻找pivot）如何随机</span><br><span class="line">（基础库的随机函数，如果rand() 是 (0, 1)区间，修改区间大小和偏移）</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li>设置一个定量的数组当作空桶； </li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去； </li>
<li>对每个不是空的桶进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>； </li>
<li>从不是空的桶里把排好序的数据拼接起来。  </li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="/Users/zcz/Desktop/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/BubbleSort.h">冒泡排序</a></td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/SelectionSort.h">选择排序</a></td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/InsertSort.h">插入排序</a></td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/QuickSort.h">快速排序</a></td>
<td>O(n*log2n)</td>
<td>O(n2)和直接插入排序一样</td>
<td>O(log2n)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/HeapSort.cpp">堆排序</a></td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/MergeSort.h">归并排序</a></td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td><strong>O(n)</strong></td>
<td>稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/ShellSort.h">希尔排序</a></td>
<td>O(n*log2n)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/CountSort.cpp">计数排序</a></td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/BucketSort.cpp">桶排序</a></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/RadixSort.h">基数排序</a></td>
<td>O(k*n)</td>
<td>O(n2)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>查找算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>查找条件</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/SequentialSearch.h">顺序查找</a></td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/BinarySearch.h">二分查找（折半查找）</a></td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/InsertionSearch.h">插值查找</a></td>
<td>O(log2(log2n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/DataStructure/HashTable.cpp">哈希查找</a></td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/blob/master/DataStructure/RedBlackTree.cpp">红黑树</a></td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log2n - log3n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>图搜索算法</th>
<th>数据结构</th>
<th>遍历时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索</a></td>
<td>邻接矩阵 邻接链表</td>
<td>O(|v|2) O(|v|+|E|)</td>
<td>O(|v|2) O(|v|+|E|)</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索</a></td>
<td>邻接矩阵 邻接链表</td>
<td>O(|v|2) O(|v|+|E|)</td>
<td>O(|v|2) O(|v|+|E|)</td>
</tr>
</tbody></table>
<h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></td>
<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题</a>、排序算法（快速排序、归并排序）</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></td>
<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题</a>、斐波那契数列</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法</a></td>
<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td>
<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td>
</tr>
</tbody></table>
<h2 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1.排序算法"></a>1.排序算法</h2><p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210824102803851.png" alt="image-20210824102803851"></p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210822164154093.png" alt="image-20210822164154093"></p>
<p><strong>稳定性</strong>：</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210822170936992.png" alt="image-20210822170936992"></p>
<h3 id="1-冒泡排序bubble-sort"><a href="#1-冒泡排序bubble-sort" class="headerlink" title="1.冒泡排序bubble sort"></a>1.冒泡排序bubble sort</h3><ol>
<li>从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置 ,(执行完一轮后，最末尾就是那个元素的最大的元素)</li>
<li><strong>稳定</strong>的排序算法</li>
</ol>
<p>第一轮：<img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210822164311788.png" alt="image-20210822164311788"><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210822170716577.png" alt="image-20210822170716577">复杂度（平均，最坏，O(n^2)，最好（O(n))  )</p>
<p>优化：</p>
<p>1.在内层循环用一个bool值记录是否进行交换，没有进行交换就直接中止（只有在有序才能优化，不然比普通的时间长，每一次多三个操作，定义，赋值，判断）</p>
<p>2.忽略上一轮曾经找到的最大元素，重复执行步骤一，直到全部元素有序（比第一个优化方式更普遍）</p>
<p>3前两种方式结合，交换则将尾巴赋值为1（最好的）</p>
<h3 id="2-原地算法"><a href="#2-原地算法" class="headerlink" title="2.原地算法"></a>2.原地算法</h3><p>1.不依赖额外资源或者依赖少数额外资源，仅靠输出覆盖输入</p>
<p>2.空间复杂度O(1)的都可以认为是原地算法</p>
<p>冒泡排序属于In-place</p>
<h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><ol>
<li>从序列中找出最小的那个元素，然后与数组最开始元素交换位置（执行完一轮后，第一个开始的那个元素就是最大的元素）verse</li>
<li>忽略1中曾经找到的最小元素，重复执行步骤1</li>
<li><strong>不稳定</strong>的算法（1中小于等于也不能保证稳定，2,4, 2,5,1==&gt;1,4,2,5,2）</li>
</ol>
<p>第一轮：最小的元素在首位</p>
<h3 id="4-堆排序-heap-sort-–对选择排序的优化"><a href="#4-堆排序-heap-sort-–对选择排序的优化" class="headerlink" title="4.堆排序 heap sort –对选择排序的优化"></a>4.堆排序 heap sort –对选择排序的优化</h3><p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823104554997.png" alt="image-20210823104554997"><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823104833260.png" alt="image-20210823104833260"><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823104952157.png" alt="image-20210823104952157"><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823105034893.png" alt="image-20210823105034893"></p>
<p>执行流程</p>
<p>1.对序列进行原地建堆</p>
<p>2.重复以下操作，直到堆的元素1(N-1次)</p>
<p>交换堆顶元素和尾元素–&gt;堆的元素减1–&gt;对0的位置进行一次siftDown操作（logN)</p>
<p>复杂度（NlogN) 空间复杂度（O(1))</p>
<p>3.不稳定排序</p>
<h3 id="5-插入排序-insertion-sort"><a href="#5-插入排序-insertion-sort" class="headerlink" title="5.插入排序 insertion sort"></a>5.插入排序 insertion sort</h3><p>类似于扑克牌排序</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823111207204.png" alt="image-20210823111207204"></p>
<p>执行流程</p>
<p>1.在执行过程中，插入排序会将序列分为2部分</p>
<p>头部是已经拍好序的，尾部是待排列的</p>
<p>2.从头开始扫描每一个元素</p>
<p>每当扫描到一个元素，就将它插入到头部合适的位置，使得头部的数据依然保持有序。</p>
<p>逆序时复杂度（O(n**2))   最好的为O(n) 空间复杂O(1)</p>
<p>3.<strong>稳定</strong>排序</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823112731329.png" alt="image-20210823112731329"></p>
<p>4.优化</p>
<p>将<strong>交换</strong>转为<strong>挪动</strong>（交换为三步，挪动为一步）</p>
<p>将待插元素备份–&gt;头部有序数据比待插元素大的，都朝尾部挪动一个位–&gt;将待插元素放到合适的位置</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823113432516.png" alt="image-20210823113432516"></p>
<h3 id="6-二分搜素–插入排序优化"><a href="#6-二分搜素–插入排序优化" class="headerlink" title="6.二分搜素–插入排序优化"></a>6.二分搜素–插入排序优化</h3><p>如何确定一个元素在数组中的位置</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823120702439.png" alt="image-20210823120702439"></p>
<p>复杂度（logn)</p>
<p>1.如果存在多个重复的值，返回哪一个值不确定</p>
<p>2.二分搜素优化了比较的次数</p>
<p>3.要求二分搜素返回的插入位置：第一个大于v的元素位置（不能等于，保持稳定性）</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210823141546174.png" alt="image-20210823141546174"></p>
<h3 id="7-归并排序-merge-sort"><a href="#7-归并排序-merge-sort" class="headerlink" title="7.归并排序 merge sort"></a>7.归并排序 merge sort</h3><p><img src="/Users/zcz/Desktop/images/image-20220505201110335.png" alt="image-20220505201110335"></p>
<p>1.不断地将当前序列平均分割成2个子序列</p>
<p>直到不能再分割（序列中只剩1个元素）</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629723882208.png" alt="1629723882208"></p>
<p>2.不断地将2个子序列合并成一个有序序列</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629727411188.png" alt="1629727411188"></p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629729017012.png" alt="1629729017012"></p>
<p>如果ri提前越界，直接将li之后的所有元素覆盖过去；li提前结束，右边也不用动了</p>
<p>复杂度（T(n)=T(n/2)*2+O(n)=O(nlogn) )最好，最坏，平均都是它</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629730789469.png" alt="1629730789469"></p>
<p>空间复杂度O(n/2+logn)=O(n)</p>
<h3 id="8-休眠排序–不提倡"><a href="#8-休眠排序–不提倡" class="headerlink" title="8.休眠排序–不提倡"></a>8.休眠排序–不提倡</h3><p>将要排序的数字设为休眠时间，每个数开一个线程，复杂度O(n)</p>
<h3 id="9-快速排序-quick-sort"><a href="#9-快速排序-quick-sort" class="headerlink" title="9.快速排序 quick sort"></a>9.快速排序 quick sort</h3><p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629731753873.png" alt="1629731753873"></p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629732316773.png" alt="1629732316773"></p>
<p>复杂度：平均是$nlogn$<br><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210824101332233.png" alt="image-20210824101332233"></p>
<h3 id="10-希尔排序-Shell-Sort—插入排序的改进"><a href="#10-希尔排序-Shell-Sort—插入排序的改进" class="headerlink" title="10.希尔排序 Shell Sort—插入排序的改进"></a>10.希尔排序 Shell Sort—插入排序的改进</h3><p>1.把序列看做是一个矩阵，分成m列，逐列进行排序</p>
<p>2.m从某个整数逐渐减为1</p>
<p>3.当m为1时，整个序列完全有序</p>
<p>希尔排序底层一般使用插入排序对每一列进行排序，也有很多资料认为希尔排序是插入排序的改进版</p>
<h3 id="11-计数排序"><a href="#11-计数排序" class="headerlink" title="11.计数排序"></a>11.计数排序</h3><p>统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引<br><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210824105721052.png" alt="image-20210824105721052"></p>
<p>1.找出最大值，给出相应存储空间</p>
<p>2.统计次数存入数组</p>
<p>3.依次取出大于1的索引</p>
<p>以上方法问题：1.无法对负值计数 2.极其浪费空间 3.不稳定 4.只能对整数排序，不能对自定义对象排序</p>
<p>改进：空间方面找出最大，最小值，从索引0开始存储次数，这样负值也能存进来，当前数值是max-min+1</p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210824111329071.png" alt="image-20210824111329071"></p>
<h3 id="12-基数排序"><a href="#12-基数排序" class="headerlink" title="12.基数排序"></a>12.基数排序</h3><p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629780732111.png" alt="1629780732111"></p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629783863502.png" alt="1629783863502"></p>
<h3 id="13-桶排序"><a href="#13-桶排序" class="headerlink" title="13.桶排序"></a>13.桶排序</h3><p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1629784640672.png" alt="1629784640672"></p>
<h2 id="2-关于B树-B-树-B-树以及红黑树的理解"><a href="#2-关于B树-B-树-B-树以及红黑树的理解" class="headerlink" title="2.关于B树 B+树 B*树以及红黑树的理解"></a>2.关于B树 B+树 B*树以及红黑树的理解</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>红黑树：linux中进程的调度用的是红黑树。数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。</p>
<p>B树：B树大量应用在数据库和文件系统当中</p>
<p>B+树：mysql使用B+树作为索引</p>
<p><strong>二叉树–&gt;二叉搜索树–&gt;二叉平衡树–&gt;红黑树</strong></p>
<p>AVL:平衡二叉树</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h3><p>底层结构是：二叉树</p>
<p><strong>定义</strong>：红黑树是基于二叉搜索树的，</p>
<p>（1）其根节点和叶子节点为黑色，</p>
<p>（2）每个红色节点的两个子节点一定是黑色，不能有两个红色节点相连，</p>
<p>（3）任一节点到每个叶子节点的路径都包含数量相同的黑节点（黑高）</p>
<p><strong>变颜色规则</strong>：所有插入的点默认为红色</p>
<h4 id="插入："><a href="#插入：" class="headerlink" title="插入："></a><em><strong>插入：</strong></em></h4><p>1.当前父亲节点是黑色直接插入</p>
<p>2.当前父亲节点是红色</p>
<p>​    （1）叔叔是红色，父亲节点和叔叔节点变黑，爷爷变红，指正定位到爷爷节点</p>
<p>​    （2）叔叔节点是黑色，</p>
<p>​                A.LL直接将父节点变为黑色，爷爷节点变红，做一次右旋</p>
<p>​                B.LR左旋成LL,再操作LL</p>
<p>​            </p>
<p><img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904102456887.png" alt="image-20210904102456887" style="zoom:50%;">–<img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904102954921.png" alt="image-20210904102954921" style="zoom:50%;">-&gt;<img src="/2021/01/02/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904103351047.png" alt="image-20210904103351047" style="zoom:50%;"></p>
<h3 id="B树-B-树"><a href="#B树-B-树" class="headerlink" title="B树(B-树)"></a>B<strong>树</strong>(B-树)</h3><p>B 树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树。</p>
<p>一棵M阶的B树：</p>
<p>（1）每个节点最多有m棵子树</p>
<p>（2）除根节点外，其余非叶子节点至少有ceil(M/2)棵子树，最多有M-1个关键码</p>
<p>（3）所有叶子节点都在同一层</p>
<p> <em>一棵含有N个总关键字数的m阶的B树的最大高度是多少?</em> log_ceil（m/2）{(N+1)/2} + 1 ，log以（m/2）为低，(N+1)/2的对数再加1</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>是应文件系统所需而产生的一种B-tree的变形树。</p>
<p>   (1) 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；</p>
<p>（2）所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。</p>
<p>（3）<strong>所有的非终端结点可以看成是索引部分</strong>，结点中仅含有其子树根结点中最大（或最小）关键字</p>
<p><strong>为什么说B+树比B树更适合数据库索引？</strong></p>
<p>1）B+树的磁盘读写代价更低</p>
<p>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；</p>
<p>2）B+树查询效率更加稳定</p>
<p>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>
<p>3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）</p>
<p>　　B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；不懂可以看看这篇解读-》<a href="https://zhuanlan.zhihu.com/p/54102723">范围查找</a></p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>​    是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p>  B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>​    B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>​    B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>​    所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h2 id="3-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url"><a href="#3-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url" class="headerlink" title="3.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?"></a>3.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?</h2><p>假如每个url大小为10bytes，那么可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。</p>
<p>　　Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M);</p>
<p>　　Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999);</p>
<p>　　巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,…,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。</p>
<p>　　Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
<p><a href="https://zhuanlan.zhihu.com/p/24383239">https://zhuanlan.zhihu.com/p/24383239</a></p>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.2Java基础</title>
    <url>/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h2><h3 id="面向过程VS面向对象⭐️"><a href="#面向过程VS面向对象⭐️" class="headerlink" title="面向过程VS面向对象⭐️"></a>面向过程VS面向对象⭐️</h3><p>对比面向过程，是两种不同的处理问题的角度 </p>
<p>面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做 什么 </p>
<p>比如：洗衣机洗衣服 </p>
<p>面向过程会将任务拆解成一系列的步骤（函数），1、打开洗衣机—–&gt;2、放衣服—–&gt;3、放洗衣粉—– 4、清洗—–&gt;5、烘干 </p>
<p>面向对象会拆出人和洗衣机两个对象： </p>
<p>人：打开洗衣机 放衣服 放洗衣粉 </p>
<p>洗衣机：清洗 烘干 </p>
<blockquote>
<p>从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护</p>
</blockquote>
<span id="more"></span>

<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81">面向对象三大特征</a></h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指<strong>把一个对象的状态信息（也就是属性）隐藏在对象内部</strong>，不允许外部对象直接访问对象的内部信息。</p>
<p>我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p>
<p><strong>好处：</strong></p>
<ol>
<li>良好的封装能够<strong>减少耦合</strong>。</li>
<li><strong>隐藏实现细节</strong>。</li>
</ol>
<p>1）<strong>javabean</strong>的属性私有，提供get，set对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String name; </span><br><span class="line">public void setName(String name)&#123; </span><br><span class="line">	this.name = &quot;tuling_&quot;+name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该name有自己的命名规则，明显不能由外部直接赋值 </p>
<p>2）<strong>orm（ 对象关系映射）框架</strong> </p>
<p>操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E7%BB%A7%E6%89%BF">继承</a></h4><p>继承是<strong>使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义可以增加新的数属性或新的功能，也可以用父类的功能。</p>
<blockquote>
<p>动物（父类）：猫，狗</p>
</blockquote>
<p><strong>好处：</strong></p>
<p>通过使用继承，可以快速地创建新的类，可以<strong>提高代码的重用，程序的可维护性</strong>，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>注意：</strong></p>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的<strong>私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</p>
<p>子类可以用自己的方式实现父类的方法。</p>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<h4 id="多态-⭐️"><a href="#多态-⭐️" class="headerlink" title="多态 ⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%A4%9A%E6%80%81">多态</a> ⭐️</h4><p><strong>同一个行为具有多个不同表现形式的能力</strong></p>
<p><strong>静态的多态性：编译时，重载（不能称为多态），动态多态性：运行时，继承</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li><p>可替换性（打印机：打印彩色，也可以打印黑白）</p>
</li>
<li><p>可扩充性（加新的子类不影响已存在类的多态性、继承性）</p>
</li>
<li><p>接口性（由子类来实现接口）</p>
</li>
</ol>
<p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li><strong>父类引用指向子类对象</strong>：Parent p = new Child();</li>
</ul>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有<strong>继承（类）/实现（接口）</strong>的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li>
<li>多态<strong>不能调用“只在子类存在但在父类不存在”</strong>的方法；</li>
<li>如果子类重写了父类的方法，<strong>真正执行的是子类覆盖的方法</strong>，如果子类没有覆盖父类的方法，执行的是父类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;A and D&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;A and A&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;B and B&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">         <span class="function">String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;B and A&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">            A a1 = <span class="keyword">new</span> A();  </span><br><span class="line">            A a2 = <span class="keyword">new</span> B();  </span><br><span class="line">            B b = <span class="keyword">new</span> B();  </span><br><span class="line">            C c = <span class="keyword">new</span> C();  </span><br><span class="line">            D d = <span class="keyword">new</span> D();  </span><br><span class="line">              </span><br><span class="line">            System.out.println(<span class="string">&quot;1--&quot;</span> + a1.show(b));  </span><br><span class="line">            System.out.println(<span class="string">&quot;2--&quot;</span> + a1.show(c));  </span><br><span class="line">            System.out.println(<span class="string">&quot;3--&quot;</span> + a1.show(d));  </span><br><span class="line">            System.out.println(<span class="string">&quot;4--&quot;</span> + a2.show(b));  <span class="comment">//4--B and A .首先a2是A引用，B实例，调用show（B b）方法，此方法在父类A中没有定义，所以B中方法show(B b)不会调用（多态必须父类中已定义该方法），再按优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</span></span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;5--&quot;</span> + a2.show(c));  <span class="comment">//同上</span></span><br><span class="line">            System.out.println(<span class="string">&quot;6--&quot;</span> + a2.show(d));  <span class="comment">//A and D .查找B中没有show(D d)方法，再查A中，有，执行。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;7--&quot;</span> + b.show(b));  </span><br><span class="line">            System.out.println(<span class="string">&quot;8--&quot;</span> + b.show(c));  <span class="comment">//B and B .</span></span><br><span class="line">            System.out.println(<span class="string">&quot;9--&quot;</span> + b.show(d));        </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1--A and A</span></span><br><span class="line"><span class="comment">2--A and A</span></span><br><span class="line"><span class="comment">3--A and D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4--B and A</span></span><br><span class="line"><span class="comment">5--B and A</span></span><br><span class="line"><span class="comment">6--A and D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7--B and B</span></span><br><span class="line"><span class="comment">8--B and B</span></span><br><span class="line"><span class="comment">9--A and D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="python-C-Java有什么区别⭐️"><a href="#python-C-Java有什么区别⭐️" class="headerlink" title="python C++ Java有什么区别⭐️"></a>python C++ Java有什么区别⭐️</h3><p>1.c++、java和python都是面向对象的编程语言，但是c++和java都是强类型静态语言，而python是一种<strong>强类型动态语言</strong></p>
<blockquote>
<p>静态：它的数据类型是在编译其间检查的；动态：运行时检查</p>
</blockquote>
<p>2.垃圾回收机制：c++需要程序员收到回收，而java和python都有自己的垃圾回收机制GC。具体两者又有不同，python的垃圾收集机制主要是用的是引用计数方式，Java还有可达性分析算法。</p>
<p>3.c++和java中<strong>变量</strong>的存储是<strong>真实值</strong>，而python总存储的是<strong>引用</strong>，所以python不用声明类型名称，它的输入均<strong>默认为字符串</strong>。</p>
<p>4.python参数传递是引用传递，Java只有值传递，C++都有</p>
<p>5.c++中用<strong>const来声明常量</strong>，java中使用<strong>final</strong>来声明，python中<strong>没有常量</strong>。</p>
<p>6.C++ ,python支持<strong>多重继承</strong>，Java 的类是<strong>单继承</strong>的；虽然 Java 的类<strong>不可以多继承</strong>，但是接口可以多继承。(类继承推荐使用单继承，这样可以保证编程思路更清晰。)</p>
<p>（1.如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体继承哪一个，会产生歧义。</p>
<p>2.如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。</p>
<p>总结：子类只能有一个亲身父亲，但是一个父类可以有多个孩子。</p>
<p>1.接口里定义的都是静态常量，方法都是抽象方法，没有逻辑实现，具体的方法必须由实现接口的类覆盖实现，只会调用实现类（子类覆盖的方法）的方法，不会产生歧义。</p>
<p>2.接口中的变量都是静态成员常量（public static final），会在编译期就感知到错误。</p>
<p>总结：接口可以继承<strong>多个父接口的相同的方法，不同的属性</strong>，不能继承多个父接口中相同的属性。）</p>
<p>7.C ++,python同时支持<strong>方法重载和操作符重载</strong>，但是 Java 只支持<strong>方法重载</strong>（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p>
<p>8.Java，python有<strong>反射机制</strong>，允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。C++没有提供这样的特性。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？⭐️"><a href="#为什么说-Java-语言“编译与解释并存”？⭐️" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-java-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%EF%BC%9F">为什么说 Java 语言“编译与解释并存”？</a>⭐️</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。</p>
<p><strong>编译型语言</strong>：通过编译器将<strong>全部代码编译</strong>成机器指令码，然后再让计算机运行。（不需要重新编译）</p>
<p><strong>解释型语言</strong>：通过解释器<strong>一行一行的将代码翻译</strong>成机器指令码，然后再让计算机运行。（每执行一次都要翻译一次）</p>
<p><strong>Java半编译语言</strong>：是将源文件（.java文件）先<strong>编译</strong>成<strong>字节码文件</strong>（.class文件），然后再在Java虚拟机（JVM）中<strong>解释</strong>执行。</p>
<blockquote>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后<strong>通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的<strong>热点代码</strong>)，所以后面<strong>引进了JIT 编译器（能够捕获程序中的热点代码）</strong>。当 JIT 编译器<strong>完成第一次编译后，其会将字节码对应的机器码保存下来</strong>，下次可以直接使用。</p>
</blockquote>
<h3 id="JVM-vs-JDK-vs-JRE⭐️"><a href="#JVM-vs-JDK-vs-JRE⭐️" class="headerlink" title="JVM vs JDK vs JRE⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=jvm-vs-jdk-vs-jre">JVM vs JDK vs JRE⭐️</a></h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220530095956933.png" alt="image-20220530095956933"></p>
<p><strong>JDK</strong> 是 Java Development Kit 缩写，它是<strong>功能齐全的 Java SDK</strong>。它<strong>拥有 JRE 所拥有的一切</strong>，还有<strong>编译器（javac）</strong>和工具（如 javadoc 和 jdb）。<strong>它能够创建和编译程序</strong>。</p>
<p><strong>JRE</strong> 是 <strong>Java 运行时环境</strong>。它是<strong>运行已编译</strong> <strong>Java 程序所需的所有内容的集合</strong>，包括 Java 虚拟机<strong>（JVM），Java 类库</strong>，java 命令和其他的一些基础构件。但是，<strong>它不能用于创建新程序</strong>。</p>
<p>应用程序服务器会将 JSP 转换为  Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<p><strong>JVM</strong></p>
<p>Java 虚拟机（JVM）是<strong>运行 Java 字节码的虚拟机</strong>。<strong>不同系统的JVM是不同的</strong>（Windows，Linux，macOS），<strong>目的是使用相同的字节码，它们都会给出相同的结果。</strong></p>
<h3 id="什么是字节码-采用字节码的好处是什么-⭐️"><a href="#什么是字节码-采用字节码的好处是什么-⭐️" class="headerlink" title="什么是字节码?采用字节码的好处是什么?⭐️"></a><strong>什么是字节码?采用字节码的好处是什么?⭐️</strong></h3><blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。<br>Java 语言通过字节码的方式，在一定程度上<strong>解决了</strong>传统解释型语言<strong>执行效率低的问题</strong>，同时又保留了解释型语言<strong>可移植</strong>的特点。所以   Java   程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，   Java程序无须重新编译便可在多种不同的计算机上运行。  </p>
</blockquote>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=oracle-jdk-%E5%92%8C-openjdk-%E7%9A%84%E5%AF%B9%E6%AF%94">Oracle JDK 和 OpenJDK 的对比</a></h3><ul>
<li><p>OpenJDK 是一个参考模型并且是完全开源的，而 <strong>Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的</strong>；</p>
</li>
<li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。</p>
</li>
</ul>
<h3 id="import-java-和-javax-有什么区别？"><a href="#import-java-和-javax-有什么区别？" class="headerlink" title="import java 和 javax 有什么区别？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">import java 和 javax 有什么区别？</a></h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，<strong>javax 当时只是扩展 API 包来使用</strong>。然而随着时间的推移，javax  逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java  包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<blockquote>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></h2><h3 id="可选参数和固定参数"><a href="#可选参数和固定参数" class="headerlink" title="可选参数和固定参数"></a>可选参数和固定参数</h3><blockquote>
<p>jdk1.5以后支持可选参数,…；固定参数：就是普通的参数</p>
</blockquote>
<p>可选参数：个数从0到无穷；只能有一个；放在参数列表最后；可选参数可以组成方法重载，但可选参数的调用优先级最低。</p>
<p>重载函数调用优先级：一摸一样的 &gt; 基本类型转换的 &gt; 自动拆箱／装箱 &gt; 继承优先父类方法 &gt; 可选参数的方法</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/da66634efe7a48409f3fc002af881eca.png" alt="img"></p>
<h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别?</a></h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符：**’0’<strong>，字符串常量是双引号引起的 0 个或若干个字符：</strong>“0”**</p>
<p><strong>含义</strong> : 字符常量相当于<strong>一个整型值</strong>( ASCII 值),可以参加表达式运算; 字符串常量代表<strong>一个地址值</strong>(该字符串在内存中存放位置)</p>
<p><strong>占内存大小</strong> ： 字符常量<strong>只占 2 个字节</strong>; 字符串常量占<strong>若干个字节</strong> </p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/86735519.jpg" alt="img"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%B3%A8%E9%87%8A">注释</a></h3><p>Java 中的注释有三种：</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释。</li>
</ol>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
</blockquote>
<h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">标识符和关键字的区别是什么？</a></h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种<strong>特殊的标识符就是关键字</strong>。</p>
<h3 id="Java-中有哪些常见的关键字？"><a href="#Java-中有哪些常见的关键字？" class="headerlink" title="Java 中有哪些常见的关键字？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F">Java 中有哪些常见的关键字？</a></h3><p><strong>final</strong>：用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</p>
<p><strong>instanceof</strong>：用来确定对象所属的类</p>
<p><strong>interface</strong>：接口</p>
<p><strong>implements</strong>：指定的接口中所声明的所有方法的实现</p>
<p><strong>native</strong>：指示该方法是用Java以外的语言实现的</p>
<p><strong>strictfp</strong>：用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</p>
<p><strong>super</strong>：表明当前对象的父类型的引用或者父类型的构造方法</p>
<p><strong>synchronized</strong>：表明一段代码需要同步执行</p>
<p><strong>throw</strong>：抛出一个异常</p>
<p><strong>throws</strong>：声明在当前定义的成员方法中所有需要抛出的异常</p>
<p><strong>transient</strong>：声明不用序列化的成员域</p>
<p><strong>volatile</strong>：表明两个或者多个变量必须同步地发生变化；可以被多个线程异步修改的成员变量</p>
<p><strong>abstract</strong></p>
<blockquote>
<p>abstract关键字可以修饰类或方法。</p>
<p>abstract类可以扩展（增加子类），但不能直接实例化。</p>
<p>abstract方法不在声明它的类中实现，但必须在某个子类中重写。</p>
</blockquote>
<h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</a>⭐️</h3><p><strong>Java 泛型</strong>（generics）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是<strong>伪泛型</strong>，这是因为 Java <strong>在编译期间</strong>，所有的<strong>泛型信息都会被擦掉</strong>，这也就是通常所说<strong>类型擦除</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果为</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管ArrayList<String>和ArrayList<Integer>看上去是不同的类型，但是上面的程序会认为它们是相同的类型。ArrayList<String>和ArrayList<Integer>在运行时事实上是相同的类型。这两种类型都<strong>被擦除成它们的“原生”类型，即ArrayList。</strong></Integer></String></Integer></String></p>
<p>问题：怎么知道对象属于哪个类型</p>
<p><strong>instanceof</strong></p>
</blockquote>
<p><strong>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法</strong></p>
<blockquote>
<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>T (type) 表示具体的一个 java 类型</li>
<li>E (element) 代表 Element</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>？ 表示不确定的 java 类型</li>
</ul>
</blockquote>
<p><strong>解决擦除的问题</strong></p>
<ul>
<li><strong>引入类型标签，使用动态的isInstance()代替instanceof</strong></li>
<li><strong>用工厂方法或模版方法创建类型实例</strong></li>
</ul>
<p><strong>真的完全擦除了吗</strong></p>
<blockquote>
<p>并不完全正确，<strong>Singature属性</strong>会为它记录泛型签名信息。Signature属性就是为了弥补擦除法的缺陷而增设的，<strong>Java可以通过反射获得泛型类</strong>型，这部分信息基本能够满足我们日常开发中的大多数场景。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>在Java里面可以<strong>通过反射获取泛型信息</strong>的场景有三个，分别是：</p>
<p>(1)<strong>成员变量</strong>的泛型</p>
<p>(2)<strong>方法参数</strong>的泛型</p>
<p>(3)<strong>方法返回值</strong>的泛型</p>
<blockquote>
<p>注意，通过<strong>对象本身也是没法获取的</strong>。</p>
<p>不能通过发射获取泛型类型信息的场景有二个，分别是：</p>
<p>(1)<strong>类或接口</strong>声明的泛型信息</p>
<p>(2)<strong>局部变量</strong>的泛型信息</p>
</blockquote>
<h3 id="和-equals-的区别⭐️"><a href="#和-equals-的区别⭐️" class="headerlink" title="==和 equals 的区别⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">==和 equals 的区别</a>⭐️</h3><p><strong>==<strong>对于基本数据类型来说，比较的是值。对于引用数据类型来说，比较的是对象的内存地址。因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，</strong>其本质比较的都是值</strong>，只是引用类型变量存的值是<strong>对象的地址</strong>。</p>
<p><strong>equals()</strong> 作用不能用于判断基本数据类型的变量，<strong>只能用来判断两个对象是否相等</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<blockquote>
<p>String类重写Object类的equals方法判断两个字符串的内容是否相等</p>
</blockquote>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 equals()方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，<strong>等价于通过“==”比较这两个对象</strong>，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 equals()方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来<strong>比较两个对象中的属性是否相等</strong>；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// String类覆盖了 equals()方法  true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;	<span class="comment">//先比较长度</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;					<span class="comment">//从头开始遍历，比较</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>Object的equals方法容易抛空指针异常</strong>，应使用常量或确定有值的对象来调用 equals。 不过更推荐使用 <code>java.util.Objects#equals</code>(<strong>JDK7 引入的工具类</strong>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">str.equals(<span class="string">&quot;SnailClimb&quot;</span>)；	<span class="comment">//空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;SnailClimb&quot;</span>.equals(str);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="hashCode-与-equals-⭐️"><a href="#hashCode-与-equals-⭐️" class="headerlink" title="hashCode()与 equals() ⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=hashcode%E4%B8%8E-equals">hashCode()与 equals()</a> ⭐️</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>
<p><strong>1)hashCode()介绍:</strong></p>
<p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>，也称为散列码；散列表存储的是键值对(key-value)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode：是一个<span class="keyword">native</span>方法，返回的是对象的内存地址.能根据“键”快速的检索出对应的“值”</span><br></pre></td></tr></table></figure>

<p><strong>2)为什么要有 hashCode？</strong></p>
<p>我们以<strong>“<code>HashSet</code> 如何检查重复”为例子</strong>来说明为什么要有 hashCode。</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相等的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是<strong>如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同（比较属性值）</strong>。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就<strong>会重新散列到其他位置</strong>。这样我们就<strong>大大减少了 equals 的次数</strong>。</p>
<p><strong>3)为什么重写 equals 时必须重写 hashCode 方法？</strong></p>
<blockquote>
<p>hashCode()<code>的默认行为是对堆上的对象产生独特值。</code>如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<blockquote>
<p>我们希望只要id是一样的，就认定为是一个对象，集合中同一个对象只存一个</p>
</blockquote>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>因为 <strong><code>hashCode()</code> 会产生哈希冲突，产生相同的hashcode值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Product product = (Product) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id, product.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product1 = <span class="keyword">new</span> Product(<span class="number">1</span>, <span class="string">&quot;包子&quot;</span>);</span><br><span class="line">        Product product2 = <span class="keyword">new</span> Product(<span class="number">1</span>, <span class="string">&quot;馒头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Product&gt; products = <span class="keyword">new</span> HashSet&lt;Product&gt;();</span><br><span class="line">        products.add(product1);</span><br><span class="line">        products.add(product2);</span><br><span class="line">        <span class="comment">// 使用equals判断是否相等</span></span><br><span class="line">        System.out.println(product1.equals(product2));</span><br><span class="line">        <span class="comment">// 查看HashSet中元素个数</span></span><br><span class="line">        System.out.println(products.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【测试结果】</span><br><span class="line"><span class="keyword">true</span> <span class="comment">// 可以看到判断是相等的</span></span><br><span class="line"><span class="number">2</span> 	 <span class="comment">// 但是还是存到了HashSet中，不重写hashcode，会将同个对象判定为2个对象⚠️</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写hashCode,再次测试</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(id);</span><br><span class="line">&#125;</span><br><span class="line">【测试结果】</span><br><span class="line"><span class="keyword">true</span> <span class="comment">// 可以看到判断是相等的</span></span><br><span class="line"><span class="number">1</span> <span class="comment">// 并且第二个值并没有存到HashSet中</span></span><br></pre></td></tr></table></figure>



<h3 id="Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F">Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</a></h3><p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210702215318688.png" alt="image-20210702215318688"></p>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p><strong>（2）包装类型 VS 基本类型</strong>⭐️</p>
<p>1）包装类型不赋值就是 <code>Null</code> ，而<strong>基本类型有默认</strong>值且不是 <code>Null</code>。</p>
<p>2）基本数据类型直接存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于<strong>堆</strong>中。</p>
<h3 id="自动装箱与拆箱⭐️"><a href="#自动装箱与拆箱⭐️" class="headerlink" title="自动装箱与拆箱⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1">自动装箱与拆箱</a>⭐️</h3><ul>
<li><strong>装箱</strong>：将基本类型<strong>用它们对应的引用类型</strong>包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<blockquote>
<p>1）包装类型可以为 null，而基本类型不可以</p>
<p>2）包装类型可用于泛型，而基本类型不可以</p>
<p>3）基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用</p>
<p>当需要进行自动装箱时，如果<strong>数字在 -128 至 127 之间时，会直接使用缓存中的对象</strong>，而不是重新创建一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span> 等价于 Integer i = Integer.valueOf(<span class="number">10</span>)	<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i 等价于 <span class="keyword">int</span> n = i.intValue();									<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h3 id="int和Integer有什么区别？为什么要有包装类？⭐️"><a href="#int和Integer有什么区别？为什么要有包装类？⭐️" class="headerlink" title="int和Integer有什么区别？为什么要有包装类？⭐️"></a>int和Integer有什么区别？为什么要有包装类？⭐️</h3><ul>
<li>数据类型不同：int 是基础数据类型，而 Integer 是包装数据类型；</li>
<li>默认值不同：int 的默认值是 0，而 Integer 的默认值是 null；</li>
<li>内存中存储的方式不同：int 在<strong>栈中直接存储的具体数值</strong>，而 Integer 存储的是<strong>堆中的引用</strong>，当 new 一个 Integer 时实际上是生成一个指针指向此对象；</li>
<li>实例化方式不同：Integer 必须实例化才可以使用，而 int 不需要；</li>
<li>变量的比较方式不同：int 可以使用 == 来对比两个变量是否相等，而 Integer 一定要使用 equals 来比较两个变量是否相等。</li>
</ul>
<p>万物皆对象。在很多情况下，需要以对象的形式操作，比如 hashCode() 获取哈希值，或者 getClass() 获取类等。</p>
<p>Java 中每个基本数据类型都对应了一个包装类，而 int 对应的包装类就是 Integer，包装类的存在解决了基本数据类型无法做到的事情：<strong>泛型类型参数（T，E，K，V，？）、序列化、类型转换、高频区间数据缓存（-128，127）</strong>等问题。</p>
<h3 id="8-种基本类型的包装类和常量池-⭐️"><a href="#8-种基本类型的包装类和常量池-⭐️" class="headerlink" title="8 种基本类型的包装类和常量池 ⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0">8 种基本类型的包装类和常量池</a> ⭐️</h3><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p>
<p><code>Character</code> 创建了数值在[0,127]范围的缓存数据，</p>
<p><code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>⚠️：如果超出对应范围仍然会去创建新的对象。</p>
<blockquote>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
</blockquote>
<p>⚠️：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;										<span class="comment">//常量池中的对象</span></span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);	</span><br><span class="line">System.out.println(i1==i2);					<span class="comment">//比较地址，false</span></span><br><span class="line">System.out.println(i1.equals(i2));	<span class="comment">//true，比较属性值</span></span><br></pre></td></tr></table></figure>

<h4 id="荐使用valueOf-方法，少使用-parseLong-方法"><a href="#荐使用valueOf-方法，少使用-parseLong-方法" class="headerlink" title="荐使用valueOf 方法，少使用 parseLong 方法"></a>荐使用<em>valueOf</em> <em>方法，少使用</em> <em>parseLong</em> <em>方法</em></h4><p>valueOf 方法会从缓存中去 拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84">在一个静态方法内调用一个非静态成员为什么是非法的?</a></h3><p><strong>静态方法是属于类</strong>的，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。<br>而<strong>非静态成员属于实例对象</strong>，只有<strong>在对象实例化之后才存在</strong>，然后通过类的实例对象去访问。<br><strong>在类的非静态成员不存在的时候静态成员就已经存在</strong>了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F">静态方法和实例方法有何不同？</a></h3><p>1.在外部<strong>调用静态方法</strong>时，可以使用**”类名.方法名**”的方式，也可以使用”<strong>对象名.方法名</strong>“的方式。实例方法只能用”<strong>对象名.方法名</strong>“的方式。</p>
<p>2.静态方法在<strong>访问本类的成员</strong>时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法）；实例方法则无此限制。</p>
<h3 id="为什么-Java-中只有值传递？⭐️"><a href="#为什么-Java-中只有值传递？⭐️" class="headerlink" title="为什么 Java 中只有值传递？⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F">为什么 Java 中只有值传递？</a>⭐️</h3><p><strong>按值调用(call by value)</strong> 表示方法接收的是参数的值(<strong>不能修改值对应的变量</strong>)，<strong>按引用调用（call by reference)</strong> 表示方法接收的是实参的实际地址（可以修改值对应的变量）。</p>
<p>实参：方法被调用时传入的实际值。</p>
<p>形参：在定义方法时括号内定义的参数列表即为形参</p>
<p><strong>Java 程序设计语言总是采用按值调用。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）不能修改一个基本数据类型的参数</span><br><span class="line">C++里面的swap(<span class="keyword">int</span> a, <span class="keyword">int</span> b)，Java不行</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">2</span>）改变一个对象参数的状态</span><br><span class="line">swap（arr）</span><br><span class="line">swap(<span class="keyword">int</span>[] array)		对象引用作为参数就可以,arr array 指向同一个数组对象</span><br><span class="line">方法得到的是对象引用的拷贝array</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">3</span>）不能交换<span class="number">2</span>个对象（只交换了拷贝的<span class="number">2</span>个对象）</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>交换之前：</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/88729818.jpg" alt="img"></p>
<p>交换之后：</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/34384414.jpg" alt="img"></p>
<p>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，<strong>这个方法交换的是这两个拷贝</strong></p>
<blockquote>
<p>封装类可以解决这个问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Wrapper over class that is used for swapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWrapper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   Car c;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor</span></span><br><span class="line">   CarWrapper(Car c)   &#123;<span class="keyword">this</span>.c = c;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Class that use Car and swaps objects of Car</span></span><br><span class="line"><span class="comment">// using CarWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This method swaps car objects in wrappers</span></span><br><span class="line">    <span class="comment">// cw1 and cw2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(CarWrapper cw1, </span></span></span><br><span class="line"><span class="params"><span class="function">                            CarWrapper cw2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car temp = cw1.c;</span><br><span class="line">        cw1.c = cw2.c;</span><br><span class="line">        cw2.c = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="number">101</span>, <span class="number">1</span>);</span><br><span class="line">        Car c2 = <span class="keyword">new</span> Car(<span class="number">202</span>, <span class="number">2</span>);</span><br><span class="line">        CarWrapper cw1 = <span class="keyword">new</span> CarWrapper(c1);</span><br><span class="line">        CarWrapper cw2 = <span class="keyword">new</span> CarWrapper(c2);</span><br><span class="line">        swap(cw1, cw2);</span><br><span class="line">        cw1.c.print();</span><br><span class="line">        cw2.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-与super"><a href="#this-与super" class="headerlink" title="this 与super"></a>this 与super</h3><p>this 和 super 都是 Java 中的关键字，都起指代作用，当显示使用它们时，都需要将它们放<strong>在方法的首行</strong>（否则编译器会报错）。 super 是用来访问父类实例属性和方法的。this 是用来访问本类实例属性和方法的，它会先从本类中找，如果本类中找不到则在父类中找。</p>
<p>它们有四点不同：<strong>指代对象、查找访问、本类属性赋值和 synchronized 的使用不同</strong>。<br>super 指代的是父类，是用来访问父类的；而 this 指代的是当前类。</p>
<p>super 只能查找父类，而 this 会先从本类中找，如果找不到则会去父类中找。</p>
<p>this 可以用来为本类的实例属性赋值，而 super 则不能实现此功能。</p>
<p>因为 this 表示当前对象，所以this 可用于 synchronized(this){….} 加锁，而 super 则不能实现此功能。</p>
<h3 id="重载和重写的区别⭐️"><a href="#重载和重写的区别⭐️" class="headerlink" title="重载和重写的区别⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB">重载和重写的区别⭐️</a></h3><p>重载就是<strong>同一个类</strong>中的<strong>多个同名方法</strong>能够根据<strong>输入数据的不同</strong>，做出不同的处理</p>
<p>重写就是当<strong>子类继承自父类的相同方法</strong>，输入数据一样，但要做出有别于父类的处理</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220211120633893.png" alt="image-20220211120633893"></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210705103857095.png" alt="image-20210705103857095"></p>
<blockquote>
<p>方法名称+参数类型+参数个数=<strong>方法签名</strong>，JVM通过这个签名来调用哪个重载方法。</p>
<p><strong>重载为什么不加返回类型？</strong>加了之后，调用重载函数（不会写返回类型），JVM就不能判断调用哪个重载函数</p>
</blockquote>
<blockquote>
<p><strong>不能重写的情况？</strong></p>
<ol>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> <strong>则子类就不能重写该方法</strong>，但是被 static 修饰的方法能够被再次声明。</li>
<li><strong>构造方法无法被重写</strong></li>
</ol>
</blockquote>
<h3 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%B7%B1%E6%8B%B7%E8%B4%9D-vs-%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝 vs 浅拷贝</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝：一个指针指向已存在的内存地址</span><br><span class="line">深拷贝：申请了一个新的内存，指针再指向</span><br></pre></td></tr></table></figure>

<h3 id="成员变量与局部变量的区别有哪些？⭐️"><a href="#成员变量与局部变量的区别有哪些？⭐️" class="headerlink" title="成员变量与局部变量的区别有哪些？⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">成员变量与局部变量的区别有哪些？</a>⭐️</h3><ol>
<li>从<strong>语法</strong>形式上看，<strong>成员变量是属于类</strong>的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，<strong>成员变量和局部变量都能被 <code>final</code> 所修饰</strong>。</li>
<li>从变量在<strong>内存中的存储方式</strong>来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是<strong>属于类</strong>的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</li>
<li>从变量在<strong>内存中的生存时间</strong>上看，静态变量的生命周期取决于类的生命周期；非静态成员变量是对象的一部分，它<strong>随着对象</strong>的创建而存在，而局部变量<strong>随着方法</strong>的调用结束而自动消失。</li>
<li>从变量<strong>是否有默认值</strong>来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而<strong>局部变量则不会自动赋值</strong>。</li>
</ol>
<blockquote>
<p>一个局部变量，如果不赋值，那么这个变量也不会进入到内存中，可以认为不存在。</p>
</blockquote>
<p>类的生命周期</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/7af40ad162d9f2d3e1256ea3d1b8f31b6327cc27.png" alt="img"></p>
<h3 id="内存分区⭐️"><a href="#内存分区⭐️" class="headerlink" title="内存分区⭐️"></a>内存分区⭐️</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈区：存放函数的局部变量，返回值以及形参</span><br><span class="line">堆区：调用malloc函数主动申请，如果不调用free函数就不会自动释放</span><br><span class="line">全局／静态区／数据段：存放静态变量和全局变量的地方</span><br><span class="line">常量区：存放常量的地方</span><br><span class="line">代码区：存放代码的地方</span><br></pre></td></tr></table></figure>

<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></h3><p>new 运算符，new 创建对象实例（<strong>对象实例在堆内存</strong>中），对象引用：指向对象实例（<strong>对象引用存放在栈</strong>内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。    </p>
<h3 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">对象的相等与指向他们的引用相等,两者有什么不同?</a></h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88">一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</a></h3><p>构造方法主要作用是<strong>完成对类对象的初始化工作</strong>。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会<strong>有默认的不带参数的构造方法</strong>。如果我们<strong>自己添加了</strong>类的构造方法（无论是否有参），Java就不<strong>会再添加默认的无参数的构造方法</strong>了。</p>
<h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法有哪些特点？是否可被 override?</a></h3><p><strong>特点：</strong></p>
<ol>
<li><strong>名字与类名相同</strong>。</li>
<li><strong>没有返回值，但不能用 void 声明构造函数</strong>。</li>
<li>生成类的对象时<strong>自动执行</strong>，无需调用。</li>
</ol>
<p><strong>构造方法不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p>
<blockquote>
<p>构造方法不可以被重写,因为重写发生在父类和子类之间,要求方法名称相同,而构造方法的名称是和类名相同的,而子类类名不会和父类类名相同,所以不可以被重写。</p>
</blockquote>
<h3 id="final、finally、finalize有什么区别？⭐️"><a href="#final、finally、finalize有什么区别？⭐️" class="headerlink" title="final、finally、finalize有什么区别？⭐️"></a>final、finally、finalize有什么区别？⭐️</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>java中的关键字</p>
<ul>
<li>修饰类：表示类不可被继承 </li>
<li>修饰方法：表示方法不可重写，但是可以重载 </li>
<li><strong>修饰变量</strong>：表示变量一旦被赋值就不可以更改它的值。  </li>
<li>修饰参数：此参数在整个方法不允许被修改</li>
</ul>
<h5 id="赋值时机"><a href="#赋值时机" class="headerlink" title="赋值时机"></a>赋值时机</h5><p>（1）<strong>类(静态)变量</strong>VS成员变量 </p>
<p>如果final修饰的是<strong>类变量</strong>，<strong>只能在静态初始化块</strong>中指定初始值或者构造函数里面指定初始值，等号赋值。(final static修饰：则有2种：等号赋值，静态初始化块赋值)</p>
<p>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</p>
<p>（2）修饰局部变量 </p>
<p>系统不会为局部变量进行初始化，<strong>局部变量必须由程序员显示初始化</strong>。不规定赋值时机，只需要在使用前赋值就可以。</p>
<p>（3）修饰基本类型数据和引用类型数据 </p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； </li>
<li>如果是引用类型的变量，则在对其初始化之后便<strong>不能再让其指向另一个对象</strong>。<strong>但是引用的值是可变的</strong>。 </li>
</ul>
<h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>用final修饰不一定具有不变性。</p>
<ul>
<li><p>修饰基本类型，具有不变性</p>
</li>
<li><p>修改对象，里面的属性也都被final修饰不一定具有不变性</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426104758235.png" alt="image-20220426104758235"></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105203573.png" alt="image-20220426105203573"></p>
</li>
<li><p>在方法里面新建的局部变量，是线程安全的，栈封闭，每个线程都有独自的栈</p>
</li>
</ul>
<p><strong>面试</strong></p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220426105733852.png" alt="image-20220426105733852"></p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>是一种一定被执行的机制。无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。比如：try  finally或者try catch finally来进行关闭JDBC连接，保证释放锁等动作。</p>
<p><strong>在以下 3 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><strong>Object类的基础方法</strong>，设计目的是保证在被垃圾收集前完成特定资源的回收，JDK9之后弃用了。</p>
<ul>
<li>finalize不一定被执行，不稳定</li>
</ul>
<blockquote>
<p>当对象变成(GC Roots)<strong>不可达时</strong>，GC会判断该对象是否覆盖了finalize方法，<strong>若未覆盖，则直接将其回收</strong>。否则，若对象未执行过finalize方法，将其<strong>放入F-Queue队列</strong>，由一<strong>低优先级线程</strong>执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会<strong>再次判断该对象是否可达</strong>，若不可达，则进行回收，否则，对象“复活” 。</p>
</blockquote>
<ul>
<li>阻碍JVM垃圾回收，性能差。GC本就因为内存不足引起，finalize调用又很慢，不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多就会容易Full GC，Full GC释放速度如果仍跟不上创建新对象的速度，就会OOM。</li>
</ul>
<h3 id="Static⭐️"><a href="#Static⭐️" class="headerlink" title="Static⭐️"></a>Static⭐️</h3><h4 id="修饰的对象"><a href="#修饰的对象" class="headerlink" title="修饰的对象"></a><em>修饰的对象</em></h4><p>static 只能修饰类变量、代码块和方法。补充：还有 class。</p>
<blockquote>
<p>修饰类变量、代码块和方法都与类无关</p>
<ul>
<li>我们<strong>不需要初始化类</strong>就可直接使用静态变量；</li>
<li>静态变量<strong>只会初始化一次</strong>，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。</li>
</ul>
</blockquote>
<p><strong>(1)当static</strong> <strong>修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且 无需初始化类，直接使用 <strong>类名.static</strong> <strong>变量</strong> 这种形式访问即可。</p>
<p>需要注意线程安全的问题了，因为当多个线程同时对共享变量进行读 写时，很有可能会出现并发问题。</p>
<p>两个解决办法：</p>
<ul>
<li>把线程不安全的 ArrayList 换成线程安全的 CopyOnWriteArrayList；</li>
<li>每次访问时，手动加锁。</li>
</ul>
<p>(2)<strong>当</strong> <strong>static</strong> <strong>修饰方法时</strong>，代表<strong>该方法和当前类是无关的</strong>，任意类都可以直接访问（如果权限是 public 的话）。 </p>
<p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们 常用的 <strong>util 类里面的各种方法，我们比较喜欢用 static 修饰方法</strong>，好处就是调用特别方便。</p>
<blockquote>
<p><strong>static 方法内部的变量在执行时是没有线程安全问题的</strong>。方法执行时，数据运行在栈里面，栈的 数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p>
</blockquote>
<p>(3)<strong>当</strong> <strong>static</strong> <strong>修饰方法块时</strong>，我们叫做静态块，静态块常常用于<strong>在类启动之前，初始化一些值</strong>，比如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">	list.add(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 <strong>static 的变量需要写在静态块的前面</strong>，不然编译也会报错。</p>
</blockquote>
<p>(4)static关键字还可以修饰类，<strong>普通类是不允许声明为静态的，只有内部类才可以</strong>。</p>
<p>被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。</p>
<h4 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a><em>初始化时机</em></h4><p>\1. 父类的静态变量和静态块比子类优先初始化； </p>
<p>\2. 静态变量和静态块<strong>比类构造器优先初始化</strong>。 </p>
<ol start="3">
<li>被 static 修饰的<strong>方法</strong>，在类初始化的时候并不会初始化，<strong>只有当自己被调用时，才会被执行。</strong></li>
</ol>
<h3 id="volatile⭐️"><a href="#volatile⭐️" class="headerlink" title="volatile⭐️"></a>volatile⭐️</h3><p>  <strong>概念</strong>：volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。 </p>
<p><strong>前提：</strong>在多核 CPU 下，为了提高效率，<strong>线程在拿值时，是 直接和 CPU 缓存打交道的</strong>，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 时，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以<strong>线程读的操作永远都是拿CPU 缓存的值</strong>。<br>这时候会产生一个问题，<strong>CPU 缓存中的值和内存中的值可能并不是时刻都同步</strong>，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值， <strong>CPU 缓存的值还是旧的</strong>，导致计算会出现问题。</p>
<p><strong>原理</strong>：这时候有个机制，就是<strong>内存会主动通知 CPU 缓存</strong>。当前共享变量的值已经失效了，你需要重新来拉取一份，<strong>CPU 缓存就会重新从内存中拿取一份最新的值</strong>。</p>
<p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存 中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而<strong>保证线程从 CPU 缓存中拿取出来的值是最新的</strong>。</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a><strong>transient</strong></h3><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时， 就会忽略该变量。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>default 关键字一般会用在接口的方法上，意思是<strong>对于该接口，子类是无需强制实现的</strong>，但接口自己 必须有默认实现。</p>
<h3 id="工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️"><a href="#工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️" class="headerlink" title="工作中有没有遇到特别好用的工具类，如何写好一个工具类⭐️"></a><em>工作中有没有遇到特别好用的工具类，如何写好一个工具类</em>⭐️</h3><p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空，相等判断等等工具类，好的工具类肯定很好用，比如说<strong>使用 static final 关键字对方法进行修饰， 工具类构造器必须是私有</strong>等等手段来写好工具类。</p>
<blockquote>
<p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。</p>
<p>Collections 是为了方便使用集合而产生的工具类，求集合中最大、小值，</p>
<p>线程安全集合synchronized；不可变集合unmodifiable （Map）</p>
<p>Objects 提供了equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的</p>
<p>Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值， requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常</p>
</blockquote>
<h3 id="为什么局部内部类和匿名内部类只能访问局部final变量？⭐️"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量？⭐️" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量？⭐️"></a><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong>⭐️</h3><p>首先需要知道的一点是: <strong>内部类和外部类是处于同一个级别的</strong>，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 </p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有 没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解 决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期。</p>
<p><strong>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修 改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</strong> </p>
<p><strong>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量</strong>，就保证了内部类的成员变量 和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p>
<h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-⭐️"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的-⭐️" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?⭐️</a></h3><p><strong>（1）可不可变</strong></p>
<p><code>String</code> 类被 final 修饰；并且String中使用 <strong>final</strong> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<strong>String 对象是不可变的</strong>。</p>
<p>String每次操作都会返回一个新的String</p>
<blockquote>
<p>str =  str.replace(“l”,”dd”);//正确</p>
<p>str.replace(“l”,”dd”);//错误</p>
</blockquote>
<blockquote>
<p>在 <strong>Java 9</strong> 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用<strong>字符数组保存字符串</strong><code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以<strong>这两种对象都是可变的</strong>。</p>
<p><strong>（2）线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为<strong>常量</strong>，线程安全。</p>
<p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了<strong>同步锁</strong>，所以是<strong>线程安全</strong>的。</p>
<p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<blockquote>
<p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p>
</blockquote>
<p><strong>（3）性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会<strong>生成一个新的</strong> <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> <strong>对象本身进行操作</strong>，而不是生成新的对象。</p>
<p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 <strong>10%~15% 左右的性能提升</strong>，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作<strong>少量的数据</strong>: 适用 <code>String</code></li>
<li><strong>单线程</strong>操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li><strong>多线程</strong>操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="抽象类VS接口⭐️"><a href="#抽象类VS接口⭐️" class="headerlink" title="抽象类VS接口⭐️"></a>抽象类VS接口⭐️</h3><p>（1）区别：</p>
<ul>
<li>抽象类的设计目的，是<strong>代码复用</strong>（当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时。）；接口的设计目的，是<strong>对类的行为进行约束</strong>（对行为的抽象，它只约束了行为的有无，不对如何实现行为进行限制。）。</li>
<li>抽象类可以存在普通<strong>成员函数</strong>，而接口中只能存在<strong>public abstract</strong> 方法。 </li>
<li>抽象类中的<strong>成员变量</strong>可以是各种类型的，而接口中的成员变量只能是<strong>public static final</strong>类型的。 </li>
<li>抽象类只能继承一个（extend），<strong>接口可以实现多个（implement）</strong>。</li>
</ul>
<p>（2）场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">eat和sleep都是狗本身所应该具有的一种行为,而钻火圈这种行为则是后天训练出来的,只能算是对狗类的一种附加或者延伸, 两者不应该在同一个范畴内</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义接口，含有钻火圈方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> interface <span class="title">DrillFireCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drillFireCircle</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">//定义抽象类狗类:包括eat() 、sleep() 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//一个SpecialDog即可继承Dog类并且实现DrillFireCircle()接口</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SpecialDog</span> <span class="keyword">extends</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">drillFireCircle</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drillFireCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（3）总结：</p>
<blockquote>
<p>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>概念：反射之所以被称为<strong>框架的灵魂</strong>，主要是因为它赋予了我们在<strong>运行时</strong>分析类以及执行类中方法的能力。通过反射你可以<strong>获取和调用任意一个类的所有属性和方法</strong>。</p>
<h4 id="反射机制优缺点-⭐️"><a href="#反射机制优缺点-⭐️" class="headerlink" title="反射机制优缺点 ⭐️"></a>反射机制优缺点 ⭐️</h4><p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了<strong>安全问题</strong>。比如可以<strong>无视泛型参数的安全检查</strong>（泛型参数的安全检查发生在编译时）。另外，反射的<strong>性能也要稍差点</strong>，不过，对于框架来说实际是影响不大的。</p>
<p><strong>为什么比较慢？</strong></p>
<p>反射它其实是一个<strong>解释过程</strong>，在运行期时，需要告诉JVM想要什么；（所有被调用/创建的都必须<strong>被发现</strong>；<strong>参数</strong>需要通过装箱/拆箱、打包到数组中<strong>进行修饰</strong>。）</p>
<p><strong>使用反射的一般步骤</strong></p>
<p>获取Class对象，然后调用对象的属性及方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取Class对象有三种方式：</span><br><span class="line">第一种是对象调用getClass方法。</span><br><span class="line">第二种方式：知道类名，直接用类名.class方式获取。此种方式性能最优。</span><br><span class="line">第三种方式：知道类的全限定名，使用Class对象的静态方法forName方法获取</span><br></pre></td></tr></table></figure>

<h4 id="反射的应用场景-⭐️"><a href="#反射的应用场景-⭐️" class="headerlink" title="反射的应用场景 ⭐️"></a>反射的应用场景 ⭐️</h4><p>例子：<a href="https://blog.csdn.net/qq_33613491/article/details/106711513">https://blog.csdn.net/qq_33613491/article/details/106711513</a></p>
<p>1）<strong>动态代理</strong>的实现也依赖反射。</p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了<strong>反射类</strong> <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);	<span class="comment">//调用指定方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于<strong>反射分析类</strong>，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h3 id="Java中的异常体系⭐️"><a href="#Java中的异常体系⭐️" class="headerlink" title="Java中的异常体系⭐️"></a>Java中的异常体系⭐️</h3><p>Java中的所有异常都来自顶级父类Throwable。Throwable下有两个子类Exception和Error。</p>
<ul>
<li><p>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。比如：OOM，</p>
</li>
<li><p>Exception：不会导致程序停止。</p>
</li>
</ul>
<p>1）非受检查异常：RunTimeException<strong>运行时</strong>异常（比如：空指针，数组越界）</p>
<p>2）受检查异常：CheckedException发生在<strong>编译</strong>过程（如：IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需处理，否则程序就不能编译通过，它有两种处理方法，通过 try catch 捕获或者通过 throw 把异常抛出去。）。</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20210723084524957.png" alt="image-20210723084524957"></p>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=try-catch-finally">try-catch-finally</a></h3><ul>
<li><p><strong>try块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
</li>
<li><p><strong>catch块：</strong> 用于处理 try 捕获到的异常。</p>
</li>
<li><p><strong>finally 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。并且 finally 语句的返回值将会覆盖原始的返回值。</p>
</li>
<li><p>```java<br>public class Test {</p>
<pre><code>public static int f(int value) &#123;
    try &#123;
        return value * value;
    &#125; finally &#123;
        if (value == 2) &#123;
            return 0;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>//如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**在以下 3 种特殊情况下，finally 块不会被执行：**</span><br><span class="line"></span><br><span class="line">1. 在 `try` 或 `finally`块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行</span><br><span class="line">2. 程序所在的线程死亡。</span><br><span class="line">3. 关闭 CPU。</span><br><span class="line"></span><br><span class="line">### 使用 `try-with-resources` 来代替`try-catch-finally`⭐️</span><br><span class="line"></span><br><span class="line">1. **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象</span><br><span class="line">2. **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</span><br><span class="line"></span><br><span class="line">&gt; 面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        //读取文本文件的内容</span><br><span class="line">        Scanner scanner = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            scanner = new Scanner(new File(&quot;D://read.txt&quot;));</span><br><span class="line">            while (scanner.hasNext()) &#123;</span><br><span class="line">                System.out.println(scanner.nextLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (scanner != null) &#123;</span><br><span class="line">                scanner.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素排序Comparable和Comparator有什么区别？⭐️"><a href="#元素排序Comparable和Comparator有什么区别？⭐️" class="headerlink" title="元素排序Comparable和Comparator有什么区别？⭐️"></a>元素排序Comparable和Comparator有什么区别？⭐️</h3><ul>
<li><p>（1）Comparable有比较的能力，Comparator比较器，都是顶级接口</p>
</li>
<li><p>（2）实现Comparable接口，并重写compareTo方法，支持Collections.sort和Arrays.sort。compareTo方法<strong>接收要对比的对象</strong>，将当前对象和要对比对象进行比较，返回int值，对比对象-当前对象，降序，（默认升序）</p>
</li>
</ul>
<p>Comparator的排序方法是compare</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105536011.png" alt="image-20220424105536011"></p>
<p>​    Comparator匿名类</p>
<p><img src="/2021/01/02/1.2Java%E5%9F%BA%E7%A1%80/image-20220424105658461.png" alt="image-20220424105658461"></p>
<ul>
<li>（3）使用场景不同，<strong>使用Comparable必须修改原有类</strong>，在排序的那个类实现Comparable接口，并重写compareTo方法。<strong>Comparator可以实现原有类的解耦</strong>，可以把它看成是一个对外提供排序的接口。</li>
</ul>
<h3 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">Object 类的常见方法总结</a></h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以子类不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=io-%E6%B5%81">I/O 流</a></h2><h3 id="什么是序列化-什么是反序列化-⭐️"><a href="#什么是序列化-什么是反序列化-⭐️" class="headerlink" title="什么是序列化?什么是反序列化? ⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">什么是序列化?什么是反序列化?</a> ⭐️</h3><p><strong>场景：</strong>如果我们需要<strong>持久化 Java 对象</strong>比如将 <strong>Java 对象保存在文件</strong>中，或者在<strong>网络传输 Java 对象</strong>，这些场景都需要用到序列化。</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象<strong>转换成二进制字节流</strong>的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">Java 序列化中如果有些字段不想进行序列化，怎么办？</a></h3><p>对于不想进行序列化的变量，使用<code>transient</code>关键字修饰。`</p>
<p><code>transient</code> <strong>只能修饰变量</strong>，不能修饰类和方法。</p>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">获取用键盘输入常用的两种方法</a></h3><p>方法 1：通过 <code>Scanner</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 <code>BufferedReader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D">Java 中 IO 流分为几种?</a></h3><ul>
<li>按照<strong>流的流向分</strong>，可以分为输入流和输出流；</li>
<li>按照<strong>操作单元</strong>划分，可以划分为字节流和字符流；</li>
<li>按照<strong>流的角色</strong>划分为节点流和处理流。</li>
</ul>
<p>Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="既然有了字节流-为什么还要有字符流-⭐️"><a href="#既然有了字节流-为什么还要有字符流-⭐️" class="headerlink" title="既然有了字节流,为什么还要有字符流? ⭐️"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81">既然有了字节流,为什么还要有字符流?</a> ⭐️</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：<strong>字符流是由 Java 虚拟机将字节流转换得到的，问题就出在这个过程还算是非常耗时</strong>，并且，如果我们不知道编码类型就<strong>很容易出现乱码</strong>问题。所以， <strong>I/O 流就干脆提供了一个直接操作字符的接口</strong>，方便我们平时对<strong>字符进行流操作</strong>。如果<strong>音频文件、图片</strong>等媒体文件用字节流比较好，<strong>如果涉及到字符</strong>的话使用字符流比较好。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p><strong>1.2.1. BigDecimal 类的用处</strong>⭐️</p>
<p><strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断（由于equals会比较值）。</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); <span class="comment">//1-b</span></span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<p><strong>1.2.2. BigDecimal 的大小比较</strong></p>
<p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p>
<p> <strong>1.2.3. BigDecimal 保留几位小数</strong></p>
<p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则</p>
<p><strong>1.2.4. BigDecimal 的使用注意事项</strong></p>
<p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<blockquote>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
</blockquote>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>1)以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line">public enum PizzaStatus &#123;</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY, </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2)使用 == 比较枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pizza.PizzaStatus pizza = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));<span class="comment">//空指针异常</span></span><br><span class="line">System.out.println(pizza == Pizza.PizzaStatus.DELIVERED);<span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="comment">// 编译正常</span></span><br><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      <span class="comment">// 编译失败，类型不匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>3)在 switch 语句中使用枚举类型</strong></p>
<p><strong>4)枚举类型的属性,方法和构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaStatus</span> </span>&#123;</span><br><span class="line">       ORDERED (<span class="number">5</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       READY (<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       DELIVERED (<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> timeToDelivery;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimeToDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       PizzaStatus (<span class="keyword">int</span> timeToDelivery) &#123;</span><br><span class="line">           <span class="keyword">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>5）EnumSet，EnumMap</strong></p>
<ul>
<li><code>EnumSet</code> 是一种专门为枚举类型所设计的 <code>Set</code> 类型。</li>
</ul>
<p>EnumSet在内部<strong>以位向量的形式存储</strong>，这种存储形式<strong>非常紧凑、高效</strong>，</p>
<p>在很多场景中的枚举常量集合操作（如：<strong>取子集、增加、删除</strong>、<code>containsAll</code>和<code>removeAll</code>批操作）使用<code>EnumSet</code>非常合适；如果需要迭代所有可能的常量则使用<code>Enum.values()</code>。</p>
<ul>
<li><code>EnumMap</code>是一个专门化的映射实现，用于<strong>将枚举常量用作键</strong>。</li>
</ul>
<p><strong>6）枚举实现单例模式，策略模式</strong></p>
<ul>
<li>单例模式</li>
</ul>
<blockquote>
<p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
</blockquote>
<p>下面的代码段显示了如何使用枚举实现单例模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaDeliverySystemConfiguration</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class="line">        <span class="comment">// Initialization configuration which involves</span></span><br><span class="line">        <span class="comment">// overriding defaults like delivery strategy</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PizzaDeliverySystemConfiguration <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> PizzaDeliveryStrategy <span class="title">getDeliveryStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deliveryStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();</span><br></pre></td></tr></table></figure>

<ul>
<li>策略模式</li>
</ul>
<p>策略模式由<strong>不同类实现同一个接口</strong>来实现的。这也就意味着添加新策略意味着<strong>添加新的实现类</strong>。</p>
<p>使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PizzaDeliveryStrategy</span> </span>&#123;</span><br><span class="line">    EXPRESS &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pizza will be delivered in express mode&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Pizza will be delivered in normal mode&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 <code>Pizza </code>增加下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDeliverable()) &#123;</span><br><span class="line">        PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">          .deliver(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.setStatus(PizzaStatus.DELIVERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza pz = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    pz.deliver();</span><br><span class="line">    assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关枚举类型的JSON序列化/反序列化</strong></p>
<p>（包括自定义）的更多信息，请参阅<a href="https://www.baeldung.com/jackson-serialize-enums">Jackson-将枚举序列化为JSON对象。</a></p>
<p>我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>
<p>下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PinType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>, <span class="string">&quot;注册使用&quot;</span>),</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>, <span class="string">&quot;忘记密码使用&quot;</span>),</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>, <span class="string">&quot;更新手机号码使用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="keyword">int</span> code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>, message=<span class="string">&#x27;忘记密码使用&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，在实际使用起来就会非常灵活方便！</p>
<h2 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h2><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3>]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.5.2开发框架SSM，SpringBoot</title>
    <url>/2021/01/02/1.5.2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SSM%EF%BC%8CSpringBoot/</url>
    <content><![CDATA[<h2 id="SSH和SSM区别"><a href="#SSH和SSM区别" class="headerlink" title="SSH和SSM区别"></a>SSH和SSM区别</h2><p>ssh通常使用 Struts2为控制器(controller) ，spring 为事务层(service)， hibernate 负责持久层（dao）<br>ssm通常使用 springMVC为控制器(controller) ，spring 为事务层(service)， </p>
<ul>
<li><h3 id="（1）MyBatis-负责持久层（dao-Struts2和SpringMVC"><a href="#（1）MyBatis-负责持久层（dao-Struts2和SpringMVC" class="headerlink" title="（1）MyBatis 负责持久层（dao)Struts2和SpringMVC"></a>（1）MyBatis 负责持久层（dao)Struts2和SpringMVC</h3></li>
</ul>
<span id="more"></span>

<p>相同：<br>spring依赖注入（DI）来管理各层的组件，都是使用AOP切面编程来管理事务，日志，权限等。<br>不同：<br>1.Struts2 和 SpringMVC <strong>控制视图和模型的交互机制不同</strong></p>
<blockquote>
<p>springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面<br>struts2采用值栈存储请求和响应的数据，通过OGNL存取数据</p>
</blockquote>
<p>2.Strtus2是<strong>Action类级别</strong>，SpringMVC是<strong>方法级别</strong>，更容易实现RESTful风格。</p>
<blockquote>
<p>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例<br>struts2是基于类开发，传递参数是通过类的属性，只能设计为多例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;3&gt;springmvc的入口是一个servlet，即前端控制器，例如：*.action</span><br><span class="line">struts2入口是一个filter过虑器，即前端过滤器，例如：/*</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="（2）Hibernate-和-MyBatis对比"><a href="#（2）Hibernate-和-MyBatis对比" class="headerlink" title="（2）Hibernate 和 MyBatis对比"></a>（2）Hibernate 和 MyBatis对比</h3></li>
</ul>
<blockquote>
<p>映射关系 Javabean&lt;=&gt;DB<br>MyBatis仅操作JavaBean，面向表结构设计，SQL框架；Hibernate操作对象去操作数据库，ORM框架</p>
</blockquote>
<p>相同：<br>1.Hibernate与MyBatis都是可以通过<strong>SessionFactoryBuider</strong>由XML配置文件生成SessionFactory，然后由<strong>SessionFactory</strong>生成<strong>Session</strong>，最后由Session来<strong>开启事务和SQL语句</strong>。其中SessionFactoryBuider,SessionFactory,Session 的生命周期都差不多<br>2.Hibernate和MyBatis都<strong>支持JDBC和JTA事务处理</strong></p>
<p>不同：</p>
<ul>
<li>（1）开发速度： </li>
</ul>
<p>MyBatis<strong>容易掌握</strong>,而Hibernate门槛较高。比起两者的开发速度，不仅仅要考虑到两者的<strong>特性及性能</strong>，更要根据<strong>项目需求</strong>去考虑究竟哪一个更适合 项目开发，比如：一个项目中用到的复杂查询基本没有，就是<strong>简单的增删改查</strong>，这样选择<strong>hibernate</strong>效率就很快了，因为基本的sql语句已经被封装好了，<strong>根本不需要你去写sql语句</strong>，这就节省了大量的时间，但是对于一个大型项目，<strong>复杂语句较多</strong>，这样再去选择hibernate就不是一个太好的选择，选择 <strong>mybatis</strong>就会加快许多，而且语句的管理也比较方便。 </p>
<ul>
<li>（2）开发工作量： </li>
</ul>
<p>Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。<br>Hibernate<strong>有良好的映射机制</strong>，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程，几乎不用编写SQL语句。针对高级查询， Mybatis<strong>需要手动编写SQL语句</strong>，以及<strong>维护ResultMap</strong>。</p>
<ul>
<li>（3）sql优化： </li>
</ul>
<p>Hibernate <strong>封装性好</strong>屏蔽了数据库差异，自动生成SQL语句。应对数据库变化能力较弱，<strong>SQL语句优化困难</strong>。</p>
<ul>
<li>（4）对象管理： </li>
</ul>
<p><strong>Hibernate 是完整的对象/关系映射解决方案</strong>，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。</p>
<ul>
<li>（5）移植性：</li>
</ul>
<p>Hibernate数据库<strong>移植性很好</strong>。MyBatis的数据库移植性不好，不同的数据库需要写不同的SQL。</p>
<ul>
<li>（6）缓存机制： </li>
</ul>
<p>Hibernate<strong>有更好的二级缓存机制</strong>。因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以<strong>在使用二级缓存时如果出现脏数据，系统会报出错误并提示</strong>。 而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围， 避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>总结：SSM和SSH不同主要在MVC实现方式，以及ORM持久化方面不同（Hiibernate与Mybatis）</p>
<p>SSM越来越<strong>轻量级配置</strong>，将<strong>注解开发</strong>发挥到极致，且<strong>ORM实现</strong>更加灵活，<strong>SQL优化</strong>更简便；SSH较注重<strong>配置开发</strong>；其中的Hiibernate对JDBC的完整封装更面向对象，<strong>对增删改查的数据维护更自动化</strong>，但<strong>SQL优化方面较弱</strong>，且入门门槛稍高。</p>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="如何实现一个IOC容器"><a href="#如何实现一个IOC容器" class="headerlink" title="如何实现一个IOC容器"></a>如何实现一个IOC容器</h3><p>1、配置文件配置包扫描路径 </p>
<p>2、递归包扫描获取.class文件 </p>
<p>3、反射、确定需要交给IOC管理的类 </p>
<p>4、对需要注入的类进行依赖注入 </p>
<ul>
<li><p>配置文件中指定需要扫描的包路径 </p>
</li>
<li><p>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解 </p>
</li>
<li><p>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路 径下所有以.class结尾的文件添加到一个Set集合中进行存储。遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 </p>
</li>
<li><p>遍历这个IOC容器，获取到每一个类的实例，判断里面是否有依赖其他类的实例，然后进行递归注入</p>
</li>
</ul>
<h3 id="spring是什么？"><a href="#spring是什么？" class="headerlink" title="spring是什么？"></a>spring是什么？</h3><p>轻量级的开源的J2EE框架。它是一个<strong>容器框架</strong>，用来装javabean（java对象），<strong>中间层框架</strong>（万能胶）可以起一个连接作用，比如说把<strong>Struts和hibernate</strong>粘合在一起运用，可以让我们的企业开发更快、更简洁 </p>
<p>Spring是一个<strong>轻量级</strong>的<strong>控制反转（IoC)和面向切面（AOP）</strong>的<strong>容器 框架</strong> </p>
<ul>
<li><p>从大小与开销两方面而言Spring都是<strong>轻量级</strong>的。 </p>
</li>
<li><p>通过控制反转(IoC)的技术达到<strong>解耦</strong>的目的 </p>
</li>
<li><p>提供了面向切面编程的丰富支持，允许通过分离应用的<strong>业务逻辑与系统级服务进行内聚性</strong>的开发 </p>
</li>
<li><p>包含并**管理应用对象(Bean)**的配置和生命周期，这个意义上是一个容器。 </p>
</li>
<li><p>将<strong>简单的组件配置</strong>组合成为复杂的应用，这个意义上是一个框架。 </p>
</li>
</ul>
<h3 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h3><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如<strong>日志、事务管理和安全</strong>这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为<strong>横切关注点</strong>，因为它们会跨越系统的多个组件。 </p>
<p>当我们需要<strong>为分散的对象引入公共行为</strong>的时候，OOP则显得无能为力。也就是说，<strong>OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系</strong>。例如日志功能。 </p>
<p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。 在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 </p>
<p>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封<strong>装成一个切面，然后注入到目标对象（具体业务逻辑）</strong>中去。AOP可以对某个对象或某些对象的功能<strong>进行增强</strong>，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情 。</p>
<h3 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h3><p>容器概念、控制反转、依赖注入</p>
<p><strong>ioc容器</strong>：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、 @repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的 bean节点，<strong>根据全限定类名使用反射</strong>创建对象放到map里、<strong>扫描到打上上述注解</strong>的类还是通过反射创建对象放到map里。 </p>
<p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再<strong>通过DI注入</strong>（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性 。根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。 </p>
<p><strong>控制反转：</strong> </p>
<p>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，<strong>自己必须主动去创建对象B</strong>或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 </p>
<p>引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，<strong>IOC容器会主动创建一个对象B注入到对象A需要的地方</strong>。 </p>
<p>通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，<strong>这就是“控制反转”这个名称的由来</strong>。 </p>
<p>全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种<strong>类似“粘合剂”的作用</strong>，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 </p>
<p><strong>依赖注入：</strong> </p>
<p>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程<strong>由自身管理变为了由IOC容器主动注入</strong>。<strong>依赖注入是实现IOC的方法</strong>：就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 </p>
<h3 id="BeanFactory和ApplicationContext有什么区别？⭐️"><a href="#BeanFactory和ApplicationContext有什么区别？⭐️" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？⭐️"></a>BeanFactory和ApplicationContext有什么区别？⭐️</h3><p><strong>ApplicationContext是BeanFactory的子接口</strong> </p>
<p>ApplicationContext提供了更完整的功能： </p>
<p>①继承MessageSource，因此支持国际化。 </p>
<p>②统一的资源文件访问方式。 </p>
<p>③提供在监听器中注册bean的事件。 </p>
<p>④同时加载多个配置文件。 </p>
<p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 </p>
<ul>
<li><p>BeanFactroy采用的是<strong>延迟加载形式来注入Bean</strong>的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。ApplicationContext，<strong>它是在容器启动时，一次性创建了所有的Bean</strong>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有<strong>利于检查所依赖属性是否注入</strong>。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。 </p>
</li>
<li><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是<strong>占用内存空间</strong>。当应用程序配置Bean较多时，<strong>程序启动较慢，但运行快</strong>。 </p>
</li>
<li><p>BeanFactory通常<strong>以编程的方式</strong>被创建，ApplicationContext还能<strong>以声明</strong>的方式创建，如<strong>使用ContextLoader</strong>。 </p>
</li>
<li><p>BeanFactory和ApplicationContext都支持<strong>BeanPostProcessor、BeanFactoryPostProcessor的使用</strong>，但两者之间的区别是：BeanFactory需要<strong>手动注册</strong>，而ApplicationContext则是<strong>自动注册</strong>。 </p>
</li>
</ul>
<h3 id="描述一下Spring-Bean的生命周期？⭐️"><a href="#描述一下Spring-Bean的生命周期？⭐️" class="headerlink" title="描述一下Spring Bean的生命周期？⭐️"></a>描述一下Spring Bean的生命周期？⭐️</h3><p>1、（扫描路径，找到类）<strong>解析类</strong>得到BeanDefinition </p>
<p>2、如果有多个构造方法，则要<strong>推断构造方法</strong> </p>
<p>3、确定好构造方法后，进行<strong>实例化</strong>得到一个Bean对象 </p>
<p>4、对对象中的加了@Autowired注解的属性<strong>进行属性填充</strong> </p>
<p>5、<strong>回调Aware方法</strong>，比如BeanNameAware，BeanFactoryAware</p>
<p>6、调用<strong>BeanPostProcessor的初始化前</strong>的方法 </p>
<p>7、调用<strong>初始化</strong>方法 </p>
<p>8、调用<strong>BeanPostProcessor的初始化后</strong>的方法，在这里会进行<strong>AOP</strong> </p>
<p>9、<strong>如果</strong>当前创建的<strong>bean是单例</strong>的则会把bean放入<strong>单例池</strong> </p>
<p>10、使用bean （运行期）</p>
<p>11、Spring容器关闭时调用DisposableBean中destory()方法 </p>
<h3 id="解释下Spring支持的几种bean的作用域。"><a href="#解释下Spring支持的几种bean的作用域。" class="headerlink" title="解释下Spring支持的几种bean的作用域。"></a><strong>解释下Spring支持的几种bean的作用域。</strong></h3><ul>
<li>singleton：默认，<strong>每个容器中只有一个bean的实例</strong>，<strong>单例模式</strong>由<strong>BeanFactory</strong>自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。 </li>
<li>prototype：<strong>为每一个bean（getBean()）请求提供一个实例</strong>。在每次注入时都会创建一个新的对象 ，容器中有多个实例</li>
<li>request：bean被定义为在<strong>每个HTTP请求中创建一个单例对象</strong>，也就是说在单个请求中都会复用这一个单例对象。 </li>
<li>session：与request范围类似，确保<strong>每个session中有一个bean</strong>的实例，在session过期后，bean会随之失效。 </li>
<li>application：bean被定义为在<strong>ServletContext</strong>的生命周期中<strong>复用一个单例对象</strong>。 </li>
<li>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</li>
</ul>
<p>global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。 </p>
<h3 id="Spring框架中的单例Bean是线程安全的么？"><a href="#Spring框架中的单例Bean是线程安全的么？" class="headerlink" title="Spring框架中的单例Bean是线程安全的么？"></a><strong>Spring框架中的单例Bean是线程安全的么？</strong></h3><p>不是。Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。 </p>
<ul>
<li><strong>有状态就是有数据存储功能</strong> ，<strong>如果Bean是有状态的</strong>， 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域 <strong>把 “singleton”改为’‘protopyte’</strong> 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了。 </li>
</ul>
<blockquote>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用<strong>Threadlocal为不同线程维护了独立的connection副本</strong>，保证线程之间不会互相影响（Spring 是如何保证事务获取同一个Connection的） </p>
</blockquote>
<ul>
<li><strong>无状态</strong>就是不会保存数据 controller、service和dao层本身<strong>并不是线程安全的</strong>，如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是<strong>自己的线程的工作内存，是安全的</strong>。 </li>
</ul>
<blockquote>
<p><strong>不要在bean中声明任何有状态的实例变量或类变量</strong>，如果必须如此，那么就使用<strong>ThreadLocal把变量变为线程私有的</strong>，如果bean的实例变量或类变量需要在<strong>多个线程之间共享</strong>，那么就只能使用<strong>synchronized、lock、CAS</strong>等这些实现线程同步的方法了。</p>
</blockquote>
<h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a><strong>Spring</strong> <strong>框架中都用到了哪些设计模式？</strong></h3><p>简单工厂：由一个工厂类<strong>根据传入的参数</strong>，动态决定应该创建哪一个产品类。</p>
<blockquote>
<p>Spring中的<strong>BeanFactory</strong>就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象**getBean()**，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 </p>
</blockquote>
<p>工厂方法： </p>
<blockquote>
<p>实现了FactoryBean接口的bean是一类叫做<strong>factory的bean</strong>。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个<strong>bean.getOjbect()方法的返回值</strong>。</p>
</blockquote>
<p>单例模式：保证一个类仅有一个实例，并提供一个<strong>访问它的全局访问点</strong> </p>
<blockquote>
<p>spring对单例的实现： spring中的单例模式完成了后半句话，即<strong>提供了全局的访问点BeanFactory</strong>。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。 </p>
</blockquote>
<p>适配器模式： </p>
<blockquote>
<p>Spring定义了一个适配接口<strong>HandlerAdapter</strong>，使得<strong>每一种Controller有一种对应的适配器实现类</strong>，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。 </p>
</blockquote>
<p>装饰器模式：动态地<strong>给一个对象添加一些额外的职责</strong>。就增加功能来说，Decorator模式相比生成子类更为灵活。 </p>
<blockquote>
<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有<strong>Wrapper</strong>，另一种是类名中含有<strong>Decorator</strong>。 </p>
</blockquote>
<p>动态代理： </p>
<blockquote>
<p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，<strong>AOP容器会为目标对象动态的创建一个代理对象</strong>。SpringAOP就是以这种方式织入切面的。 <strong>织入：把切面应用到目标对象并创建新的代理对象的过程</strong>。 </p>
</blockquote>
<p>观察者模式： </p>
<blockquote>
<p>spring的<strong>事件驱动模型</strong>使用的是观察者模式 ，Spring中Observer模式常用的地方是监听器listener的实现。 </p>
</blockquote>
<p>策略模式： </p>
<blockquote>
<p>Spring框架的<strong>资源访问Resource接口</strong>。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了Resource 接口来访问底层资源。 </p>
</blockquote>
<p>模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。 </p>
<blockquote>
<p>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。 </p>
<p>refresh方法</p>
</blockquote>
<h3 id="Spring事务的实现方式和原理以及隔离级别？⭐️"><a href="#Spring事务的实现方式和原理以及隔离级别？⭐️" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别？⭐️"></a><strong>Spring事务的实现方式和原理以及隔离级别？⭐️</strong></h3><p>在使用Spring框架时，可以有两种使用事务的方式，一种是<strong>编程式</strong>的，一种是<strong>申明式</strong>的，**@Transactional注解**就是申明式的。 </p>
<p>首先，<strong>事务这个概念是数据库层面的</strong>，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。 </p>
<p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。 </p>
<p>在一个方法上加了@Transactional注解后，Spring<strong>会基于这个类生成一个代理对象</strong>，会将这个代理对象作为<strong>bean</strong>，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的<strong>自动提交设置为false</strong>，然后再去执行原本的<strong>业务逻辑方法</strong>，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法<strong>出现了异常</strong>，那么则会将事务进行<strong>回滚</strong>。 </p>
<p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的<strong>rollbackFor属性</strong>进行配置，默认情况下会对RuntimeException和Error进行回滚。 </p>
<p><strong>spring事务隔离级别就是数据库的隔离级别</strong>：<strong>外加一个默认级别</strong> </p>
<ul>
<li><p>read uncommitted（未提交读） </p>
</li>
<li><p>read committed（提交读、不可重复读）orcal默认 </p>
</li>
<li><p>repeatable read（可重复读） mysql，spring默认</p>
</li>
<li><p>serializable（可串行化） 效率最低，级别最高</p>
</li>
</ul>
<p>数据库的配置隔离级别是Read Commited，而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准？ </p>
<p>以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库 </p>
<h3 id="spring事务传播机制⭐️"><a href="#spring事务传播机制⭐️" class="headerlink" title="spring事务传播机制⭐️"></a><strong>spring事务传播机制</strong>⭐️</h3><p>多个事务方法相互调用时,事务如何在这些方法间传播 ？</p>
<blockquote>
<p>方法A是一个事务的方法，方法<strong>A执行过程中调用了方法B</strong>，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法<strong>所定义的事务传播类型所决定</strong>。</p>
</blockquote>
<p>REQUIRED(Spring默认的事务传播类型)：如果当前(A)没有事务，则自己<strong>新建</strong>一个事务；如果当前存在事务，则<strong>加入</strong>这个事务。（一起成功一起失败）</p>
<p>SUPPORTS：如果当前<strong>没有</strong>事务，就以<strong>非事务方法</strong>执行；当前存在事务，则<strong>加入</strong>当前事务</p>
<p>MANDATORY：如果当前事务不存在，则<strong>抛出异常</strong>；当前存在事务，则<strong>加入</strong>当前事务</p>
<p>NEVER：如果当前事务不存在，<strong>不使用事务</strong>；如果当前事务存在，则<strong>抛出异常</strong> </p>
<p>REQUIRES_NEW：如果当前事务不存在，<strong>新建</strong>一个新事务，如果存在当前事务，则<strong>挂起</strong>该事务。 （A，B各自只处理自己的事务）</p>
<p>NOT_SUPPORTED：如果当前事务不存在，以<strong>非事务</strong>方式执行,如果当前存在事务，则<strong>挂起</strong>当前事务 </p>
<p>NESTED：如果当前事务不存在，<strong>新建</strong>一个事务；如果当前事务存在，则在<strong>嵌套事务</strong>中执行。</p>
<p>和REQUIRES_NEW的区别 </p>
<blockquote>
<p><strong>NESTED</strong>则是<strong>当前存在事务</strong>时（我们把当前事务称之为父事务）会开启一个<strong>嵌套事务</strong>（称之为一个子事务）。 在NESTED情况下<strong>父事务回滚时， 子事务也会回滚</strong>。</p>
<p>REQUIRES_NEW是<strong>新建一个事务并且新开启的这个事务与原有事务无关</strong>。在REQUIRES_NEW情况下，<strong>原有事务回滚，不会影响新开启的事务</strong>。 </p>
</blockquote>
<p>和REQUIRED的区别 </p>
<blockquote>
<p>在<strong>NESTED</strong>情况下，被调用方发生异常时，调用方<strong>可以catch其异常，这样只有子事务回滚，父事务不受影响</strong>。</p>
<p><strong>REQUIRED</strong>情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，<strong>由于共用一个事务</strong>，所以<strong>无论调用方是否catch其异常，事务都会回</strong>滚。</p>
</blockquote>
<h3 id="spring事务什么时候会失效"><a href="#spring事务什么时候会失效" class="headerlink" title="spring事务什么时候会失效?"></a><strong>spring事务什么时候会失效?</strong></h3><p><strong>spring事务的原理是AOP</strong>，进行了切面增强，那么失效的根本原因是这个AOP不起作用（getBean获取代理类）了！常见情况有如下几种 </p>
<p>1、发生<strong>自调用</strong>，类里面使用this调用本类的方法（this通常省略），此时这个this对象<strong>不是代理类</strong>，而是UserService对象本身！ 默认<strong>只有在外部调用事务</strong>才会生效</p>
<p>解决方法很简单，让那个this变成<strong>UserService的代理类</strong>即可！ </p>
<p>2、方法<strong>不是public</strong>的 </p>
<p>@Transactional 只能用于 public 的方法上，否则事务不会失效</p>
<blockquote>
<p>如果要用在非 public 方法上，可以开启 AspectJ 代理模式。 </p>
</blockquote>
<p>3、数据库引擎本身<strong>不支持事务</strong>(例如：Myisam)</p>
<p>4、 <strong>数据源没有配置事务管理器</strong></p>
<p>5、<strong>没有被spring管理</strong> (类没有放在Spring容器)</p>
<p>6、异常被吃掉**(Catch)，事务不会回滚**(或者<strong>抛出的异常没有被定义</strong>，默认为<strong>RuntimeException</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// update order</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">					<span class="comment">//1.没有抛出异常</span></span><br><span class="line">          <span class="comment">//2.throw new Exception(&quot;更新错误&quot;);也是错的，默认为RuntimeException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是bean的自动装配，有哪些方式？"><a href="#什么是bean的自动装配，有哪些方式？" class="headerlink" title="什么是bean的自动装配，有哪些方式？"></a><strong>什么是bean的自动装配，有哪些方式？</strong></h3><p>开启自动装配，只需要在xml配置文件中<strong>定义“autowire”属性</strong>。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cutomer&quot; class=&quot;com.xxx.xxx.Customer&quot; autowire=&quot;&quot; /&gt; </span><br></pre></td></tr></table></figure>

<p>autowire属性有五种装配的方式： </p>
<ul>
<li>no – 缺省情况下，自动配置是通过<strong>“ref”属性</strong>手动设定 。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">手动装配：以value或ref的方式明确指定属性值都是手动装配。 </span><br><span class="line">需要通过‘ref’属性来连接bean。</span><br></pre></td></tr></table></figure>

<ul>
<li>byName-根据bean的<strong>属性名称</strong>进行自动装配。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>/&gt; </span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li>byType-根据bean的<strong>类型</strong>进行自动装配。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。 </span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>/&gt; </span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li>constructor-<strong>类似byType</strong>，不过是<strong>应用于构造器的参数</strong>。如果一个bean<strong>与构造器参数的类型形同</strong>，则进行自动装配，否则导致异常。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装配。</span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;construtor&quot;</span>/&gt; </span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li>autodetect-如果有<strong>默认的构造器</strong>，则通过constructor方式进行自动装配，<strong>否则使用byType方式</strong>进行自动装配。 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。 </span><br></pre></td></tr></table></figure>

<p>通过注解 @Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。 </p>
<h2 id="springmvc、springBoot"><a href="#springmvc、springBoot" class="headerlink" title="springmvc、springBoot"></a><strong>springmvc、springBoot</strong></h2><h3 id="springboot-约定优于配置这个问题"><a href="#springboot-约定优于配置这个问题" class="headerlink" title="springboot 约定优于配置这个问题?"></a>springboot 约定优于配置这个问题?</h3><p>首先，约定优于配置是一种软件设计的范式，它的核心思想是减少软件开发人员对于配置项的维护，从而让开发人员更加具交在业务逻辑上。<br>第二个，spring boot 就是约定优于配置这一理念下的产物，它类似于 spring 框架下的一个脚手架，通过 spring boot 我们可以快速开发基于 spring 生态下的应用程序。<br>第三个，基于传统的 spring 框架开发 web 应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如第一个，管理Jar包的依赖。第二个，web.xml 的维护。第三个， spring MVC 中的一个叫 dispatch servlet.xml 配置项的一个维护。第四个，应用需要自己手动去部署到 web 容器。第五个，第三方组件集成到 spring IoC 容器中的时候，我们需要做配置项的维护。而在 spring boot 中，我们不再需要去做这些繁琐的配置，因为 spring boot 已经帮我们自动完成了。而完成这样一个动作的前提就是基于约定优于配置这样一个思想。<br>最后，spring bbot约定优于配置的体现有很多，比如第一个， springboot starter 启动依赖，它能够帮助我们管理所有的Jar包版本。第二个，如果当前的应用依赖了 web 这样一个Jar包，那么 spring bot 会自动内置Tomcat容器来去运行 web 应用，我们不再需要去单独进行应用部署。<br>第三， springboot 的自动装配机制的实现中，通过扫描约定路径下的 spring. factory 文件去进行识别配置类，从而去实现Bean的自动装载。<br>第四， springboot 默认会加载 resource 目录下的 application.property 文件。总的来说，约定优于配置是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效以及更加便捷地去实现软件系统的开发和维护。以上就是我对于这个问题的理解。</p>
<h3 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别"></a><strong>Spring Boot、Spring MVC</strong> <strong>和</strong> <strong>Spring</strong> <strong>有什么区别</strong></h3><p>Spring是一个<strong>轻量级</strong>的<strong>控制反转（IoC)和面向切面（AOP）</strong>的<strong>容器 框架</strong> 。spring是<strong>一个IOC容器，用来管理Bean，使用依赖注入实现控制反转</strong>，可以很方便的<strong>整合各种框架</strong>，提供<strong>AOP机制</strong>弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等 </p>
<p>springmvc是<strong>spring对web框架的一个解决方案或设计理念</strong>，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端 </p>
<p>springboot是spring提供的一个快速开发工具包，其实就是Spring，它做了一些对Spring Bean的默认配置。让程序员能更方便、更快速的开发spring+springmvc 应用，<strong>简化了配置</strong>（约定了默认配置）<strong>，整合了一系列的解决方案</strong>（starter机制）、redis、 mongodb、es，核心理念：开箱即用，快速启动</p>
<h3 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a><strong>SpringMVC</strong> <strong>工作流程</strong></h3><p>1）用户发送请求至<strong>前端控制器 DispatcherServlet</strong>。 </p>
<p>2）DispatcherServlet 收到请求<strong>调用 HandlerMapping 处理器映射器</strong>。</p>
<blockquote>
<p>维护&lt;url，handler&gt;的映射</p>
</blockquote>
<p>3）处理器映射器找到<strong>具体的处理器</strong>(可以根据 <strong>xml 配置、注解</strong>进行查找)，<strong>生成处理器Handler及处理器拦截器</strong> (如果有则生成)一并<strong>返回给 DispatcherServlet</strong>。 </p>
<p>4）DispatcherServlet <strong>调用 HandlerAdapter 处理器适配器执行Handler</strong>。 </p>
<blockquote>
<p>适配器模式：HandlerAdapter会根据handler规则执行不同类型的handler</p>
</blockquote>
<p>5）HandlerAdapter <strong>经过适配执行具体的handler</strong>(Controller，也叫<strong>后端控制器</strong>) </p>
<p>6） handler执行完成<strong>返回 ModelAndView</strong>。 </p>
<p>7）HandlerAdapter 将 handler 执行结果 <strong>ModelAndView 返回给 DispatcherServlet</strong>。</p>
<p>8） DispatcherServlet 将 ModelAndView 传给 <strong>ViewReslover 视图解析器</strong>。 </p>
<p>9）ViewReslover <strong>解析后返回具体 View</strong>。 </p>
<p>10）DispatcherServlet 根据 View <strong>进行视图渲染</strong>（即将模型数据填充至视图中）。 </p>
<p>11）DispatcherServlet <strong>响应用户</strong>。</p>
<p><img src="/2021/01/02/1.5.2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SSM%EF%BC%8CSpringBoot/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4ODM1NQ==,size_16,color_FFFFFF,t_70.jpeg" alt="springmvc工作流程图"></p>
<h3 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a><strong>Spring MVC的主要组件？</strong></h3><p><strong>Handler</strong>：也就是处理器。它直接应对着MVC中的C也就是<strong>Controller</strong>层，它的具体表现形式有很多，<strong>可以是类，也可以是方法</strong>。在Controller层中**@RequestMapping标注**的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler </p>
<p>1、HandlerMapping 🀄️接口</p>
<p>initHandlerMappings(context)，处理器映射器，<strong>根据用户请求的资源uri来查找Handler的</strong>。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是HandlerMapping需要做的事。 </p>
<blockquote>
<p>URL：Bean id；Key,value；注解</p>
</blockquote>
<p>2、HandlerAdapter 🀄️接口</p>
<p>initHandlerAdapters(context)，适配器。因为<strong>SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok（@ReqeustMapping,Conroller接口,HttpRequestHandler,HttpServlet）</strong>，但是<strong>Servlet需要的处理方法的结构却是固定的</strong>，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。 </p>
<p>Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人。</p>
<p>3、HandlerExceptionResolver </p>
<p>initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是<strong>根据异常设置ModelAndView，之后再交给render方法进行渲染</strong>。 </p>
<p>4、ViewResolver </p>
<p>initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver主要要做的工作，<strong>ViewResolver需要找到渲染所用的模板和所用的技术</strong>（也就是视图的类型）<strong>进行渲染</strong>，具体的渲染过程则交由不同的视图自己完成。 </p>
<p>5、RequestToViewNameTranslator </p>
<p>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的 Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。 </p>
<p>RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到 ViewName的转换规则都要在一个Translator里面全部实现。 </p>
<p>6、LocaleResolver </p>
<p>initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到<strong>国际化资源或者主题的</strong>时候。 </p>
<p>7、ThemeResolver </p>
<p>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，<strong>同一个主题不同区域也可以显示不同的风格</strong>。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource 和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这 是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是 ThemeSource的工作。最后从主题中获取资源就可以了。 </p>
<p>8、MultipartResolver </p>
<p>initMultipartResolver(context)，<strong>用于处理上传请求</strong>。处理方法是将普通的request包装成 MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。 </p>
<p>9、FlashMapManager </p>
<p>initFlashMapManager(context)，用来<strong>管理FlashMap</strong>的，FlashMap主要用在<strong>redirect中传递参数</strong>。 </p>
<h3 id="Spring-Boot启动过程"><a href="#Spring-Boot启动过程" class="headerlink" title="Spring Boot启动过程"></a>Spring Boot启动过程</h3><h3 id="Spring-Boot-自动配置原理？"><a href="#Spring-Boot-自动配置原理？" class="headerlink" title="Spring Boot 自动配置原理？"></a><strong>Spring Boot</strong> <strong>自动配置原理？</strong></h3><p>@Import + @Configuration + Spring spi(服务提供者接口)</p>
<ul>
<li>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META INF/spring.factories下 </li>
<li>使用Spring spi扫描META-INF/spring.factories下的配置类 </li>
<li>使用@Import导入自动配置类 </li>
</ul>
<p><img src="/2021/01/02/1.5.2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SSM%EF%BC%8CSpringBoot/image-20220213224439725.png" alt="image-20220213224439725"></p>
<blockquote>
<p> @SpringBootConfiguration：标记当前类为配置类<br> @EnableAutoConfiguration：开启自动配置<br> @ComponentScan：扫描<strong>主类</strong>所在的同级包以及下级包里的Bean<br> <strong>关键是@EnableAutoConfiguration</strong></p>
<p> <strong>AutoConfigurationImportSelector</strong>中的方法<strong>getCandidateConfigurations</strong>，得到待配置的class的类名集合,这个集合就是所有需要进行自动配置的类，而是是否配置的关键在于META-INF/spring.factories文件中是否存在该配置信息。</p>
</blockquote>
<p><img src="/2021/01/02/1.5.2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SSM%EF%BC%8CSpringBoot/image-20220214115219963.png" alt="image-20220214115219963"></p>
<h3 id="如何理解-Spring-Boot-中的-Starter"><a href="#如何理解-Spring-Boot-中的-Starter" class="headerlink" title="如何理解 Spring Boot 中的 Starter"></a><strong>如何理解</strong> <strong>Spring Boot</strong> <strong>中的</strong> <strong>Starter</strong></h3><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean ，而starter可以避免繁琐的配置</p>
<p>starter就是定义一个starter的jar包，<strong>写一个@Configuration配置类</strong>、将这些bean定义在里面，然后在 starter包的META-INF/spring.factories中写入该配置类，springboot会按照约定来加载该配置类</p>
<p>开发人员只需要在maven中引入starter依赖，进行相应的属性配置（使用默认配置（该配都帮忙配了）时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，springboot-starter-redis </p>
<h3 id="什么是嵌入式服务器？为什么要使用嵌入式服务器"><a href="#什么是嵌入式服务器？为什么要使用嵌入式服务器" class="headerlink" title="什么是嵌入式服务器？为什么要使用嵌入式服务器?"></a><strong>什么是嵌入式服务器？为什么要使用嵌入式服务器?</strong></h3><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行。</p>
<p>只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了 </p>
<p>springboot已经<strong>内嵌了tomcat.jar</strong>，运行main方法时会去启动tomcat，并利用tomcat的<strong>spi机制</strong>加载springmvc</p>
<h3 id="JPA？"><a href="#JPA？" class="headerlink" title="JPA？"></a>JPA？</h3><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><strong>Mybatis</strong></h2><h3 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a><strong>mybatis的优缺点</strong></h3><p>优点： </p>
<p>1、<strong>基于 SQL 语句编程，相当灵活</strong>，不会对应用程序或者数据库的现有设计造成任何影响，<strong>SQL 写在XML里，解除 sql 与程序代码的耦合</strong>，便于统一管理；提供 XML标签， 支持编写动态 SQL 语句， 并可重用。 </p>
<p> 2、<strong>与 JDBC 相比，减少了 50%以上的代码量</strong>，消除了 JDBC 大量冗余的代码，不需要手动开关连接； </p>
<p> 3、<strong>很好的与各种数据库兼容</strong>（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库MyBatis 都支持）。 </p>
<p> 4、能够<strong>与 Spring 很好的集成</strong>； </p>
<p> 5、提供<strong>映射标签</strong>， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。 </p>
<p>缺点： </p>
<p> 1、<strong>SQL 语句的编写工作量较大</strong>， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。 </p>
<p> 2、<strong>SQL 语句依赖于数据库， 导致数据库移植性差</strong>， 不能随意更换数据库。 </p>
<h3 id="和-的区别是什么？⭐️"><a href="#和-的区别是什么？⭐️" class="headerlink" title="#{}和${}的区别是什么？⭐️"></a><strong>#{}和${}的区别是什么？⭐️</strong></h3><p>（1） #{}是预编译处理、是<strong>占位符</strong>， ${}是字符串替换、是<strong>拼接符</strong>。</p>
<p>（2）Mybatis 在处理#{}时，会将 sql 中的#{}替换为**?号<strong>，调用</strong>PreparedStatement<strong>来赋值；<br>Mybatis 在处理${}， 将其替换成</strong>变量的值**，调用 <strong>Statement</strong>来赋值；</p>
<p>（3）#{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量自动加上<strong>单引号</strong></p>
<p>${}的变量替换是在 DBMS 外，变量替换后，对应的变量不会加上单引号<br><strong>使用#{}可以有效的防止 SQL 注入</strong>， 提高系统安全性。 </p>
<h3 id="简述-Mybatis-的插件（拦截器）运行原理，如何编写一个（分页）插件。"><a href="#简述-Mybatis-的插件（拦截器）运行原理，如何编写一个（分页）插件。" class="headerlink" title="简述 Mybatis 的插件（拦截器）运行原理，如何编写一个（分页）插件。"></a><strong>简述</strong> <strong>Mybatis</strong> <strong>的插件（拦截器）运行原理，如何编写一个（分页）插件。</strong></h3><p>答： Mybatis 只支持针对 <strong>ParameterHandler(参数类型转换)、ResultSetHandler(对应JDBC)、StatementHandler(对应JDBC)、Executor（执行器，生成SQL语句，查询缓存）</strong> 这4 种接口的插件， Mybatis <strong>使用 JDK 的动态代理</strong>， 为需要拦截的接口生成代理对象以<strong>实现接口方法拦截功能</strong>， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <strong>InvocationHandler 的</strong> <strong>invoke() 方法</strong>， 拦截那些你指定需要拦截的方法。 </p>
<p><strong>编写插件：</strong> <strong>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法</strong>，然后在给插件<strong>编写注解</strong>， <strong>指定要拦截哪一个接口的哪些方法</strong>即可， 在<strong>配置文件中配置</strong>编写的插件。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//intercept方法里面有一个参数invocation（通过invocation可以获取拦截方法的数据）</span></span><br><span class="line"><span class="comment">//StatementHandler接口，query就是拦截的方法</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;), </span></span><br><span class="line"><span class="meta">	@Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;), </span></span><br><span class="line"><span class="meta">  @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123; Statement.class &#125;)&#125;)</span> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//前面写一些代码</span></span><br><span class="line">invocation.proceed()执行具体的业务逻辑 </span><br><span class="line"><span class="comment">//后面写一些代码</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6.0并发编程</title>
    <url>/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="对线程安全的理解"><a href="#对线程安全的理解" class="headerlink" title="对线程安全的理解"></a><strong>对线程安全的理解</strong></h3><p>当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果(预期结果或单线程的结果)，我们就说这个对象是线程安全的。</p>
<p>线程安全其实本质上是<strong>内存安全</strong>，JVM中的堆是共享内存，<strong>可以被所有线程访问</strong> ，这就会有线程并发安全的问题</p>
<span id="more"></span>

<blockquote>
<p><strong>堆</strong>是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配给用户的空间，局部堆就是用户分配的空间。堆在操作系统对<strong>进程初始化</strong>的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。 </p>
<blockquote>
<p>在Java中，堆是Java虚拟机所管理的内存中<strong>最大的一块</strong>，是<strong>所有线程共享</strong>的一块内存区域，在虚拟机<strong>启动时创建</strong>。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 </p>
</blockquote>
<p><strong>栈</strong>是每个线程<strong>独有的</strong>，保存其<strong>运行状态和局部自动变量的</strong>。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候<strong>会自动切换栈</strong>。栈空间不需要在高级语言里面显式的分配和释放。</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul>
<li>加锁排队执行，比如：使用sychronized加锁，使用ReentrantLock加锁</li>
</ul>
<blockquote>
<p>sychronized是JVM层的自动加锁和释放锁的同步锁</p>
<p>ReentrantLock需要程序员自己加锁和释放锁</p>
</blockquote>
<ul>
<li>使用线程安全类，比如AutomicInteger</li>
</ul>
<blockquote>
<p>将++ —变为一个原子操作</p>
</blockquote>
<ul>
<li>使用线程本地变量ThreadLocal</li>
</ul>
<blockquote>
<p>每一个线程都有自己的一个私有变量，不同线程操作的是不同变量，也就不会产生线程安全问题。</p>
</blockquote>
<h3 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a><strong>对守护线程的理解</strong></h3><p>用户线程：默认情况我们创建的线程或线程池都是用户线程</p>
<p>守护线程：<strong>为所有非守护线程提供服务的线程</strong>；任何一个守护线程都是<strong>整个JVM中所有非守护线程的保姆</strong>； </p>
<p>通过Thraed.isDaemon()查看是否为守护线程。</p>
<p>守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；  由于<strong>守护线程的终止是自身无法控制的</strong>，因此千万不要把IO、File等重要操作逻辑分配给它；因为它不靠谱，<strong>随时可能退出（</strong>守护线程<strong>不能用于去访问固有资源</strong>，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。）</p>
<p><strong>守护线程的作用是什么？</strong> </p>
<p>举例， <strong>GC垃圾回收线程</strong>：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于<strong>实时监控和管理系统中的可回收资源</strong>。 </p>
<p><strong>应用场景：</strong>来为其它线程提供服务支持的情况（说心跳检测，事件监听，GC垃圾回收线程等）。</p>
<p><strong>PS：</strong>（1）<strong>thread.setDaemon(true)必须在thread.start()之前设置</strong>，否则会跑出一个 </p>
<p>IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 </p>
<p>（2）在Daemon线程中产生的新线程也是Daemon的。 </p>
<p>（3）Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以<strong>如果要使用后台线程就不能用Java的线程池</strong>。</p>
<h3 id="并发、并行、串行的区别"><a href="#并发、并行、串行的区别" class="headerlink" title="并发、并行、串行的区别"></a><strong>并发、并行、串行的区别</strong></h3><ul>
<li>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着 </li>
<li>并行在时间上是重叠的，两个任务在<strong>同一时刻互不干扰</strong>的同时执行。 </li>
<li>并发允许两个任务彼此干扰。同一时刻、只有一个任务运行，交替执行</li>
</ul>
<h3 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a><strong>并发的三大特性</strong></h3><p><strong>（1）　原子性</strong></p>
<ul>
<li><p>原子性是指在一个操作中<strong>cpu不可以在中途暂停然后再调度</strong>，即<strong>不被中断操作</strong>，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元， 往账户B加上1000元。2个操作必须全部完成。 </p>
</li>
<li><p>举个例子：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>1：将 count 从<strong>主存读到线程中的工作内存的副本</strong>中 </li>
<li>2：+1的运算 </li>
<li>3：将结果写入工作内存 </li>
<li>4：将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的) </li>
</ul>
<p>那程序中原子性指的是最小的操作单元，比如自<strong>增操作，它本身其实并不是原子性操作，分了3步的， 包括读取变量的原始值、进行加1操作、写入工作内存</strong>。前3步是原子性不能够保证线程安全，由于第4步。（即使第4步是原子性的，也不能保证线程安全）</p>
<p><strong>关键字：</strong>synchronized ，（CAS）</p>
<p><strong>（2）可见性</strong>  </p>
<ul>
<li><p><strong>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong>。 </p>
</li>
<li><p>例子：若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改，其他线程没看到这就是可见性问题。（第3，4步是原子操作，但还不是线程安全）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1 </span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>; </span><br><span class="line"><span class="keyword">while</span>(!stop)&#123; </span><br><span class="line">doSomething(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2 </span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是<strong>还没来得及写入主存当中，线程2转去做其他事情了</strong>，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 </p>
<p><strong>关键字：</strong>volatile、synchronized、final </p>
<blockquote>
<p>原子性CAS与可见性volatile保证线程安全</p>
</blockquote>
<p><strong>（3）有序性</strong> </p>
<ul>
<li>虚拟机在进行代码编译时，<strong>单线程下，对于那些改变顺序之后不会对最终结果造成影响的代码</strong>，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们<strong>重排序</strong>。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有<strong>可能会出现线程安全问题</strong>。 </li>
<li>例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">bool flag = <span class="keyword">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  a = <span class="number">2</span>; <span class="comment">//1 </span></span><br><span class="line">  flag = <span class="keyword">true</span>; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;<span class="comment">//3 </span></span><br><span class="line">  	<span class="keyword">int</span> ret = a * a;<span class="comment">//4 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步 </p>
</blockquote>
<p><strong>关键字：</strong>volatile、synchronized (禁止指令重排序)</p>
<blockquote>
<p>synchronized关键字同时满足以上三种特性，但是<strong>volatile关键字不满足原子性</strong>。 </p>
<p>在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或 java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。 我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性)</p>
</blockquote>
<h2 id="一-三大类"><a href="#一-三大类" class="headerlink" title="(一) 三大类"></a>(一) 三大类</h2><p>1.并发安全</p>
<p>底层角度：</p>
<ul>
<li><p>互斥同步</p>
</li>
<li><p>非互斥同步</p>
</li>
<li><p>结合互斥同步和非互斥同步（效率和安全的平衡）</p>
</li>
<li><p>无同步方案</p>
</li>
</ul>
<p>使用者角度：</p>
<ul>
<li>避免共享变量</li>
<li>共享变量，但加锁或final</li>
<li>使用成熟工具类</li>
</ul>
<p>2.线程管理（提高效率）</p>
<p>线程池相关类</p>
<p>能获取子线程的运行结果的相关类</p>
<p>3.线程协作</p>
<p>AQS</p>
<h2 id="二-线程池"><a href="#二-线程池" class="headerlink" title="(二) 线程池"></a>(二) 线程池</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p><code>池理解为计划经济。资源有限，池就是要管理好资源。</code></p>
<p><strong>为什么用线程池</strong></p>
<blockquote>
<p>1、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。 </p>
<p>2、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。 </p>
<p>3、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。 </p>
</blockquote>
<h3 id="2-处理流程，创建，停止，复用，判断是否完成"><a href="#2-处理流程，创建，停止，复用，判断是否完成" class="headerlink" title="2.处理流程，创建，停止，复用，判断是否完成"></a>2.处理流程，创建，停止，复用，判断是否完成</h3><h4 id="2-1构造函数的6大核心参数"><a href="#2-1构造函数的6大核心参数" class="headerlink" title="2.1构造函数的6大核心参数"></a><strong>2.1构造函数的6大核心参数</strong></h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20211231210225294.png" alt="image-20211231210225294"></p>
<p><strong>添加线程规则</strong></p>
<blockquote>
<p>源码在:ThreadPoolExecutor中的execute函数</p>
</blockquote>
<h4 id="2-2线程池处理流程⭐️"><a href="#2-2线程池处理流程⭐️" class="headerlink" title="2.2线程池处理流程⭐️"></a><strong>2.2线程池处理流程⭐️</strong></h4><p>线程池初始时为空，任务来了再创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）线程数 &lt; corePoolSize，即使其他工作线程空闲，也会创建一个新线程来运行新任务。</span><br><span class="line">（2）线程数&gt;=corePoolSize，&lt;maxPoolSize，将任务放入workQueue中（希望保持较少的线程数）</span><br><span class="line">（3）工作队列已满，线程数&lt;maxPoolSize，则创建1个新线程</span><br><span class="line">（4）队列已满，线程数&gt;=maxPoolSize，拒绝该任务。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20211231211213193.png" alt="image-20211231211213193"></p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426165904228.png" alt="image-20220426165904228"></p>
<p><strong>KeepAliveTime</strong></p>
<p>线程数 &gt; corePoolSize，多余的线程空闲时间超过KeepAliveTime就会被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keepAliveTime设置成负数或者是0，表示无限阻塞？</span><br><span class="line"></span><br><span class="line">答：这种是不对的，如果 keepAliveTime 设置成负数，在线程池初始化时，就会直接报 IllegalArgumentException 的异常，而设置成 0，队列如果是 LinkedBlockingQueue 的话，执行workQueue.poll (keepAliveTime, TimeUnit.NANOSECONDS) 方法时，如果队列中没有任务，会直接返回 null，导致线程立马返回，不会无限阻塞。 </span><br><span class="line"></span><br><span class="line">如果想无限阻塞的话，可以把 keepAliveTime 设置的很大，把 TimeUnit 也设置的很大，接近于无限阻塞。</span><br><span class="line"></span><br><span class="line">对于线程空闲回收的理解？</span><br><span class="line">空闲线程回收的时机：如果线程超过 keepAliveTime 时间后，还从阻塞队列中拿不到任务</span><br><span class="line">（这种情况我们称为线程空闲），当前线程就会被回收，如果 allowCoreThreadTimeOut 设置成true，core thread 也会被回收，直到还剩下一个线程为止，如果 allowCoreThreadTimeOut 设置成 false，只会回收非 core thread 的线程。</span><br><span class="line">线程在任务执行完成之后，之所有没有消亡，是因为阻塞的从队列中拿任务，在 keepAliveTime 时间后都没有拿到任务的话，就会打断阻塞，线程直接返回，线程的生命周期就结束了，JVM 会回收掉该线程对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说一说线程执行任务之后，都在干啥？</span><br><span class="line">答：线程执行任务完成之后，有两种结果： </span><br><span class="line">\1. 线程会阻塞从队列中拿任务，没有任务的话无限阻塞； </span><br><span class="line">\2. 线程会阻塞从队列中拿任务，没有任务的话阻塞一段时间后，线程返回，被 JVM 回收。</span><br></pre></td></tr></table></figure>

<p><strong>ThreadFactory</strong></p>
<p>使用默认就可以了</p>
<p><strong>workQueue</strong>⭐️</p>
<p>1）直接交接：SychronousQueue（队列大小为0，不能存任务，此时应使用大的maxPoolSize，因为没有队列作为缓冲）</p>
<p>2）无界队列：LinkedBlockingQueue（<strong>如果处理跟不上任务提交速度，任务越来越多，会造成oom异常</strong>）</p>
<p>3）有界队列：ArrayBlockingQueue，用得少</p>
<p>4）优先级队列：PriorityBlockingQueue ，用得少</p>
<p><strong>拒绝策略</strong></p>
<p><strong>（1）拒绝时机</strong></p>
<p>1.线程池（Executor）关闭时</p>
<p>2.workQueue，maxPoolSize都饱和了</p>
<p><strong>（2）4种拒绝策略</strong>⭐️</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:<strong>丢弃任务并抛出</strong>RejectedExecutionException异常。 </li>
<li>ThreadPoolExecutor.DiscardPolicy：<strong>丢弃任务，但是不抛出异常</strong>。 </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：<strong>丢弃队列最前面的任务</strong>，然后<strong>重新提交</strong>被拒绝的任务 </li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务，（<strong>自己提交自己处理</strong>）</li>
</ul>
<p><strong>（3）线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？</strong> </p>
<p>答：可以自定义的，线程创建默认使用的是 DefaultThreadFactory，自定义话的只需要<strong>实现 ThreadFactory 接口</strong>即可；拒绝请求也是可以自定义的，实现<strong>RejectedExecutionHandler 接口</strong>即 可；在 <strong>ThreadPoolExecutor</strong> 初始化时，将两个自定义类作为构造器的入参传递给 ThreadPoolExecutor 即可。</p>
<h4 id="2-3常见线程池以及创建⭐️"><a href="#2-3常见线程池以及创建⭐️" class="headerlink" title="2.3常见线程池以及创建⭐️"></a><strong>2.3常见线程池以及创建</strong>⭐️</h4><ul>
<li><p><strong>Executors</strong>自动创建线程池，会有OOM异常的风险，</p>
</li>
<li><p>使用<strong>ThreadPoolExecutor</strong>手<strong>动的方式创建线程池（推荐）</strong>，因为这种方式可以通过参数来<strong>控制最大线程数和拒绝策略</strong>，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。</p>
</li>
</ul>
<p><strong>自动创建</strong></p>
<p>1）newFixedThreadPool：固定线程数，采用<strong>LinkedBlockingQueue</strong>，KeepAliveTime=0</p>
<blockquote>
<p>队列占用内存太多，会出现OOM</p>
</blockquote>
<p>2）newSingleThreadExecutor：单线程，采用<strong>LinkedBlockingQueue</strong>，KeepAliveTime=0</p>
<blockquote>
<p>队列占用内存太多，会出现OOM</p>
</blockquote>
<p>3）newCachedThreadPool：<strong>SychronousQueue</strong>，KeepAliveTime=60，corePoolSize=0,<strong>maxPoolSize无限</strong><br>无界线程池，<strong>具有自动回收多余线程</strong>的功能</p>
<blockquote>
<p>创建非常多的线程，会出现OOM</p>
</blockquote>
<p>4）newScheduledThreadPool：周期性执行，DelayedWorkQueue，KeepAliveTime=60，maxPoolSize无限</p>
<blockquote>
<p>Scheduled方法，只执行一次定时任务，（传入任务，多久后执行，单位）</p>
<p>ScheduledAtFixedRate，执行多次定时任务（传入任务，多久后开始执行定时任务，执行时间间隔，单位）每间隔一段时间执行定时任务</p>
<p>ScheduledWithFixedDelay，执行多次定时任务（传入任务，多久后开始执行，执行时间间隔，单位），不同之处：等任务执行完成后，间隔一段时间再执行</p>
</blockquote>
<p>5）newSingleScheduledThreadPool</p>
<p>6）workStealingPool（JDK1.8）少用</p>
<blockquote>
<p>多个子任务：每个任务都有自己的队列，其他线程可以帮助完成，抢占式的。<br>任务：不加锁，执行顺序不能保证</p>
<p>应用场景：递归</p>
</blockquote>
<h4 id="Executor工具框架"><a href="#Executor工具框架" class="headerlink" title="Executor工具框架"></a><strong>Executor工具框架</strong></h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220101104717826.png" alt="image-20220101104717826"></p>
<blockquote>
<ol>
<li><p>定义任务类：Runnable、Callable、FutureTask。Runnable 是定义无返回值的任务， Callable 是定义有返回值的任务，FutureTask 是对 Runnable 和 Callable 两种任务的统一， 并增加了对任务的管理功能； </p>
</li>
<li><p>执行任务类：ThreadPoolExecutor、Executor、ExecutorService。Executor 定义最基本的运行接口，ExecutorService 是对其功能的补充，ThreadPoolExecutor 提供<strong>真正可运行的线程 池类</strong>，三个类定义了任务的运行机制。</p>
</li>
</ol>
</blockquote>
<h4 id="两个提交任务"><a href="#两个提交任务" class="headerlink" title="两个提交任务"></a>两个提交任务</h4><p>execute() VS submit()</p>
<ul>
<li>execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、Runnable两种类型的参数。</li>
<li>execute()提交任务后会没有返回值，而submit()有</li>
<li>execute()任务的执行结果和可能的异常调用者并不关心；submit()方便Exception处理</li>
</ul>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a><strong>Future</strong></h4><blockquote>
<p>作用：通过 Future 去控制子线程执行的计算过程,最后获取到计算结果</p>
</blockquote>
<p>get()：线程池不会直接抛出异常，只有future.get()才会抛出（只抛ExecutionException）</p>
<blockquote>
<p>任务5种状态：</p>
<p>任务正常完成</p>
<p>任务尚未完成：get将阻塞并直到任务完成</p>
<p>任务执行过程中抛出ExecutionException</p>
<p>任务取消CallcellationException</p>
<p>任务超时TimeoutExceptionget</p>
</blockquote>
<p>get(long,Timeunit)</p>
<p>Cancel()：true：中断当前任务</p>
<p>isDone()：任务是否完成（不管是否抛异常）</p>
<p>isCancelled()</p>
<p><strong>Future创建方式</strong></p>
<ul>
<li>线程池的submit返回Future对象</li>
</ul>
<p>submit()方法自身并不会传递结果，而是返回一个Future异步执行实例（一开始为空），<strong>处理过程的结果被包装到Future实例</strong>中，调用者可以通过Future.get()方法获取异步执行的结果。实际上是 FutureTask.get ，其方法底层是从 FutureTask  的 outcome 属性拿值的</p>
<ul>
<li>FutureTask创建Future对象</li>
</ul>
<p>创建callable的task，将task传入futureTask，提交到线程池，通过futureTask.get()</p>
<p><strong>注意</strong></p>
<p>for循环get()，会出现部分线程执行慢的情况，可以调用get(long,timeout)，超时丢弃任务</p>
<p>使用<em>CompleteFuture</em>，某个子任务执行完，可以立即得到结果</p>
<h4 id="2-4线程数量的选择"><a href="#2-4线程数量的选择" class="headerlink" title="2.4线程数量的选择"></a><strong>2.4线程数量的选择</strong></h4><p>（1）定性</p>
<ul>
<li><p>根据业务进行考虑，初始化线程池时，我们需要考虑所有业务涉及的线程池，如果目前所有 的业务同时都有<strong>很大流量</strong>，那么在对于当前业务设置线程池时，我们尽量把<strong>线程大小、队列 大小都设置小</strong>，如果所有业务基本上都不会同时有流量，那么就可以稍微设置大一点；</p>
</li>
<li><p>根据业务的实时性要求，如果<strong>实时性要求高</strong>的话，我们把<strong>队列设置小</strong>一点，<strong>coreSize ==  maxSize</strong>，并且设置 <strong>maxSize 大一点</strong>，如果实时性要求低的话，就可以把队列设置大一点。</p>
</li>
</ul>
<p>（2）粗略定量</p>
<p>CPU密集型（加密，计算）：最佳线程数为<strong>CPU核心的1-2倍</strong></p>
<p>耗时IO型（读写数据库，文件等）：最佳线程数为<strong>CPU核心很多倍</strong></p>
<blockquote>
<p>《Java并发编程实战》的作者 Brain Goetz ：线程数=CPU核心数*(1+平均等待时间/平均工作时间)；</p>
<p>等待（读取数据库）越长，线程数越多；</p>
</blockquote>
<p>（3）更加精准</p>
<p>根据具体业务，去进行程序的压测</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426172633985.png" alt="image-20220426172633985"></p>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a><strong>线程池状态</strong></h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220101105917734.png" alt="image-20220101105917734"></p>
<p>wokerCount 任务队列里面的工作线程数</p>
<p><strong>有2种转换</strong></p>
<ul>
<li>shutdown</li>
</ul>
<p>从running，shutdown，tidying，terminated</p>
<ul>
<li>shutdownNow</li>
</ul>
<p>从running，stop，tidying，terminated</p>
<h4 id="2-5停止线程池"><a href="#2-5停止线程池" class="headerlink" title="2.5停止线程池"></a><strong>2.5停止线程池</strong></h4><p>1.shutdown</p>
<p>关闭初始化。<strong>等线程池里面的任务全部完成再关闭</strong>，新的任务来会拒绝</p>
<p>2.isShutdown</p>
<p>是否进入关闭状态（不是真正停止）</p>
<p>3.isTerminated</p>
<p>真正停止</p>
<p>4.awaitTermination</p>
<p>测试一段时间内，线程池是否真正停止</p>
<p>5.shutdownNow</p>
<p>中断线程，同时将任务列表返回</p>
<h4 id="2-6线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？⭐️"><a href="#2-6线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？⭐️" class="headerlink" title="2.6线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？⭐️"></a>2.6<strong>线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程？</strong>⭐️</h4><p>（1）一方面：阻塞队列通过阻塞可以<strong>保留住当前想要继续入队</strong>的任务。 另一方面：阻塞队列可以保证任务队列中没有任务时<strong>阻塞获取任务的线程</strong>，使得线程进入<strong>wait状态，释放cpu资源</strong>。<strong>阻塞队列自带阻塞和唤醒的功能</strong>，不需要额外处理，无任务执行时,<strong>线程池利用阻塞队列的take方法挂起</strong>，从而维持核心线程的存活、不至于一直占用cpu资源。</p>
<p>（2）在创建<strong>新线程的时候，是要获取全局锁</strong>的，这个时候其它的就得阻塞，影响了整体效率。<br>就好比一个企业里面有10个（core）正式工的名额，最多招10个正式工，要是任务超过正式工人数（<strong>task &gt; core</strong>）的情况下，工厂领导（线程池）不是首先扩招工人，还是这10人，但是任务可以<strong>稍微积压一下</strong>，即先放到队列去（代价低）。10个正式工慢慢干，迟早会干完的，要是任务还在继续增加，超过正式工的<strong>加班忍耐极限了（队列满了）</strong>，就得招外包帮忙了（<strong>非核心线程</strong>）要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p>
<h4 id="2-7线程池实现任务复用的原理⭐️"><a href="#2-7线程池实现任务复用的原理⭐️" class="headerlink" title="2.7线程池实现任务复用的原理⭐️"></a>2.7<strong>线程池实现任务复用的原理</strong>⭐️</h4><p>在线程池中，<strong>同一个线程可以从阻塞队列中不断获取新任务来执行</strong>。其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用Thread.start()来创建新线程，而是<strong>让每个线程去执行一个“循环任务”</strong>,在这个“循环任务”中不停的<strong>检查是否有任务需要被执行</strong>,如果有则直接执行,也就是调用<strong>任务中的run 方法</strong>,将 run 方法当成一个普通的方法执行,通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来。</p>
<h4 id="2-8如何判断线程池已经执行完所有任务了？"><a href="#2-8如何判断线程池已经执行完所有任务了？" class="headerlink" title="2.8如何判断线程池已经执行完所有任务了？"></a>2.8如何判断线程池已经执行完所有任务了？</h4><ul>
<li>使用isTerminated方法</li>
</ul>
<blockquote>
<p>需要通过线程池的完成状态来实现，不然线程池会一直处于RUNNING状态，<strong>需要调用shutdown</strong>关闭线程池，一般情况下不推荐使用</p>
</blockquote>
<ul>
<li>使用getCompleteTaskCount</li>
</ul>
<blockquote>
<p>通过判断计划执行总任务的数量和已经完成的任务数量是否相等，若相等则已经全部执行完成，但因为任务和线程状态可能在计算过程中会动态变化，所以得到的是一个大致的值，<strong>可能不准确</strong></p>
</blockquote>
<ul>
<li>使用CountDownlatch</li>
</ul>
<blockquote>
<p>相当于一个线程安全的<strong>单次计数器</strong>，使用比较简单，且无需关闭线程池，是<strong>比较常用的判断方法</strong></p>
<p>声明一个包含5个任务的计数器；每个任务执行完成后计数器-1；CountDownlatch为0时，表示任务都执行完成</p>
</blockquote>
<ul>
<li>使用CyclicBarrier</li>
</ul>
<blockquote>
<p>相当于一个线程安全的<strong>重复计数器</strong>，<strong>使用比较复杂，使用较少</strong>，</p>
</blockquote>
<h3 id="3-钩子方法，线程池任务执行之前和之后，加料"><a href="#3-钩子方法，线程池任务执行之前和之后，加料" class="headerlink" title="3.钩子方法，线程池任务执行之前和之后，加料"></a>3.钩子方法，线程池任务执行之前和之后，加料</h3><p>在线程池任务执行之前实现 beforeExecute 方法，执行之后实现 afterExecute 方法。</p>
<p>钩子函数作用：</p>
<blockquote>
<p>解耦，利用钩子拦截，再做其他事情。而不是将全部事情写在一个任务里。</p>
</blockquote>
<blockquote>
<p>场景：线程暂停；恢复；在每个任务执行前后想做日志，统计</p>
</blockquote>
<h3 id="4-不同场景，如何使用线程池⭐️"><a href="#4-不同场景，如何使用线程池⭐️" class="headerlink" title="4.不同场景，如何使用线程池⭐️"></a><strong>4.不同场景，如何使用线程池</strong>⭐️</h3><h4 id="1-coreSize-maxSize，无界队列（常用）"><a href="#1-coreSize-maxSize，无界队列（常用）" class="headerlink" title="1 coreSize == maxSize，无界队列（常用）"></a><strong>1 coreSize == maxSize，无界队列（常用）</strong></h4><p><code>ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 600000L, TimeUnit.DAYS, new LinkedBlockingQueue());</code></p>
<p>让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗，一般来说业务流量都有波峰低谷，在流量低谷时，线程不会被回收；流 量波峰时，maxSize 的线程可以应对波峰，不需要慢慢初始化到 maxSize 的过程。</p>
<p>前提：</p>
<p>（1）allowCoreThreadTimeOut 我们采取默认 false，而不会主动设置成 true， allowCoreThreadTimeOut 是 false 的话，当线程空闲时，就不会回收核心线程</p>
<p>（2）keepAliveTime 和 TimeUnit 我们都会设置很大，这样线程空闲的时间就很长，线程就不会轻易的被回收。<br>场景：我们<strong>现在机器的资源都是很充足的</strong>，我们不用去担心线程空闲会浪费机器的资源，所以这种写法 目前是很常见的。</p>
<h4 id="2-maxSize-无界-SynchronousQueue"><a href="#2-maxSize-无界-SynchronousQueue" class="headerlink" title="2.maxSize 无界 + SynchronousQueue"></a><strong>2.maxSize</strong> <strong>无界</strong> <strong>+ SynchronousQueue</strong></h4><p>SynchronousQueue其内部有<strong>堆栈和队列两种形式，默认是堆栈的形式</strong>，其内部是没有存储的容器的，放元素和拿元素是一一对应的，比如我使用 <strong>put 方法放元素， 如果此时没有对应的 take 操作的话，put 操作就会阻塞</strong>，需要有线程过来执行 take 操作后，put 操作才会返回。基于此特点，如果要使用 SynchronousQueue 的话，我们需要尽量<strong>将 maxSize 设置大一点，防止请求被拒绝</strong>。  </p>
<p>优点：当任务被消费时，才会返回，这样请求就能够<strong>知道当前请求是已经在被消费了</strong>。如果是其他的队列的话，我们只知道任务已经被提交成功了，但无法知道当前任务是在被消费中，还是正在队列中堆积。 </p>
<p>缺点： </p>
<p>\1. 比较消耗资源，大量请求到来时，我们<strong>会新建大量的线程</strong>来处理请求； </p>
<p>\2. 如果请求的量难以预估的话，<strong>maxSize 的大小也很难设置</strong>。</p>
<h4 id="3-maxSize-有界-Queue-无界"><a href="#3-maxSize-有界-Queue-无界" class="headerlink" title="3 maxSize 有界 + Queue 无界"></a><strong>3 maxSize</strong> <strong>有界</strong> <strong>+ Queue</strong> <strong>无界</strong></h4><p>比如我们设置 maxSize 为 20，Queue 选择默认构造器的 LinkedBlockingQueue，</p>
<p>优点： </p>
<p>\1. 电脑 <strong>cpu 固定的情况</strong>下，每秒能同时工作的线程数是有限的，此时开很多的线程其实也是浪费，还不如把这些请求放到队列中去等待，这样可以<strong>减少线程之间的 CPU 的竞争</strong>； </p>
<p>\2. LinkedBlockingQueue 默认构造器构造出来的链表的最大容量是 Integer 的最大值，<strong>非常适合流量忽高忽低</strong>的场景：当流量高峰时，大量的请求被阻塞在队列中，让有限的线程可以<strong>慢慢消费</strong>。 </p>
<p>缺点：流量高峰时，大量的请求被阻塞在队列中，对于请求的<strong>实时性难以保证</strong>，所以当对请求的实时性要求较高的场景，不能使用该组合。</p>
<h4 id="4-maxSize-有界-Queue-有界"><a href="#4-maxSize-有界-Queue-有界" class="headerlink" title="4 maxSize 有界 + Queue 有界"></a><strong>4 maxSize</strong> <strong>有界</strong> <strong>+ Queue</strong> <strong>有界</strong></h4><p>这种组合是对 3 缺点的补充，我们把队列从无界修改成有界，只要排队的任务在要求的时间内， 能够完成任务即可。 这种组合需要我们把线程和队列的大小进行配合计算，保证大多数请求都可以在要求的时间内， 有响应返回。</p>
<blockquote>
<h4 id="keepAliveTime-设置无穷大"><a href="#keepAliveTime-设置无穷大" class="headerlink" title="keepAliveTime 设置无穷大"></a><strong>keepAliveTime</strong> <strong>设置无穷大</strong></h4><p>有些场景下我们不想让空闲的线程被回收，于是就把 keepAliveTime 设置成 0，实际上这种设置 是错误的，当我们把 keepAliveTime 设置成 0 时，线程使用 poll 方法在队列上进行超时阻塞时， 会立马返回 null，也就是空闲线程会立马被回收。</p>
<p>所以如果我们想要空闲的线程不被回收，我们可以设置 keepAliveTime 为无穷大值，并且设置 TimeUnit 为时间的大单位，比如我们设置 keepAliveTime 为 365，TimeUnit 为 TimeUnit.DAYS，意思是线程空闲 1 年内都不会被回收。</p>
<p>在实际的工作中，机器的内存一般都够大，我们<strong>合理设置 maxSize 后，即使线程空闲，我们也不希望线程被回收</strong>，我们常常也会设置 keepAliveTime 为无穷大。</p>
</blockquote>
<h3 id="7-注意点"><a href="#7-注意点" class="headerlink" title="7.注意点"></a>7.注意点</h3><p>避免任务堆积</p>
<p>避免线程数过多</p>
<p>排查线程泄漏（线程没有回收）</p>
<h2 id="三-ThreadLocal"><a href="#三-ThreadLocal" class="headerlink" title="(三) ThreadLocal"></a>(三) ThreadLocal</h2><h3 id="1-介绍，作用"><a href="#1-介绍，作用" class="headerlink" title="1.介绍，作用"></a>1.介绍，作用</h3><p><em>ThreadLocal</em>的作用是提供线程内的局部变量，<strong>同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本</strong>，因此该变量对其他线程而言是隔离的。</p>
<p><strong>作用</strong></p>
<p>线程安全（每一个线程独享一个对象）</p>
<p>空间换时间（相对于每个任务创建一个SimpleDateFormat）</p>
<p>免去传参，低耦合</p>
<p>不需要加锁，执行效率高</p>
<h3 id="2-场景⭐️"><a href="#2-场景⭐️" class="headerlink" title="2.场景⭐️"></a>2.场景⭐️</h3><p><strong>独享的对象</strong></p>
<p>1.每个线程<strong>需要一个独享的对象</strong>（通常为<strong>工具类（线程不安全）</strong>：SimpleDateFormat，Random）</p>
<p>业务：1000个线程打印SimpleDateFormat时间字符串，每次执行任务都创建SimpleDateFormat（1000次），开销大；其实创建1个就可以了，但是1个SimpleDateFormat的话就存在并发不安全的问题。</p>
<p>解决方法1:加锁，但是任务都得一个个等待，但存在性能问题</p>
<p>解决方法2:线程池10个线程使用10个SimpleDateFormat </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要重写initialValue</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal2 = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>保存全局变量</strong>（任何方法可以轻松获取对象）</p>
<p>2.每个线程内需要<strong>保存全局变量</strong>（在拦截器中获取用户信息，Session会话管理），可以让不同方法直接使用，<strong>避免参数传递</strong>的麻烦</p>
<p>业务：把user对象层层传递，导致代码冗余且不易维护；采用UserMap，并发不安全。</p>
<p>解决方法1**:加锁，或者用ConcurrentHashMap**；但存在性能问题</p>
<p>解决方法2:</p>
<p>用ThreadLocal保存一些业务内容（用户权限信息，用户名，UserID等）</p>
<p>这些信息在同一个线程内是一样的，不同线程使用的业务内容是不同的</p>
<p>在线程生命周期内，<strong>使用这个静态的ThreadLocal实例的get()方法获取自己set过的那个对象</strong>，避免了将这个对象作为参数传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合适时机，初始化值</span></span><br><span class="line"><span class="keyword">package</span> threadlocal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalNormalUsage06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service1().process(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;超哥&quot;</span>);</span><br><span class="line">        UserContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> Service2().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = UserContextHolder.holder.get();</span><br><span class="line">        <span class="comment">//ThreadSafeFormatter.dateFormatThreadLocal.get();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Service2拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        <span class="keyword">new</span> Service3().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = UserContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service3拿到用户名：&quot;</span> + user.name);</span><br><span class="line">        UserContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.数据库连接</p>
<p><strong>连接池是缓存并托管数据库连接，主要是为了提高性能</strong>。</p>
<blockquote>
<p>连接池是缓存并托管数据库连接，引入了数据库连接池，提前创建好了n条连接放入池，为了避免单一数据库连接的创建和关闭耗费时间和性能，这样可以提高性能。</p>
<p>连接池里面有一定数量的连接资源，比如最大20个连接。<br>如果<strong>直接连接数据库是没有使用数据库连接池</strong>，特点是：要传入url、用户名和密码等信息）</p>
<p>使用数据库连接池，通常都是得到一个所谓的javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等），肯定是重新定义了getConnection、closeConnection等方法，所以你<strong>每次得到的Connection，几乎都不是新建立的连接</strong>（而是已经建立好并放到缓存里面的连接），你<strong>调用closeConnection方法，也不是真正的关闭连接</strong>（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）</p>
</blockquote>
<p>而<strong>ThreadLocal缓存连接</strong>，是为了把同一个数据库连接“分享”给同一个线程的不同调用方法。</p>
<blockquote>
<p>如果一个请求中涉及多个 DAO 操作，而如果这些DAO中的Connection都是独立的话，就没有办法完成一个事务。但是如果DAO 中的 Connection 是从 ThreadLocal 中获得的（意味着都是同一个对象）， 那么这些 DAO 就会被纳入到同一个 Connection 之下。</p>
</blockquote>
<p><strong>数据库连接池不用ThreadLocal行不行？</strong></p>
<p>不行。<strong>不同时间的多个线程</strong>要从数据库连接池拿连接，那这个时候就可<strong>能拿到的是同一个连接</strong>了，也就是说在<strong>多个线程在同一个事务之内</strong>，线程a执行了插入还没来得及提交，线程b此时来了个更新，在线程a还未操作完之前，线程b更新完了后，直接把连接给close了，线程a插了一半发现插不了了。</p>
<p>为了确保不同时间多个线程可能拿到的是同一个连接，那么此时threadlocal闪亮登场，就算我拿的是“同一个连接”，在引入了threadlocal后，每个线程之间都会<strong>创建独立的连接副本</strong>，这样就互相不干扰了。</p>
<h3 id="3-ThreadLocal原理⭐️"><a href="#3-ThreadLocal原理⭐️" class="headerlink" title="3.ThreadLocal原理⭐️"></a>3.ThreadLocal原理⭐️</h3><p><strong>每一个 Thread 对象均含有一个 ThreadLocalMap 类型的成员变量 threadLocals ，它存储本线程中所 有ThreadLocal对象及其对应的值</strong> </p>
<p><strong>ThreadLocalMap</strong> 由一个个 Entry 对象构成Entry 继承自 WeakReference&lt;ThreadLocal&lt;?&gt;&gt; ，一个 Entry 由 ThreadLocal 对象和 Object 构成。由此可见， <strong>Entry 的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收。</strong></p>
<p><strong>原理图</strong>⭐️</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220101143155727.png" alt="image-20220101143155727"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>个Thread利用TreadLoaclMap保存多个ThreadLocal。</span><br><span class="line">例如：<span class="number">1</span>个线程可能有多个threadLocal</span><br><span class="line">User user = UserContextHolder.holder.get();</span><br><span class="line">ThreadSafeFormatter.dateFormatThreadLocal.get();</span><br></pre></td></tr></table></figure>

<p>**initialValue()**⭐️</p>
<p><strong>initialValue()是延时加载的，调用get()时才调用initialValue()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）之前没有用set()，则会调用initialValue()，⚠️没有重写则返回null</span><br><span class="line">2）之前用了set()，则不会再调用initialValue()</span><br><span class="line">如果remove()，则调用get()，会再调用initialValue()</span><br></pre></td></tr></table></figure>

<p><strong>get() 获取threadlocal对应的value⭐️</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先获取当前Thread的引用t</span><br><span class="line">（2）在通过t先获取当前的ThreadLocalMap map</span><br><span class="line">（3）判断是否为空</span><br><span class="line">  不为空：map.getEntry(this) //⚠️this为当前ThreadLocal</span><br><span class="line">  为空：调用initialValue()</span><br></pre></td></tr></table></figure>

<p><strong>set()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先获取当前Thread的引用t</span><br><span class="line">（2）在通过t先获取当前的ThreadLocalMap map</span><br><span class="line">（3）判断是否为空</span><br><span class="line">	不为空：直接map.set(this,value)//⚠️this为当前ThreadLocal</span><br><span class="line">	为空：createMap（t，value）</span><br><span class="line">		//⚠️map的key和value都保存在Thread中，而不ThreadLocal</span><br></pre></td></tr></table></figure>

<p><strong>remove()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先获取当前Thread的引用t</span><br><span class="line">（2）在通过t先获取当前的ThreadLocalMap map</span><br><span class="line">（3）判断是否为空</span><br><span class="line">	不为空：直接m.remove(this)</span><br></pre></td></tr></table></figure>

<p><strong>threadLocalMap类 就是 Thread.threadLocals</strong></p>
<blockquote>
<p>key：ThreadLoacl，value：值</p>
<p><strong>采用线性探测法</strong></p>
</blockquote>
<p>哈希冲突：HashMap，拉链法；JDK1.8拉链法+超过一定量变成红黑树</p>
<h3 id="4-注意点-使用坑"><a href="#4-注意点-使用坑" class="headerlink" title="4.注意点 使用坑"></a>4.注意点 使用坑</h3><p><strong>（1）内存泄漏</strong></p>
<p><code>某个对象不再有用，但占用的内存不能被回收</code></p>
<p><strong>1）要么ThreadLocal，要么value泄漏</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadLocal采用弱引用（可以被GC回收）；   </span><br><span class="line">value = v; 强引用（赋值操作，GC不能回收）</span><br></pre></td></tr></table></figure>

<p><strong>场景：线程池，key对应的value不能被GC回收</strong></p>
<p>JDK：set，get等方法扫描到key为null的Entry，并把对应的value设置为null，这样value就可以被回收了。</p>
<p>但是一个ThreadLocal不再使用，也不会再使用set，get；</p>
<blockquote>
<p>强引用：Java虚拟机（JVM）必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory 错误也不会回收这种对象。</p>
<p>我们在使用完对象后如果想让 JVM 回收对象需要将对象弱化，具体操作是将其引用置为null</p>
</blockquote>
<p><strong>2）解决</strong></p>
<ul>
<li><p>因此在**使用完ThreadLocal要手动调用remove()或使用拦截器调用remove()**，阿里规约</p>
</li>
<li><p>将ThreadLocal变量定义成private static，这样就一直<strong>存在ThreadLocal的强引用</strong>，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</p>
</li>
</ul>
<p><strong>（2）空指针异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        <span class="keyword">return</span> longThreadLocal.get();	<span class="comment">//返回的是Long,而函数返回long</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(threadLocalNPE.get());</span><br><span class="line"><span class="comment">//由于拆箱/装箱问题, 包装类转化为基本类型出错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;		<span class="comment">//返回Long则不会抛空指针异常了</span></span><br><span class="line">        <span class="keyword">return</span> longThreadLocal.get();	<span class="comment">//返回的是Long,而函数返回long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）共享对象</strong></p>
<p><strong>如果set的对象是static对象</strong>，则此时会有线程安全问题（多个线程同时操作临界资源）</p>
<blockquote>
<p>如果不使用ThreadLocal就可以解决，那不要使用</p>
</blockquote>
<p><strong>（4）优先使用框架</strong></p>
<p><strong>1）在Spring中，使用RequestContextHolder</strong>，那就不用自己维护ThreadLocal，**因为可能会忘记调用remove()**等，造成内存泄漏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateTimeContextHolder</span><br><span class="line">RequestContextHolder</span><br></pre></td></tr></table></figure>

<p>2）每一个HTTP（共享HTTPSession）请求对应一个线程</p>
<p><strong>（5）创建子线程时，子线程是得不到父线程的 ThreadLocal</strong></p>
<p>可以使用 InheritableThreadLocal 来代替 ThreadLocal</p>
<p>我们使用InheritableThreadLocal可以保证在子线程中拿到父线程设置的ThreadLocal的值，它在创建子线程时<strong>通过复制父线程的ThreadLocal的值</strong>来保证ThreadLocal的值的传递。但是<strong>在线程池这种线程复用</strong>的场景下，<strong>不会每次都创建线程</strong>，这就导致了ThreadLocal的值传递不起作用。</p>
<p>阿里开发出来的<strong>TransmittableThreadLocal</strong>来让线程池提交任务时进行ThreadLocal的值传递。</p>
<p><strong>（6）如果是拿数据的 springBean 是丢给线程池执行的，我们能够成功的从 ThreadLocal 中拿到数据 么？</strong></p>
<p>不管是主线程还是子线程和 ThreadLocal 进行交互时，HashMap 都是同一个，也就是说 <strong>ThreadLocal 中保存的 HashMap 是共享的，这就导致了线程安全的问题</strong>。</p>
<p><strong>进行 HashMap 的拷 贝</strong>，这样子线程的 HashMap 和 main 线程的 HashMap 就不同了，可以解决上面的问题。 我们提交任务时， 使用的是 Runnable，要实现 HashMap 的拷贝的话，我们需要<strong>把 Runnable 进 行一层包装</strong>。</p>
<h3 id="5-ThreadLocal与Synchronized的区别"><a href="#5-ThreadLocal与Synchronized的区别" class="headerlink" title="5. ThreadLocal与Synchronized的区别"></a>5. ThreadLocal与Synchronized的区别</h3><p>1、Synchronized用于线程间的<strong>数据共享</strong>，而ThreadLocal则用于线程间的<strong>数据隔离</strong>。</p>
<p>2、Synchronized是利用<strong>锁的机制</strong>，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了<strong>变量的副本</strong>，使得每个线程在某一时间访问到的并不是同一个对象</p>
<h2 id="（四）锁"><a href="#（四）锁" class="headerlink" title="（四）锁"></a>（四）锁</h2><h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1. Lock接口"></a>1. Lock接口</h3><p><strong>（1）简介</strong></p>
<p>锁是一种工具，用于<strong>控制共享资源的访问</strong></p>
<p>synchronized，Lock都能够达到线程安全，Lock不是来代替synchronized，而是当synchronized不满足要求时，Lock来提供高级功能。</p>
<blockquote>
<p>lock实现类：ReentrantLock ，ReentrantReadWriteLock</p>
</blockquote>
<p><strong>（2）有synchronized，还需要Lock？⭐️</strong></p>
<p>synchronized不够用</p>
<p>1）效率低：锁释放情况少，不能设定超时；只有在代码执行完毕或者异常才释放</p>
<p>2）不够灵活：自动释放锁，加锁和释放锁的时机单一，不可被中断</p>
<p>3）无法知道是否成功获取锁</p>
<p><strong>区别：</strong></p>
<p>synchronized是关键字；Lock是一个接口</p>
<p>synchronized能锁住类、方法和代码块；而Lock是块范围内的</p>
<p>synchronized不能知道线程有没有拿到锁，而Lock可以</p>
<p>synchronized会自动释放锁，而Lock必须手动释放锁</p>
<p>synchronized会一直等待锁，不会响应中断； Lock可以。</p>
<p><em>synchronized</em>只支持<em>非公平锁</em>，<em>lock</em>支持<em>非公平锁</em>和公平锁</p>
<p><strong>（3）方法介绍</strong></p>
<p>**lock()**：获取锁（在异常时不会自动释放锁，要手动在try，finally里释放）</p>
<blockquote>
<p>缺点：不能够被中断，一旦陷入<strong>死锁</strong>，就会陷入永久等待</p>
</blockquote>
<p>**tryLock()**（立即返回，不会等待）</p>
<blockquote>
<p>尝试获取锁，获取成功返回true，失败返回false</p>
</blockquote>
<p><strong>tryLock(long Tim,TimeUnit time)</strong>   （超时就放弃，<strong>可以被中断</strong>）</p>
<p><strong>（4）可见性保证⭐️</strong></p>
<p>线程与线程之间不能够看见对方的动态，线程1修改A=1，线程2可能看到的A还是0</p>
<p><strong>happens-before</strong></p>
<p>Lock与synchronized有同样的内存语义。也就是说线程加锁后可以<strong>看到前一个线程解锁前发生的所有操作</strong></p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220101162042272.png" alt="image-20220101162042272"></p>
<h3 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2.锁的分类"></a>2.锁的分类</h3><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220101162215222.png" alt="image-20220101162215222"></p>
<h4 id="（1）乐观锁-非互斥同步锁-和悲观锁（互斥同步锁）"><a href="#（1）乐观锁-非互斥同步锁-和悲观锁（互斥同步锁）" class="headerlink" title="（1）乐观锁(非互斥同步锁)和悲观锁（互斥同步锁）"></a>（1）乐观锁(非互斥同步锁)和悲观锁（互斥同步锁）</h4><p><strong>由来</strong>：互斥同步（悲观）锁存在很多缺点</p>
<blockquote>
<p>阻塞和唤醒带来性能劣势（用户态，核心态切换，上下文切换）</p>
<p>永久阻塞：持锁的线程遇到死锁，等锁释放的线程也进入永久等待<br>优先级反转：优先级低的线程执行的慢或者不释放锁，则优先级高的得不到锁</p>
</blockquote>
<p>（1）悲观锁：synchronized和Lock相关类</p>
<blockquote>
<p>例子：select for update悲观锁（查询条件用了索引/主键，行锁；否则用表锁）</p>
<p>添加lock_version变成乐观锁<br>Update set num=2,version=version+1 where version=1 and id =5;</p>
</blockquote>
<p>（2）乐观锁：比较乐观不加锁。更新数据时，同时查看更新期间是否有其他线程在修改数据，如果没有，直接就给；如果有则不能更新数据，而是选择放弃，报错，重试等策略。</p>
<blockquote>
<p>乐观锁的实现一般利用CAS算法实现<br><strong>例子：原子类，并发容器，Git等</strong></p>
<p>Git就是乐观锁的典型例子，git会检查远端仓库版本是不是领先于本地版本，是的话，证明已经被修改过了，提交就失败；否则就可以提交。</p>
</blockquote>
<p>（3）开销对比</p>
<p>悲观锁：一劳永逸，适用于<strong>持锁时间比较长</strong>，可以避免大量的无用自旋等消耗。</p>
<blockquote>
<p>1.临界区有<strong>IO</strong>操作；2.临界区<strong>代码复杂</strong>或循环量大；3.临界区<strong>竞争非常激烈</strong></p>
</blockquote>
<p>乐观锁：消耗越来越多，适用于<strong>读多写少</strong>的场景</p>
<h4 id="（2）可重入锁和非可重入锁（ReentrantLock为例）⭐️"><a href="#（2）可重入锁和非可重入锁（ReentrantLock为例）⭐️" class="headerlink" title="（2）可重入锁和非可重入锁（ReentrantLock为例）⭐️"></a>（2）可重入锁和非可重入锁（ReentrantLock为例）⭐️</h4><p>可重入锁： synchronized（隐式）与Lock（显式），ReentrantLock（默认非公平，效率更高）</p>
<p><strong>作用</strong></p>
<blockquote>
<p>1.避免死锁：手里拿着锁A，进入方法1，执行完后，还要执行方法2（同样需要锁A），如果不可重入锁，那么此时获取不到锁A，导致死锁</p>
<p>2.提升封装性（不用一次次的加锁解锁）</p>
</blockquote>
<p><strong>可重入锁原理</strong></p>
<blockquote>
<p>可重入锁<strong>利用state变量</strong>，表示上锁的次数。</p>
<p>上锁时，先判断是非为0，是的话，尝试用CAS的方式去获取；<br>不是0 的话，先判断是不是自己持有，是的，state加1；不是，放入等待队列，<strong>park</strong>挂起当前线程。</p>
<p>释放锁时，state-1，判断释放锁的是否是当前线程，如果不是报错；是的话继续判断是非为0，是的unpark释放，同时处理park的线程会被唤醒继续执行。</p>
</blockquote>
<p><strong>非可重入锁原理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上锁时，为0时，尝试获取锁（state最大为1）</span><br><span class="line">释放时，不是当前线程抛异常；是的话直接设置为0</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94.png" alt="可重入锁和不可重入锁源码对比"></p>
<p><strong>场景</strong></p>
<p>1.预定座位</p>
<p>2.打印字符串（顺序完整性）</p>
<p><strong>ReentrantLock其他方法</strong></p>
<p>isHeldByCurrentThread：锁释放是否被当前线程持有</p>
<p>getQueueLength：返回正在等待这把锁的队列长度</p>
<h4 id="（3）公平锁和非公平锁"><a href="#（3）公平锁和非公平锁" class="headerlink" title="（3）公平锁和非公平锁"></a>（3）公平锁和非公平锁</h4><p><em>synchronized</em>只支持<em>非公平锁</em>，<em>lock</em>支持<em>非公平锁</em>和公平锁</p>
<p><strong>1.介绍</strong></p>
<p>公平锁：按顺序执行（吞吐量更小）（多个判断条件，判断当前结点是否为第一个结点，是的去获取锁，否则返回false）</p>
<p>非公平锁：合适时机插队，避免唤醒带来的空档期，提高效率</p>
<p>（有可能线程饥饿，每次执行，都有其他线程抢走锁，导致长时间无法执行）</p>
<blockquote>
<p>A,B,C；A释放锁时，唤醒B，C在唤醒B的期间，拿到锁，并很快执行完再释放，此时B再拿到锁</p>
</blockquote>
<p><strong>2.例子</strong></p>
<p>线程1-3：需要打印字符串1，打印字符串2（2个任务）</p>
<blockquote>
<p>公平锁：线程1-3打印字符串1，线程1-3打印字符串2</p>
<p>非公平锁：线程1打印字符串1，2；线程2打印字符串1，2；线程3打印字符串1，2；</p>
<p>tryLock()：<strong>非公平锁，不管前面是否有线程在等待队列</strong></p>
</blockquote>
<h4 id="（4）共享锁和排他锁（ReentrantReadWriteLock读写锁）⭐️"><a href="#（4）共享锁和排他锁（ReentrantReadWriteLock读写锁）⭐️" class="headerlink" title="（4）共享锁和排他锁（ReentrantReadWriteLock读写锁）⭐️"></a>（4）共享锁和排他锁（ReentrantReadWriteLock读写锁）⭐️</h4><p><strong>1.作用</strong></p>
<p>多读操作是没有线程安全问题的，所以<strong>为了提高效率，允许多个线程读取共享资源</strong>；但是,如果有一个线程想去写共享资源来就不应该有其他线程对该资源进行读或写;</p>
<p><strong>2.规则</strong></p>
<p><strong>要么多读，要么一写</strong>（不能读写同时进行）</p>
<p>读写锁是一把锁：有读锁定和写锁定</p>
<p><strong>3.实现</strong></p>
<p><strong>（1）重入性</strong></p>
<p><strong>可重入性说的是线程可以对共享资源重复加锁</strong>，对应的，释放时也可以重复释放，对于 ReentrantLock 来说，在获得锁的时候，state 会加 1，重复获得锁时，不断的对 state 进行递增 即可，比如目前 state 是 4，表示线程已经对共享资源加锁了 4 次，线程每次释放共享资源的锁 时，state 就会递减 1，直到递减到 0 时，才算真正释放掉共享资源。</p>
<p><strong>（2）插队</strong></p>
<p><strong>1）公平：</strong></p>
<p>读写都不允许插队</p>
<p><strong>2）非公平：</strong></p>
<p><strong>读锁：仅在等待队列的头结点不是获取写锁时可以插队；写锁可以插队</strong></p>
<p>场景：线程1，2在读；线程3要写，拿不到锁，进入等待队列；线程5要来读</p>
<p>策略1:允许5插队</p>
<blockquote>
<p>读效率高</p>
<p>写容易造成饥饿</p>
</blockquote>
<p>策略2:读锁不允许插队，5在排在3后面 （ReentrantReadWriteLock的策略）</p>
<blockquote>
<p>避免写饥饿</p>
</blockquote>
<p><strong>（3）不允许升级；允许降级</strong></p>
<blockquote>
<p><strong>写降级为读</strong>：在不释放写锁的情况下，获取读锁，成功降级后释放写锁；提高读效率</p>
</blockquote>
<blockquote>
<p><strong>读不可升级为写</strong>：读升级到写是不行的，会带来阻塞。（所有的读锁都释放了，才可以升级，因为<strong>有读就不能写</strong>）</p>
</blockquote>
<h4 id="（5）自旋锁和阻塞锁"><a href="#（5）自旋锁和阻塞锁" class="headerlink" title="（5）自旋锁和阻塞锁"></a>（5）自旋锁和阻塞锁</h4><p><strong>自旋锁</strong>：当前线程获取不到锁时，不必阻塞，可以先自旋（等待一会），<strong>避免线程切换的开销</strong></p>
<p>场景：<strong>同步资源锁定时间很短</strong>，为了切换线程，线程挂起和恢复现场花费的时间可能导致比用户执行代码的时间还要长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点：避免线程切换的开销</span><br><span class="line">缺点：如果占用时长，会浪费资源，开销是线性增长的</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220102113500426.png" alt="image-20220102113500426"></p>
<p><strong>阻塞锁：获取不到锁就阻塞</strong></p>
<h4 id="（6）可中断锁"><a href="#（6）可中断锁" class="headerlink" title="（6）可中断锁"></a>（6）可中断锁</h4><blockquote>
<p><em>中断</em>是指计算机运行过程中，出现某些意外情况需处理机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
</blockquote>
<p><strong>（1）介绍</strong></p>
<p>场景：A、B两线程去竞争锁，A得到了锁，B等待，但是A有很多事情要处理，B可能就会等不及了，<strong>中断自己</strong>，不再等待这个锁了，转而处理其他事情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized：不可中断锁</span><br><span class="line">Lock：可中断锁（因为tryLock和lockInterruptibly都能响应中断）</span><br></pre></td></tr></table></figure>

<p><strong>interrupt()并不会使线程停止运行</strong></p>
<p><strong>（2）中断</strong></p>
<p>中断（Interrupt）一个线程意味着在该线程<strong>完成任务之前停止其正在进行的一切</strong>，有效地中止其当前的操作。</p>
<p>中断线程最好的，最受推荐的方式是，<strong>使用共享变量发出信号</strong>，告诉线程必须停止正在运行的任务。线程必须周期性的核查这一变量（尤其在冗余操作期间），然后<strong>有秩序地中止任务</strong>。</p>
<h3 id="3-锁优化⭐️"><a href="#3-锁优化⭐️" class="headerlink" title="3.锁优化⭐️"></a>3.锁优化⭐️</h3><p><strong>（1）JVM自身优化</strong></p>
<p>1）自旋锁和自适应</p>
<blockquote>
<p>不是盲目自旋，在自旋次数太多，直接变成阻塞锁；自旋次数可以动态调整</p>
</blockquote>
<p>2）锁消除</p>
<p>方法内部的局部对象，不需要加锁</p>
<p>3）锁粗化</p>
<p>代码同步块越小越好，如果对同一个锁反复请求与释放，会消耗掉一定的系统资源。</p>
<p><strong>锁粗化把多次锁的请求合并成一个请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doSomethingMethod()&#123;</span><br><span class="line">    synchronized(lock)&#123;</span><br><span class="line">        //do some thing</span><br><span class="line">    &#125;</span><br><span class="line">    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕</span><br><span class="line">    synchronized(lock)&#123;</span><br><span class="line">        //do other thing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doSomethingMethod()&#123;</span><br><span class="line">    //进行锁粗化：整合成一次锁请求、同步、释放</span><br><span class="line">    synchronized(lock)&#123;</span><br><span class="line">        //do some thing</span><br><span class="line">        //做其它不需要同步但能很快执行完的工作</span><br><span class="line">        //do other thing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）锁升级</p>
<p>锁膨胀是指 synchronized <strong>从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程</strong>，它叫做锁膨胀也叫做锁升级。</p>
<p>  JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized  在释放和获取锁时都会从用户态转换成内核态，而<strong>转换的效率是比较低的</strong>。但有了锁膨胀机制之后，synchronized  的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了  synchronized 的性能，我们可以根据并发程度的激烈设计锁的不同状态。</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/v2-e443f6a3b2cbf5a62bd3c715c24c963a_720w.jpg" alt="img"></p>
<p> <strong>具体锁升级过程</strong></p>
<p>对象刚创建出来的时候是无锁的状态；当一个线程去竞争这个对象锁的时候，状态变为偏向锁；如果该线程没有获取到这个锁，就升级成一个轻量级的一个 CAS 的锁，就是一个乐观锁。乐观锁的他是一个比较交换的过程CAS。然后如果这个 CAS 没有设置成功的话，他会进行一个自旋，然后自旋到一定的次数之后才会升级成一个 synchronized的一个重量级的锁，这样话就保证了它的一个性能的问题。</p>
<p><strong>（2）自己写代码时的优化</strong></p>
<p>1）缩小同步代码块</p>
<p>2）尽量不要锁住方法</p>
<p>3）减少请求锁的次数</p>
<p>4）避免人为制造“热点”：用cnt保存大小，不要每次都遍历全部</p>
<p>5）锁中尽量不包含锁</p>
<h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p>synchronized能锁住普通方法、静态方法和代码块，最常用的代码块。</p>
<p><strong>修饰代码块需要指定加锁对象</strong>，这个对象通常使用this或者xx.class来表示；使用this表示使用当前对象加锁，而使用class时，表示使用某个类来加锁，它是全局生效的（可以理解为只有一把锁）。</p>
<p>普通方法是针对<strong>对象级别</strong>的，不同的对象对应不同的锁；</p>
<p>静态方法加锁是<strong>全局的</strong>，针对的是所有调用者。</p>
<h3 id="synchonized-底层实现"><a href="#synchonized-底层实现" class="headerlink" title="synchonized 底层实现"></a>synchonized 底层实现</h3><p>synchonized 是通过JVM内置的Monitor监视器实现的，而监视器又是依赖于操作系统互斥锁Mutex实现的。<br>JVM监视器的执行流程。</p>
<ul>
<li>线程先通过自旋CAS的方法尝试获取锁</li>
<li>如果获取失败就进入EntrySet集合；获取成功就拥有该锁，对应计数器+1</li>
<li>锁<strong>使用完成后就会通知EntrySet集合的线程</strong>，让他们去尝试获取锁</li>
<li>当调用<strong>wait</strong>时，线程释放锁并进入waitSet集合，等其他线程调用notify或者notifyall再尝试获取锁</li>
</ul>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220423200751923.png" alt="image-20220423200751923"></p>
<h3 id="lock-和-synchonized-的一个区别⭐️"><a href="#lock-和-synchonized-的一个区别⭐️" class="headerlink" title="lock 和 synchonized 的一个区别⭐️"></a>lock 和 synchonized 的一个区别⭐️</h3><p>第一个，从功能角度来看，lock和 synchonized 都是 Java 中去用来解决<strong>线程安全问题的一个工具</strong>。<br>第二个，从特性来看，</p>
<ul>
<li><p>lock 是 guc 包里面提供的一个<strong>接口</strong>，而这个接口它有很多的实现类，其中就包括 ReentrantLock的实现synchonized 是 Java 中的同步<strong>关键字</strong>。</p>
</li>
<li><p>其次 synchonized 可以通过<strong>两种方式去控制锁的粒度</strong>。一种是把 synchonized 关键字修饰在方法层面，另一种是修饰在代码块上。并且我们可以<strong>通过 synchonized 加锁对象的生命周期来控制锁的作用范围</strong>。比如锁对象是静态对象或者是类对象，那么这个锁就是属于全局锁。如果锁对象是普通实例对象，那么这个锁的范围取决于这个实例的生命周期。<br>lock 中<strong>锁的粒度</strong>是通过它里面提供的 lock 方法和 unlock 方法来决定的。像这样包裹在两个方法之间的代码是能够保证现在安全的。而<strong>锁的作用域</strong>取决于 lock 实例的生命周期。</p>
</li>
<li><p>然后 lock 比 synchonized 的<strong>灵活性更高</strong>。lock 可以自主地去决定什么时候加锁，什么时候释放锁，只需要调用 lock 和 unlock 这两个方法就可以了。</p>
</li>
<li><p>同时 lock 还提供了<strong>非阻塞竞争锁</strong>的方法，叫 try lock 这个方法可以通过返回 true or false 来告诉当<strong>前线程是否已经有其他线程正在使用锁</strong>。而 synchonized 由于是关键字，所以它无法去实现非阻塞竞争锁的方法。</p>
</li>
<li><p>lock是可<strong>中断锁</strong>；synchonized 不可中断锁</p>
</li>
<li><p>lock需要<strong>手动释放</strong>， synchonized 锁的释放是被动的，就是当 synchonized 同步代码块执行结束以后或者代码出现异常的时候才会被释放。</p>
</li>
<li><p>最后 lock <strong>提供了公平锁和非公平锁的机制</strong>。公平锁是指线程竞争锁资源的时候，如果已经有其他线程正在排队或者等待锁释放。那么当前竞争锁的线程是无法去插队的，而非公平锁不管是否有线程在排队等待锁，它都会去尝试去竞争一次锁。 synchonized 只提供了一种非公平锁的实现。</p>
</li>
</ul>
<p>第三个，从性能方面来看，synconnetnet和 lock 在性能方面相差不大，在实现上会有一定的区别。 synchonized 引入了偏向锁、轻量级锁、重量级锁以及<strong>锁升级的机制</strong>来去实现锁的优化，而 lock 中则用到了<strong>自旋锁的方式</strong>去实现性能优化。</p>
<h3 id="synchronized-VS-ReentrantLock⭐️"><a href="#synchronized-VS-ReentrantLock⭐️" class="headerlink" title="synchronized VS ReentrantLock⭐️"></a>synchronized VS ReentrantLock⭐️</h3><p><strong>synchronized 是可重入的排它锁</strong>，和 ReentrantLock 锁功能相似，任何使用 synchronized 的地方， 几乎都可以使用 ReentrantLock 来代替，两者最大的相似点就是：可重入 + 排它锁，两者的区别 </p>
<p>主要有这些： </p>
<p>\1. ReentrantLock 的功能更加丰富，比如提供了 <strong>Condition，可以打断</strong>的加锁 API、能满足锁 +  队列的复杂场景等等； </p>
<p>\2. ReentrantLock 有<strong>公平锁和非公平锁</strong>之分，而 synchronized 都是非公平锁； </p>
<p>\3. 两者的使用姿势也不同，ReentrantLock 需要<strong>申明，有加锁和释放锁的 API</strong>，而 </p>
<p>synchronized 会<strong>自动对代码块进行加锁释放锁</strong>的操作，synchronized 使用起来更加方便。 </p>
<h2 id="（五）原子类"><a href="#（五）原子类" class="headerlink" title="（五）原子类"></a>（五）原子类</h2><h3 id="1-什么是原子类，有什么用？"><a href="#1-什么是原子类，有什么用？" class="headerlink" title="1.什么是原子类，有什么用？"></a>1.什么是原子类，有什么用？</h3><p>一个原子操作是<strong>不可中断的</strong>，一旦开始，就运行到结束，不会有上下文切换，为了保证线程安全<br><strong>比起锁</strong></p>
<ul>
<li><p>粒度更细：缩小到变量级别</p>
</li>
<li><p>效率更高：除了高度竞争的情况</p>
</li>
</ul>
<h3 id="2-六类原子类"><a href="#2-六类原子类" class="headerlink" title="2.六类原子类"></a>2.六类原子类</h3><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220114172709770.png" alt="image-20220114172709770"></p>
<h3 id="3-Atomic-基本类型原子类，已AutomicInteger为例⭐️"><a href="#3-Atomic-基本类型原子类，已AutomicInteger为例⭐️" class="headerlink" title="3.Atomic*基本类型原子类，已AutomicInteger为例⭐️"></a>3.Atomic*基本类型原子类，已AutomicInteger为例⭐️</h3><ul>
<li><strong>AtomicInteger作为原子计数器</strong></li>
</ul>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220114173125965.png" alt="image-20220114173125965"></p>
<ul>
<li><strong>比较和交换操作</strong></li>
</ul>
<p><code>compareAndSet</code>：比较和交换操作将内存位置的内容与给定值进行比较，并且只有它们相同时，才将该内存位置的内容修改为给定的新值。这是作为单个原子操作完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">110</span>);   <span class="comment">//current value 100</span></span><br><span class="line">  </span><br><span class="line">        System.out.println(isSuccess);      <span class="comment">//true</span></span><br><span class="line">         </span><br><span class="line">        isSuccess = atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">120</span>);       <span class="comment">//current value 110</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(isSuccess);      <span class="comment">//false</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Atomic-Array"><a href="#4-Atomic-Array" class="headerlink" title="4.Atomic*Array"></a>4.Atomic*Array</h3><p>类似AtomicInteger</p>
<h3 id="5-Atomic-Reference⭐️"><a href="#5-Atomic-Reference⭐️" class="headerlink" title="5.Atomic*Reference⭐️"></a>5.Atomic*Reference⭐️</h3><p>类似AtomicInteger</p>
<ul>
<li>自旋锁</li>
</ul>
<p><code>compareAndSet</code></p>
<blockquote>
<p><em><strong>Atomic* *原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？</strong></em></p>
<p>Java 为这种情况提供了一个 API：AtomicReference，AtomicReference 类可操作的对象是个 泛型，所以支持自定义类。</p>
</blockquote>
<h3 id="6-普通类型升级为原子类：用AtomicIntegerFieldUpdater"><a href="#6-普通类型升级为原子类：用AtomicIntegerFieldUpdater" class="headerlink" title="6.普通类型升级为原子类：用AtomicIntegerFieldUpdater"></a>6.普通类型升级为原子类：用AtomicIntegerFieldUpdater</h3><blockquote>
<p>利用反射原理</p>
</blockquote>
<h3 id="7-Adder⭐️"><a href="#7-Adder⭐️" class="headerlink" title="7.Adder⭐️"></a>7.Adder⭐️</h3><blockquote>
<p>java8引入，竞争激烈时，LongAdder比AtomicLong效率高，本质上是空间换时间</p>
</blockquote>
<p><strong>每一次加法，都flush，refresh</strong>导致浪费资源。而LongAdder把不同线程对应到不同的cell上进行修改，降低冲突的概率，是<strong>多段锁</strong>的思想。</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220114180631453.png" alt="image-20220114180631453"></p>
<p>内部引入了<strong>base变量和cell数组</strong></p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220114181032846.png" alt="image-20220114181032846"></p>
<p>在求sum的过程中，cell可能变化，导致结果不是精准的</p>
<h3 id="8-Accumulator"><a href="#8-Accumulator" class="headerlink" title="8.Accumulator"></a>8.Accumulator</h3><p><strong>更加通用的Adder</strong></p>
<h2 id="（六）CAS"><a href="#（六）CAS" class="headerlink" title="（六）CAS"></a>（六）CAS</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>CAS算法的全称是：compareAndSwap的意思，是能保证当操作的线程安全的算法。CAS算法将<strong>预期值和更新值</strong>传入方法中进行比较，如果内存值和预期值不同，那么此次操作失败，继续循环获取新的内存值，预期值，更新值，直到这次操作成功，我们称这种操作为线程的自旋，最后返回现在的内存值，其中的算法我们称为CAS算法。</p>
<h3 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h3><p>CAS的核心类。由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问。而Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存。</p>
<h3 id="以AutomicInteger为例"><a href="#以AutomicInteger为例" class="headerlink" title="以AutomicInteger为例"></a>以AutomicInteger为例</h3><p><code>public native long objectFieldOffset(Field var1):</code>  valueOffset：返回指定的变量value在所属类中的<strong>内存偏移地址</strong>，并且private volatile int value；<strong>保证value的可见性</strong> ，<code>getIntVolatile</code>获得期望值。</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426204050171.png" alt="image-20220426204050171"></p>
<p><code>public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x)</code>：这个即CAS操作，比较对象o中偏移量为offset的变量的值是否与expected相等，相等则用x更新，然后返回true，否则返回false。</p>
<p>查看UnSafe类对应的Cpp代码：核心函数cmpxchg</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjIxNTYxNw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>一个线程把数据A变成了B，然后又重新变成了A，此时另一个线程读取该数据的时候，发现A没有变化，就误认为是原来的那个A，但是<strong>此时A的一些属性或状态已经发生过变化</strong>。</p>
<p>要解决ABA问题，可以增加一个版本号，当内存位置V的值每次被修改后，版本号都加1。<br> （1）使用AtomicStampedReference对象，<strong>版本戳为Int</strong>。</p>
<p>（2）AtomicMarkableReference：带版本戳的原子引用类型，<strong>版本戳为boolean类型</strong>。</p>
<h2 id="（七）线程协作，控制并发流程"><a href="#（七）线程协作，控制并发流程" class="headerlink" title="（七）线程协作，控制并发流程"></a>（七）线程协作，控制并发流程</h2><h3 id="1-控制并发流程工具类"><a href="#1-控制并发流程工具类" class="headerlink" title="1.控制并发流程工具类"></a>1.控制并发流程工具类</h3><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426205731705.png" alt="image-20220426205731705"></p>
<h3 id="2-Semaphore信号量⭐️"><a href="#2-Semaphore信号量⭐️" class="headerlink" title="2.Semaphore信号量⭐️"></a>2.Semaphore信号量⭐️</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>new Semaphore(证书数量，fair)</p>
<p>acquire：</p>
<p>acquireUninterruptibly：不响应中断</p>
<p>tryacquire：查看有没有许可证，没有立即返回False，不必阻塞；有的话就获取。</p>
<p>tryacquire（timeout），等待timeout，没有就放弃</p>
<p>release</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p>一次可以获取多个许可证。释放和获取必须一致，比如每次获取2个，释放1个，许可证数量不够，导致程序卡死</p>
</li>
<li><p>一般设置公平</p>
</li>
<li><p>可以跨线程，线程池，比如A获取，B释放</p>
</li>
<li><p>可以实现“条件等待”，相当于轻量级的CountDownLatch。线程1等待线程2完成，线程1acquire，线程2release后，线程1就可以执行了。</p>
</li>
</ul>
<h3 id="3-CountDownLatch倒计时门闩⭐️"><a href="#3-CountDownLatch倒计时门闩⭐️" class="headerlink" title="3.CountDownLatch倒计时门闩⭐️"></a>3.CountDownLatch倒计时门闩⭐️</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426210042562.png" alt="image-20220426210042562"></p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>1等多：1个线程等待其他线程都执行完毕才执行自己的任务。</li>
</ul>
<blockquote>
<p>比如一组线程有 5 个，只需要在初始化 CountDownLatch 时，给同步器的 state 赋值为 5，主线程执行 CountDownLatch.await ，子线程 都执行 CountDownLatch.countDown 即可。</p>
<p>当执行CountDownLatch.countDown，子线程开始全部执行</p>
</blockquote>
<ul>
<li>多等1：多个线程等待某一个线程的信号，再同时执行。</li>
<li>多等多也可以</li>
</ul>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul>
<li>一次性</li>
</ul>
<h3 id="4-CyclicBarrier循环栅栏"><a href="#4-CyclicBarrier循环栅栏" class="headerlink" title="4.CyclicBarrier循环栅栏"></a>4.CyclicBarrier循环栅栏</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>count计数器  parties线程数</strong>（当有parties个线程到达barrier,就会更新换代）</p>
<p><strong>每次线程await一次，count减1，变为0，达到等待线程数量要求，condition将条件队列中的线程全部唤醒</strong>。</p>
<h4 id="与CountDownLatch区别"><a href="#与CountDownLatch区别" class="headerlink" title="与CountDownLatch区别"></a>与CountDownLatch区别</h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426213657643.png" alt="image-20220426213657643"></p>
<h4 id="如何重置"><a href="#如何重置" class="headerlink" title="如何重置"></a>如何重置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？<br>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回；然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<h3 id="5-Condition接口（条件对象）"><a href="#5-Condition接口（条件对象）" class="headerlink" title="5.Condition接口（条件对象）"></a>5.Condition接口（条件对象）</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426212042747.png" alt="image-20220426212042747"></p>
<h4 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> flowcontrol.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示用Condition实现生产者消费者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(queueSize);</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();	</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();	<span class="comment">//没放满</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();	<span class="comment">//没取空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo2 conditionDemo2 = <span class="keyword">new</span> ConditionDemo2();</span><br><span class="line">        Producer producer = conditionDemo2.<span class="function">new <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = conditionDemo2.<span class="function">new <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列空，等待数据&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();	<span class="comment">//消费者等待</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    notFull.signalAll(); <span class="comment">//通知生产者</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;从队列里取走了一个数据，队列剩余&quot;</span> + queue.size() + <span class="string">&quot;个元素&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列满，等待有空余&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();	<span class="comment">//生产者等待</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    notEmpty.signalAll();	<span class="comment">//通知消费者</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;向队列插入了一个元素，队列剩余空间&quot;</span> + (queueSize - queue.size()));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426213425932.png" alt="image-20220426213425932"></p>
<h2 id="（八）AQS"><a href="#（八）AQS" class="headerlink" title="（八）AQS"></a>（八）AQS</h2><h4 id="aqs的理解⭐️"><a href="#aqs的理解⭐️" class="headerlink" title="aqs的理解⭐️"></a>aqs的理解⭐️</h4><p>aqs 是 Abstract Queued Synchronizer，AQS 中队列只有两个：同步队列 + 条件队列，底层数据结构两者都是链表。aqs 它是 juc 包中的多个组件的底层实现。比如说像 lock 各种锁、countDownLatch 、semaphore各种线程协作工具类都是用到了 aqs 。</p>
<p>从本质上来说，aqs提供了两种锁的机制，分别是<strong>排他锁和共享锁</strong>。所谓排他锁，就是存在多个线程去竞争同一共享资源的时候，同一个时刻只允许一个线程去访问这样一个共享资源。比如 lock 中的 reentrantLock，它的一个实现就是用到了 aqs 中的一个排他锁的功能。共享锁也称为读锁，就是在同一个时刻允许多个线程同时获得这样一个锁的资源，比如reentrantreadwirteLock , countDownLatch以及 semaphore 都用到了 aqs 中的共享锁的功能。</p>
<p>那么 aqs 作为互斥锁来说，它的整个设计体系中需要解决三个核心的问题。</p>
<p>​    第一个，互斥变量的设计，以及如何保证多线程同时更新互斥变量的时候线程的一个安全性。<br>​    第二个，未竞争到锁资源的线程的等待，以及竞争到锁的资源释放锁之后的唤醒。<br>​    第三个，锁竞争的公平性和非公平性。</p>
<p> aqs 采用了一个 int 类型的互斥变量(共享资源) <strong>state</strong> 用来记录锁竞争的一个状态。 0 表示当前没有任何线程竞争到锁资源而大于等于 1 表示已经有线程正在持有锁资源。一个线程来获得锁资源的时候，首先会判断 state 是否等于0，如果是则把这个 state 更新成1，表示占用到锁。而这个过程中如果多个线程同时去做这样一个操作，就会导致线程安全性问题。因此 aqs 采用了 <strong>cas 机制</strong>去保证 state 互斥变量更新的一个原子性。</p>
<p>未获得到锁的线程通过 <strong>unsafe 类中的 park 方法</strong>去进行阻塞，把阻塞的线程按照先进先出的原则去加入到一个双向链表的一个结构中。当获得锁资源的线程在释放锁之后，会从这样一个双向列表的<strong>头部去唤醒下一个等待</strong>的线程，再去竞争锁。</p>
<p>最后关于锁竞争的公平性和非公平性的问题，aqs的处理方法是在竞争锁资源的时候，公平锁需要<strong>去判断双向链表中是否有阻塞的线程</strong>，如果有则需要去排队等待。而非公平锁的处理方式是<strong>不管双向链表中是否存在</strong>,等待竞争锁的线程，它都会直<strong>接去尝试更改互斥变量state去竞争锁</strong>，假设在一个临界点获得锁的线程释放锁，此时 state 等于0，并且FIFO队列中有等待的线程。而当前的这个线程去抢占锁的时候，正好可以把 state 修改成1，那么这个时候就表示它可以拿到锁，而这个过程是非公平的。 </p>
<p>总结：AQS底层使用了一个volatile的int类型的成员变量来<strong>表示同步状态</strong>，通过CAS，自旋以及LockSupport.park()维护state变量的状态，使并发达到同步的控制效果；通过内置的FIFO队列来完成资源获取的<strong>排队工作</strong>。将每条要抢占资源的线程封装成一个Node结点来实现<strong>锁的分配</strong>。</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220418114713421.png" alt="image-20220418114713421"></p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220427170729235.png" alt="image-20220427170729235"></p>
<h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><ul>
<li><strong>state</strong></li>
</ul>
<p><strong>private volatile int state</strong>，不同协作工具类对应不同含义；semaphore：剩余的许可证数量，CountDownLatch：还要倒数的数量，cycilcBarrier：线程数量reentrantlock：可重入计数</p>
<blockquote>
<p><strong>reentrantlock</strong></p>
<ul>
<li>初始为0，compareAndSetState(0,1)成功则把当前线程设置为独占线程,成功则获得锁，不成功则继续。</li>
<li>会再次看一下state是否为0，是的话compareAndSetState(1)将state设为1并把当前线程设置为独占线程，否则看一下当前独占线程是否是当前线程是的话state+1，返回true结束，当前线程拿到资源，否则返回false</li>
</ul>
<p><strong>semaphore</strong></p>
<ul>
<li>允许线程执行的证书，许可证。主要用于控制当前活动线程数目</li>
</ul>
<p><strong>cycilcBarrier</strong></p>
<ul>
<li>count为计数器，初始化为线程数。每次线程await一次，count减1，变为0，达到等待线程数量要求，condition将条件队列中的线程全部唤醒。</li>
</ul>
<p><strong>CountDownLatch</strong></p>
<ul>
<li>比如一组线程有 5 个，只需要在初始化 CountDownLatch 时，给同步器的 state 赋值为 5，主线程执行 CountDownLatch.await ，子线程 都执行 CountDownLatch.countDown 即可。</li>
</ul>
</blockquote>
<ul>
<li>控制线程抢锁和配合的<strong>FIFO双向队列</strong></li>
<li>期望协作工具类去实现的<strong>获取/释放等重要方法</strong></li>
</ul>
<h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><p>我们可以选择 ReentrantLock 来描述一下实现思路： </p>
<ol>
<li><p>写一个类，想好协作的逻辑，实现获取/释放锁方法</p>
</li>
<li><p>内部写一个Sync类继承 AQS，并实现 AQS 的 tryAcquire 和 tryRelease 两个方法，在 tryAcquire 方 法里面实现控制<strong>能否获取锁</strong>，比如当同步器状态 state 是 0 时，即可获得锁，在 tryRelease  方法里面控制<strong>能否释放锁</strong>，比如将同步器状态递减到 0 时，即可释放锁；</p>
</li>
<li><p>对外提供 lock、release 两个方法，lock 表示获得锁的方法，底层调用 AQS 的 tryAcquire 方法， release 表示释放锁的方法，底层调用 AQS 的 tryRelease 方法。</p>
</li>
</ol>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>semaphore，countdownlatch，reentrantlock，reentrantreadwirtelock，线程池ThreadpoolExecutor有些功能是类似的（<strong>同步状态的原子性管理；线程的阻塞与解除阻塞；队列的管理</strong>），抽取出来形成一个工具类AQS，这样使用起来就方便了。（Doug lea大神）</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220426214025803.png" alt="image-20220426214025803"></p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>getState()：获取锁的标志state值</p>
</li>
<li><p>setState()：设置锁的标志state值</p>
</li>
<li><p>节点状态</p>
</li>
</ul>
<p>AQS中，有一个<strong>核心状态是waitStatus</strong>，这个代表节点的状态，决定了当前节点的后续操作，比如是否等待唤醒，是否要唤醒后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为0，等待状态</span></span><br><span class="line"><span class="comment">// 中断或超时，取消请求</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在同步队列中，后继节点等待当前节点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在条件队列中，等待唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 传播：应将releaseShared传播到其他节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目的是为了去获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果成功获得到锁，则没有必要进入到队列排队</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//前面方法失败，这个时候就需要把当前线程挂起，放入到阻塞队列中</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tryAcquire(int)：独占方式获取锁。尝试获取资源，成功则返回true，失败则返回false。</p>
<p>（1）调用<strong>子类tryAcquire</strong>尝试获取锁，获取成功，直接返回</p>
<p>（2）否则，将当前线程封装成节点加入FIFO队列末尾</p>
<p>addWaiter是进入队列的操作，其主要流程是新建节点然后将新节点CAS排到队列尾部，</p>
<p>而acquireQueued的职责是线程进入队列之后的操作，继续获取锁？还是阻塞？还是唤醒其他结点？<br> // 1：通过不断的自旋尝试使自己前一个节点的状态变成 signal，然后阻塞自己。<br>// 2：获得锁的线程执行完成之后，释放锁时，会把阻塞的 node 唤醒,node 唤醒之后再次自旋，尝试获得锁<br>// 返回 false 表示获得锁成功，返回 true 表示失败<br>此方法的核心：shouldParkAfterFailedAcquire，这个方法的主要目的就是把前一个节点的状态置为 SIGNAL，只要前一个节点的状态是 SIGNAL，当前节点就可以阻塞了（parkAndCheckInterrupt 就是使节点阻塞的方法）</p>
</blockquote>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zeo5Zeo55qE6L-35a2Q,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AQS就是负责线程进入同步队列以后的逻辑，如何如何阻塞？如何唤醒？</span><br><span class="line">获取node节点的前驱节点，判断其是否是head,是则继续抢锁（可能刚入队列就排在head后面，也有可能自旋后，有其他节点获取锁出队列，而使得node排在head后面），抢锁成功则出队换头。</span><br><span class="line">     </span><br><span class="line">阻塞判断shouldParkAfterFailedAcquire，什么情况下应该阻塞线程？什么情况下应该再给一次抢锁的机会？<span class="number">3</span>种情况：</span><br><span class="line">     判断node的前驱节点waitStatus=SIGNAL（这里和CLH锁自旋检测前驱状态一样），node的线程就放心阻塞。</span><br><span class="line">     node前驱节点被取消了，waitStatus=<span class="number">1</span>，再自旋一次</span><br><span class="line">     node的前驱节点waitStatus=<span class="number">0</span>或者waitStatus=PROPAGATE，此时将node前驱节点waitStatus设置为SIGNAL，然后再给一次自旋的机会。</span><br><span class="line">     </span><br><span class="line">shouldParkAfterFailedAcquire判断应该阻塞线程，则调用parkAndCheckInterrupt，其内部调用LockSupport.park(<span class="keyword">this</span>)阻塞当前线程。LockSupport对UNSAFE中的park、unpark进行了封装，其能精准阻塞一个线程其能精准阻塞一个线程，也能精准唤醒一个线程（不同于wait和notify）</span><br></pre></td></tr></table></figure>

<ul>
<li>tryRelease(int)：独占方式释放锁。尝试释放资源，成功则返回true，失败则返回false。</li>
</ul>
<blockquote>
<p>调用<strong>子类tryRelease</strong>尝试释放锁，没有释放成功直接返回false；</p>
<p>释放成功，doReleaseShared唤醒后续节点，如果节点为null，则反向遍历有效节点。（通过unparkSuccessor方法唤醒等待队列中的下一个线程，unparkSuccessor方法里面LockSupport.unpark）</p>
</blockquote>
<p><strong>ReentrantLock示例</strong></p>
<p><strong>tryAcquire逻辑</strong></p>
<p><a href="https://s2.51cto.com/oss/202105/11/418bbeedb23a9aed06785e03b6f33e8d.jpg"><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/418bbeedb23a9aed06785e03b6f33e8d.jpg" alt="img"></a></p>
<p><strong>tryRelease逻辑</strong> </p>
<p><a href="https://s3.51cto.com/oss/202105/11/4a3216755ef548f35b559eb15ee19ee5.jpg"><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4a3216755ef548f35b559eb15ee19ee5.jpg" alt="img"></a></p>
<ul>
<li>tryAcquireShared</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>与排斥锁的tryAcquire方法不同，<strong>tryAcquireShared的返回值是整型，而不是布尔型，返回值可以对应3种情形。</strong></p>
<ol>
<li>负数： 失败，doAcquireShared进入等待队列，等待获取资源。</li>
<li>0：成功，但是其他线程无法再成功</li>
<li><strong>正数：成功，且其他线程也可能成功</strong></li>
</ol>
<p>由于共享锁允许多个线程同时获取成功，因此可以用 返回值代表还能有几个线程可以继续获取资源，但并不是强制性的。</p>
<p>线程获 得排它锁的时候，仅仅把自己设置为同步队列的头节点即可，但如果是共享锁的话，还会去唤醒 自己的后续节点，一起来获得该锁，通过<strong>doReleaseShared也就是唤醒队列的等待节</strong>点，这”共享精神”值得钦佩哦。</p>
</blockquote>
<ul>
<li>tryReleaseShared</li>
</ul>
<blockquote>
<p>首先去尝试释放资源<strong>tryReleaseShared</strong>(arg)，如果释放成功了，就代表有资源空闲出来，那么就用<strong>doReleaseShared</strong>()去唤醒后续结点（尽可能唤醒队列中所有的节点，而被唤醒的线程又会帮助去唤醒其他线程，包括新加入的节点，直到队列中只有head）。</p>
<p>在自旋的阶段，每一次循环的过程都是首先<strong>获得头结点</strong>，如果头结点不为空且不为尾结点(阻塞队列里面只有一个结点)，那么先获得该节点的状态。<br>    如果是SIGNAL的状态，则代表它需要有后继结点去唤醒，首先将其的状态变为0，因为是要释放资源了，它也不需要做什么了，所以转变为初始状态，然后去唤醒后继结点unparkSuccessor(h)，<br>    如果结点状态一开始就是0，那么就给他转换成PROPAGATE状态，保证在后续获取资源的时候，还能够向后面传播<br>    如果自旋过程中，头结点改变了，那么就退出循环过程。（只要在某个循环的过程中有线程刚获取了锁且设置了新head，就会再次循环。目的当然是为了再次执行<code>unparkSuccessor(h)</code>，即唤醒队列中第一个等待的线程。）</p>
</blockquote>
<ul>
<li>公平与非公平</li>
</ul>
<p>非公平锁（NonfairSync  ）是每次tryAcquire时如果当前资源处于0，没有被占有的状态，每个线程都有机会去获取锁，而公平锁（FairSync ）在tryAcquire中哪怕资源没被占有，也只有队首的元素有资格去获取锁。</p>
<p><img src="/2021/01/02/1.6.0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220427160538778.png" alt="image-20220427160538778"></p>
<ul>
<li>singal与singalAll</li>
</ul>
<p>singal：唤醒条件队列中的节点，实际上就是把条件队列中的头节点转移到 同步队列中，并把其前置节点状态置为 SIGNAL。</p>
<p>singalAll：其本质就是 for 循环调用 transferForSignal 方法</p>
<p><em><strong>描述下线程入、出同步队列的时机和过程？</strong></em> </p>
<p>答：(排它锁为例)从 AQS 整体架构图中，可以看出同步队列入队和出队都是有两个箭头指向，所以入队和出队的时机各有两个。 </p>
<p>同步队列入队时机： </p>
<p>\1. 多个线程请求锁，<strong>获取不到锁</strong>的线程需要到同步队列中排队阻塞； </p>
<p>\2. <strong>条件队列中的节点被唤醒</strong>，会从条件队列中转移到同步队列中来。 </p>
<p>同步队列出队时机：</p>
<ol>
<li><p><strong>锁释放</strong>时，头节点出队； </p>
</li>
<li><p><strong>获得锁的线程，进入条件队列时，会释放锁</strong>，同步队列头节点开始竞争锁。</p>
</li>
</ol>
<p><em><strong>条件队列中的元素入队和出队的时机和过程？</strong></em> </p>
<p>答：入队时机：执行 <strong>await</strong> 方法时，当前线程会释放锁，并进入到条件队列。 </p>
<p><strong>出队</strong>时机：执行 signal、signalAll 方法时，<strong>节点会从条件队列中转移到同步队列</strong>中。</p>
<p><em><strong>为什么* <em>AQS</em> *有了同步队列之后，还需要条件队列？</strong></em> </p>
<p>答：的确，一般情况下，我们只需要有同步队列就好了，但在上锁后，需要操作队列的场景下， 一个同步队列就搞不定了，<strong>需要条件队列进行功能补充</strong>，比如当<strong>队列满</strong>时，执行 <strong>put</strong> 操作的线程 会进入条件队列等待，当<strong>队列空</strong>时，执行 <strong>take 操作</strong>的线程也会进入条件队列中等待，从一定程 度上来看，条件队列是对同步队列的场景功能补充。</p>
<p><em><strong>描述一下条件队列中的节点转移到同步队列中去的时机和过程？</strong></em></p>
<p>答：时机：当有线程执行 signal、signalAll 方法时，从条件队列的头节点开始，转移到同步队列 中去。 </p>
<p>过程主要是以下几步： </p>
<ol>
<li><p>找到<strong>条件队列的头节点</strong>，头节点 next 属性<strong>置为 null</strong>，从条件队列中移除了；</p>
</li>
<li><p>头节点追加到<strong>同步队列的队尾</strong>； </p>
</li>
<li><p>头节点状态（waitStatus）从 CONDITION 修改成 <strong>0（初始化状态</strong>）； </p>
</li>
<li><p>将节点的<strong>前一个节点状态置为 SIGNAL</strong>。</p>
</li>
</ol>
<h2 id="（十）并发场景题"><a href="#（十）并发场景题" class="headerlink" title="（十）并发场景题"></a>（十）并发场景题</h2><h4 id="共享资源初始化"><a href="#共享资源初始化" class="headerlink" title="共享资源初始化"></a>共享资源初始化</h4><p>在分布式的系统中，我们喜欢把一些死的配置资源在项目启动的时候加锁到 JVM 内存里面去， 这样请求在拿这些共享配置资源时，就可直接从内存里面拿，不必每次都从数据库中拿，减少了 时间开销。</p>
<p>共享资源初始化的步骤一般为：项目启动 -&gt; 触发初始化动作 -&gt;单线程从数据库中捞取数据 -&gt; 组 装成我们需要的数据结构 -&gt; 放到 JVM 内存中。</p>
<p>在项目启动时，为了防止共享资源被多次加载，我们往往会加上排它锁，让一个线程加载共享资 源完成之后，另外一个线程才能继续加载，此时的排它锁我们可以选择 synchronized 或者 ReentrantLock。</p>
<p>有的同学可能会问，不是可以直接使用了 ConcurrentHashMap 么，为什么还需要加锁呢？的确 ConcurrentHashMap 是线程安全的，但它只能够保证 Map 内部数据操作时的线程安全，是无法 保证多线程情况下，<strong>查询数据库并组装数据的整个动作只执行一次的</strong>，我们加 synchronized 锁 住的是整个操作，保证整个操作只执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; SHARED_MAP = Maps.newConcurrentMap();</span><br><span class="line"><span class="comment">// 有无初始化完成的标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> loaded = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化共享资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostConstruct</span>	<span class="comment">//作用是在Spring 容器初始化时，再执行该注解打上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(loaded)&#123;</span><br><span class="line">  	<span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 再次 check</span></span><br><span class="line">    <span class="keyword">if</span>(loaded)&#123;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;SynchronizedDemo init begin&quot;</span>);</span><br><span class="line">    <span class="comment">// 从数据库中捞取数据，组装成 SHARED_MAP 的数据格式</span></span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    log.info(<span class="string">&quot;SynchronizedDemo init end&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量退款"><a href="#批量退款" class="headerlink" title="批量退款"></a>批量退款</h4><p>场景：</p>
<p>1：小明在淘宝上买了一个商品，觉得不好，把这个商品退掉(商品还没有发货，只退钱)，我们 叫做单商品退款，单商品退款在后台系统中运行时，整体耗时 30 毫秒。 </p>
<p>2：双 11，小明在淘宝上买了 40 个商品，生成了同一个订单（实际可能会生成多个订单，为了 方便描述，我们说成一个），第二天小明发现其中 30 个商品是自己冲动消费的，需要把 30 个 商品一起退掉。</p>
<p>前提：</p>
<p>此时后台只有单商品退款的功能，没有批量商品退款的功能。</p>
<p>解决：</p>
<ul>
<li>for 循环调用 30 次单商品退款的接口，</li>
<li>把任务都提交到线程池里面去</li>
</ul>
<p>向线程池提交了 30 个 任务后，主线程如何等待 30 个任务都执行完成呢？如何拿到执行结果？</p>
<ul>
<li>加CountDownLatch ，让主线程去等待子任务全部执行完 成之后才继续执行。</li>
</ul>
<blockquote>
<p>用 Runnable 作为线程任务就不 行了，因为 Runnable 是没有返回值的，我们需要选择 Callable 作为任务。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>1.5.1设计模式</title>
    <url>/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>可参考：</p>
<p>概念？</p>
<blockquote>
<p>代表了最佳的实践。它是众多软件开发人员经过相当长的一段时间的试验总结出来的。是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
</blockquote>
<p>为什么需要？</p>
<blockquote>
<p>为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</blockquote>
<span id="more"></span>

<h3 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h3><ul>
<li>单一原则：一个类或者一个方法只负责一项职责。</li>
<li>里氏替换原则：子类可以扩展父类的功能，但不能改变原有父类的功能。</li>
<li>依赖倒置原则：面向接口编程（变量或者传参数，尽量使用抽象类，或者接口)</li>
<li>接口隔离原则：建立单一接口（复杂的接口，根据业务拆分成多个简单接口）</li>
<li>迪米特原则：最少知道原则，尽量降低类与类之间的耦合，一个对象应该对其他对象有最少的了解。</li>
<li>开闭原则：对扩展开放，对修改闭合</li>
</ul>
<p><strong>类装载的时机</strong></p>
<ul>
<li><p>new一个对象时</p>
</li>
<li><p>使用反射创建它的实例时</p>
</li>
<li><p>子类被加载时，如果父类还没有加载，就先加载父类</p>
</li>
<li><p>JVM启动时，执行主类会先被加载</p>
</li>
</ul>
<h3 id="1-单例模式⭐️"><a href="#1-单例模式⭐️" class="headerlink" title="1.单例模式⭐️"></a>1.单例模式⭐️</h3><blockquote>
<p>某个类只能有一个实例，提供一个全局的访问点。</p>
<p>优点：节省内存，加快对象访问速度</p>
<p>缺点：单例类的职责过重，在一定程度上违背了“单一职责原则”。 </p>
</blockquote>
<p>手写双重检验单例模式 懒汉式，DCL</p>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/v2-e18571b5dd02bcad4e123a1a3935a72a_r.jpg" alt="preview"></p>
<h3 id="（1）饿汉式（推荐）"><a href="#（1）饿汉式（推荐）" class="headerlink" title="（1）饿汉式（推荐）"></a>（1）饿汉式（推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton(); <span class="comment">//私有化实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点：由于instance的初始化是在类加载时进行的，类加载是由ClassLoader来实现的，如果初始化太早，就会造成资源浪费。</span></span><br><span class="line"><span class="comment">//当然，如果所需的单例占用的资源很少，这种实现也可以的</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）懒汉式"><a href="#（2）懒汉式" class="headerlink" title="（2）懒汉式"></a>（2）懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程不安全)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//缺点：如果有两个线程同时运行到 if (singleton == null)，都判断为null</span></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给类对象加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;	<span class="comment">//对其他线程可见volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;<span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双重校验单例模式(DCL)：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;	<span class="comment">//双重校验</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;	<span class="comment">//双重校验</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有两个线程同时运行到 if (singleton == null)，都判断为null，最终两个线程就各自会创建一个实例出来。</p>
<p>所以需要加上synchronized关键字之后，getInstance方法就会锁上了。但是，这种写法虽然避免了可能会出现的多个实例问题，但是会强制除T1之外的所有线程等待，影响程序效率，于是有了双重校验的单例模式。</p>
<p>第一个 if(instance==null)，其实是为了解决代码二中的效率问题，只有instance为null的时候才进入synchronized的代码段大大减少了几率。</p>
<p>第二个if(instance==null)，则是为了防止可能出现多个实例的情况。</p>
<p>缺点：    第一次加载时反应不快，由于java内存模型一些原因偶尔失败 </p>
</blockquote>
<h3 id="（3）静态内部类"><a href="#（3）静态内部类" class="headerlink" title="（3）静态内部类"></a>（3）静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;	<span class="comment">//内部类SingletonHolder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();<span class="comment">//饿汉式</span></span><br><span class="line">  &#125;	<span class="comment">//static final Singleton</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;	<span class="comment">//外部类调用时才加载，懒汉式</span></span><br><span class="line">  <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于内部类SingletonHolder，它是一个饿汉式的单例实现。在SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真单例。</p>
<p>同时，由于SingletonHolder是一个内部类，只在外部类的Singleton的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。</p>
<p>它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现。</p>
<p>缺点：    第一次加载时反应不够快 </p>
</blockquote>
<h3 id="（4）枚举"><a href="#（4）枚举" class="headerlink" title="（4）枚举"></a>（4）枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SingleInstance.INSTANCE.fun1();</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 自动序列化机制，保证了线程的绝对安全。</p>
<p><strong>简单、高效、安全</strong>。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<p><strong>序列化</strong>是将一个对象转化为一个二进制表示的字节数组，通过保存或则转移这些二进制数组达到持久化的目的。</p>
</blockquote>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul>
<li>线程池：httpsession，数据库，redis，MQ连接池</li>
<li>网站的计数器</li>
<li>任务管理器</li>
<li>回收站</li>
<li>Spring 的 ApplicationContext 创建的 <strong>Bean</strong> 实例都是单例对象，还有 <strong>ServletContext</strong></li>
</ul>
<blockquote>
<p>⚠️Spring框架对单例的支持是采用单例注册表的方式进行实现的</p>
<p>饿汉和懒汉都有一个缺点，<strong>单例不能被继承</strong>。而<em>单例注册表</em>的构造函数是protected。</p>
</blockquote>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<h3 id="2-简单工厂模式⭐️"><a href="#2-简单工厂模式⭐️" class="headerlink" title="2.简单工厂模式⭐️"></a>2.简单工厂模式⭐️</h3><blockquote>
<p>一个工厂类根据<strong>传入的参数决定</strong>创建出那一种产品类的实例。（用来生产同一等级结构中的任意产品）</p>
<p>终极目的：<strong>解耦：把对象的创建和使用的过程分开，并且大大简化了实例化时的初始化设置</strong></p>
<p>缺点：工厂类太简单——无法满足开闭原则，对多个产品的扩展不利</p>
<p>一个工厂生产多个产品（塑料桌子，木质桌子等等）</p>
</blockquote>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Spring 中的 <strong>BeanFactory</strong> 使用简单工厂模式，根据传入一个唯一的标识来获得 Bean 对象。</p>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220329161907086.png" alt="image-20220329161907086"></p>
<p>栗子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-工厂方法模式⭐️"><a href="#3-工厂方法模式⭐️" class="headerlink" title="3.工厂方法模式⭐️"></a>3.工厂方法模式⭐️</h3><blockquote>
<p>工厂方法模式，有了进步，把工厂类进行改进，提升为一个抽象类（接口），把对具体产品的实现交给对应的具体的子类去做，<strong>解耦</strong>多个产品之间的业务逻辑。（用来生产同一等级结构中的固定产品）</p>
<p>对应工厂生产对应产品。（工厂抽象）</p>
<p>例子：塑料桌子工厂，木质桌子工厂</p>
</blockquote>
<h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>MyBatis中使用的比较多，<strong>事务模块和数据源模块</strong>都使用了工厂方法模式。</p>
<p>Spring 的 <strong>FactoryBean</strong> 接口的 <code>getObject</code> 方法也是工厂方法</p>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220329163202614.png" alt="image-20220329163202614"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractFactory af = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">            Product a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4.抽象工厂模式"></a>4.抽象工厂模式</h3><blockquote>
<p>前面都是针对一个产品族的设计，如果有多个产品族的话，就可以使用抽象工厂模式。（用来生产不同产品族的全部产品）<strong>目标是一套产品：塑料桌子和木质椅子</strong>，塑料桌子和塑料椅子等等。</p>
<p>对应工厂生产对应产品。此时（产品再抽象）</p>
<p>抽象工厂，具体工厂；抽象产品，具体产品</p>
</blockquote>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-1Q11416002NW.gif" alt="抽象工厂模式的结构图"></p>
<h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><p>java.sql.<strong>Connection</strong> 接口就是一个抽象工厂，其中包括很多抽象产品如 <strong>Statement</strong>、Blob、Savepoint 等</p>
<p><strong>区别</strong></p>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1242094-20181129074638111-1477347512.png" alt="img"></p>
<blockquote>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）</p>
<p> 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）<br> 抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）    </p>
</blockquote>
<p><strong>共同目的</strong></p>
<blockquote>
<p>解耦</p>
</blockquote>
<h3 id="5-代理模式⭐️"><a href="#5-代理模式⭐️" class="headerlink" title="5.代理模式⭐️"></a>5.代理模式⭐️</h3><p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330160037475.png" alt="image-20220330160037475"></p>
<blockquote>
<p>作用：中介隔离作用。开闭原则，增加功能</p>
<p>假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。</p>
<p>概念：为其他对象提供一个代理以便控制这个对象的访问。</p>
<p><strong>对象：抽象角色，代理角色和真实角色</strong>。</p>
<p>优点：能将代理对象与真实被调用的目标对象<strong>分离</strong>，<strong>可以对目标对象的功能增强</strong>。</p>
<p>缺点：<strong>1）代码冗余。2）不易维护</strong>。一旦接口增加方法，目标对象与代理对象都要进行修改</p>
</blockquote>
<h4 id="静态代理VS动态代理"><a href="#静态代理VS动态代理" class="headerlink" title="静态代理VS动态代理"></a>静态代理VS动态代理</h4><p>所谓静态代理中的“静”字，无非就是<strong>代理类的创建时机不同</strong>罢了。<br><strong>（1）灵活性</strong> ：动态代理更加灵活，<strong>不需要必须实现接口，可以直接代理实现类</strong>，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</p>
<p><strong>（2）JVM 层面</strong> ：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li><strong>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法</strong>。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<h5 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a><strong>栗子</strong></h5><p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl``send()</code></p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><blockquote>
<p>jdk动态代理模式是利用java中的<strong>反射技术，在运行时动态创建代理类</strong>。</p>
<p>基于动态jdk涉及到<strong>两个核心的类Proxy类和一个 InvocationHandler接口。</strong></p>
<p><strong>通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的method.invoke()方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<p><strong>自定义 <code>InvocationHandler </code> 并重写 <code>invoke</code> 方法</strong></p>
</blockquote>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<h5 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a><strong>栗子</strong></h5><p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<p><strong>过程</strong></p>
<p>1.定义一个接口及其实现类；</p>
<p>2.自定义代理类 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</p>
<p>3.通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</p>
<h4 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h4><blockquote>
<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在<strong>运行时对字节码进行修改和动态生成</strong>。</p>
<p><strong>CGLIB 通过继承方式实现代理</strong>。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标<strong>对象实现了接口，则默认采用 JDK 动态代理</strong>，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中  Enhancer 类和MethodInterceptor 接口是核心。</strong></p>
</blockquote>
<p>你需要<strong>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法</strong>，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="params"><span class="function">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>proxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h5 id="栗子-2"><a href="#栗子-2" class="headerlink" title="栗子"></a><strong>栗子</strong></h5><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<p><strong>过程</strong></p>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="jdk-VS-cglib"><a href="#jdk-VS-cglib" class="headerlink" title="jdk  VS  cglib"></a><strong>jdk  VS  cglib</strong></h4><p>（1）<strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong></p>
<p>（2）由于是通过“子类化”(继承)的方式， 所以不能代理声明为 final 类型的类和方法</p>
<p>（3）就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
<blockquote>
<p>cglib3.1 JDK8 在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍。</p>
</blockquote>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><p>1）保护代理</p>
<p> 在客户端请求接口时我们可能需要<strong>在调用之前对权限进行验证</strong>（<strong>防火墙</strong>）</p>
<p>2）日志记录代理</p>
<p>需要<strong>记录用户的一些操作日志信</strong>息或者通过记录接口调用前后时间，统计执行时长</p>
<blockquote>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
<p>1.为什么jdk动态代理被代理的类为什么要实现接口？</p>
<p> <strong>因为Java是单继承的,而代理类又必须继承自Proxy类,所以通过jdk代理的类必须实现接口.</strong></p>
</blockquote>
<p>3）重量级操作–虚拟代理</p>
<p> 比如创建开销大，一些占用系统资源较多或者加载时间较长的对象（ IO对象，图片文件）</p>
<p>4）远程代理</p>
<p>RPC，Dubbo</p>
<p>5）缓存代理</p>
<p>为某一个操作的结果<strong>提供临时的缓存存储空间</strong>，以便在<strong>后续使用中能够共享这些结果</strong>，从而可以避免某些方法的重复执行，优化系统性能。</p>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220329214851788.png" alt="image-20220329214851788"></p>
<h3 id="6-适配器模式⭐️"><a href="#6-适配器模式⭐️" class="headerlink" title="6.适配器模式⭐️"></a>6.适配器模式⭐️</h3><p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330164154768.png" alt="image-20220330164154768"></p>
<blockquote>
<p> 作用：为了兼容性，客户端通过适配器可以透明地调用目标接口。复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。讲中文的人同讲英文的人对话时需要一个翻译；用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p> 概念：将一个类的方法接口转换成客户希望的另外一个接口。</p>
<p> 对象：目标接口，Adapter:适配器，Adaptee：被适配的类。</p>
<p> 实现：通过<strong>关联或者继承</strong>间接访问原类</p>
<p> 装饰模式：需要<strong>修改扩展接口</strong>功能</p>
<p> 适配器模式：原有接口很好，只是客户端不兼容，做了转换而已</p>
</blockquote>
<h4 id="栗子-3"><a href="#栗子-3" class="headerlink" title="栗子"></a><strong><strong>栗子</strong></strong></h4><p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330163448556.png" alt="image-20220330163448556"></p>
<h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><p>（1）java.io 包中，InputStream 字节输入流通过适配器 InputStreamReader 转换为 Reader 字符输入流。</p>
<p>（2） Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter </code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<p>（3）Spring MVC 中的 HandlerAdapter，由于 handler 有很多种形式，包括 Controller、HttpRequestHandler、Servlet 等，但调用方式又是确定的，因此需要适配器来进行处理，根据适配规则调用 handle 方法。<br>（4）Arrays.asList 方法，将数组转换为对应的集合（注意不能使用修改集合的方法，因为返回的 ArrayList 是 Arrays 的一个内部类）。</p>
<h3 id="7-装饰者模式⭐️"><a href="#7-装饰者模式⭐️" class="headerlink" title="7.装饰者模式⭐️"></a>7.装饰者模式⭐️</h3><blockquote>
<p>作用：豆浆：加入黑糖，五谷，鸡蛋…糖豆浆，五谷豆浆…通过继承会造成类爆炸</p>
<p>概念：<strong>动态的给对象添加新的功能</strong>。</p>
<p>对象：被装饰者，被装饰者接口，装饰抽象类，装饰实现类</p>
</blockquote>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330155907010.png" alt="image-20220330155907010"></p>
<h4 id="栗子-4"><a href="#栗子-4" class="headerlink" title="栗子"></a><strong>栗子</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被装饰者的对象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的被装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dounai</span> <span class="keyword">implements</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;纯豆奶&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰者的基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decroator</span> <span class="keyword">implements</span> <span class="title">Drink</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink drink; <span class="comment">//要装饰的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decroator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> drink.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  drink.desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blackdou</span> <span class="keyword">extends</span> <span class="title">Decroator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blackdou</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost()+<span class="number">2f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.desc()+<span class="string">&quot;+黑豆&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的装饰者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SugarDecroator</span> <span class="keyword">extends</span> <span class="title">Decroator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SugarDecroator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost()+<span class="number">1f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.desc()+<span class="string">&quot;+糖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Drink drink = <span class="keyword">new</span> Dounai();</span><br><span class="line">        Blackdou blacktang = <span class="keyword">new</span> Blackdou(drink);</span><br><span class="line">        SugarDecroator  sugar = <span class="keyword">new</span> SugarDecroator(blacktang);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这杯豆浆价格为：&quot;</span>+sugar.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述为：&quot;</span>+sugar.desc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><p>（1）java.io 包中，InputStream 字节输入流通过装饰器 BufferedInputStream 增强为缓冲字节输入流。</p>
<p>（2）<strong>Spring 中配置 DataSource</strong> 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。</p>
<p>（3）装饰者模式对<strong>HttpServletRequest</strong>进行增强。（<strong>增强了request</strong>的编码问题以及过滤XSS）</p>
<h3 id="8-观察者模式⭐️"><a href="#8-观察者模式⭐️" class="headerlink" title="8.观察者模式⭐️"></a>8.观察者模式⭐️</h3><blockquote>
<p>作用：在被观察者和观察者之间建立一个抽象的耦合，被观察者角色所知道的只是一个具体观察者列表，一对多。它只知道它们都有一个共同的接口</p>
<p>对象：抽象主题，具体主题，抽象观察者，具体观察者</p>
</blockquote>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330171810944.png" alt="image-20220330171810944"></p>
<h4 id="栗子-5"><a href="#栗子-5" class="headerlink" title="栗子"></a><strong>栗子</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1 = <span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体目标发生改变...</span><br><span class="line">--------------</span><br><span class="line">具体观察者1作出反应！</span><br><span class="line">具体观察者2作出反应！</span><br></pre></td></tr></table></figure>

<h4 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h4><p>事件监听者角色：<strong>ServletContextListener</strong> 能够监听 ServletContext 对象的生命周期，实际上就是监听 Web 应用。当 Servlet 容器启动 Web 应用时，调用 <code>contextInitialized</code> 方法，终止时调用 <code>contextDestroyed</code> 方法。（还有ApplicationListener）</p>
<p><strong>当系统一方行为依赖另一方行为的变动时</strong>，可使用观察者模式松耦合联动双方。例如：<strong>下订单完后，发送短信，送优惠券</strong>….</p>
<h3 id="9-模板方法模式⭐️"><a href="#9-模板方法模式⭐️" class="headerlink" title="9.模板方法模式⭐️"></a>9.模板方法模式⭐️</h3><blockquote>
<p>作用：用模板方法<strong>将相同处理逻辑的代码放到抽象父类</strong>中,可以提高代码的复用性</p>
<p>对象：抽象类（具体方法，抽象方法1，抽象方法2），实现类</p>
</blockquote>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330171944675.png" alt="image-20220330171944675"></p>
<h4 id="栗子-6"><a href="#栗子-6" class="headerlink" title="栗子"></a><strong>栗子</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass tm = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 程序的运行结果如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象类中的具体方法被调用...</span><br><span class="line">抽象方法1的实现被调用...</span><br><span class="line">抽象方法2的实现被调用...</span><br></pre></td></tr></table></figure>

<h4 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h4><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是<strong>使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</strong></p>
<p>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。</p>
<h3 id="10-建造者模式"><a href="#10-建造者模式" class="headerlink" title="10.建造者模式"></a>10.建造者模式</h3><blockquote>
<p>作用：封装一个<strong>复杂对象的构建过程</strong>，并可以按步骤构造。</p>
<p>对象：产品角色，抽象建造者，具体建造者，指挥者</p>
<p>建造者模式更加<strong>注重方法的调用顺序</strong>，工厂模式<strong>注重创建对象</strong>。</p>
</blockquote>
<p><img src="/2021/01/02/1.5.1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220330172753766.png" alt="image-20220330172753766"></p>
<h4 id="栗子-7"><a href="#栗子-7" class="headerlink" title="栗子"></a><strong>栗子</strong></h4><p> (1) 产品角色：包含多个组成部件的复杂对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> (3) 具体建造者：实现了抽象建造者接口。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5) 客户类。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h4><p> <strong>相同的方法，不同的执行顺序，产生不同的结果</strong>。</p>
<p> 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</p>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>可迁移场景下的数字文档管理系统</title>
    <url>/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="可迁移场景下的数字文档管理系统"><a href="#可迁移场景下的数字文档管理系统" class="headerlink" title="可迁移场景下的数字文档管理系统"></a>可迁移场景下的数字文档管理系统</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701183305806.png" alt="image-20220701183305806"></p>
<span id="more"></span>

<h4 id="档案利用模块"><a href="#档案利用模块" class="headerlink" title="档案利用模块"></a>档案利用模块</h4><h5 id="统计演示"><a href="#统计演示" class="headerlink" title="统计演示"></a>统计演示</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701183439630.png" alt="image-20220701183439630"></p>
<h4 id="档案管理模块"><a href="#档案管理模块" class="headerlink" title="档案管理模块"></a>档案管理模块</h4><h5 id="识别演示"><a href="#识别演示" class="headerlink" title="识别演示"></a>识别演示</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701183510703.png" alt="image-20220701183510703"></p>
<h5 id="自动归档"><a href="#自动归档" class="headerlink" title="自动归档"></a>自动归档</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701184049328.png" alt="image-20220701184049328"></p>
<p>归档结果</p>
<p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701184403079.png" alt="image-20220701184403079"></p>
<h5 id="档案浏览"><a href="#档案浏览" class="headerlink" title="档案浏览"></a>档案浏览</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701184501194.png" alt="image-20220701184501194"></p>
<p>支持多种文档预览</p>
<p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701192552523.png" alt="image-20220701192552523"></p>
<p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701193319725.png" alt="image-20220701193319725"></p>
<h4 id="档案检索模块"><a href="#档案检索模块" class="headerlink" title="档案检索模块"></a>档案检索模块</h4><h5 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701192715246.png" alt="image-20220701192715246"></p>
<h5 id="图片检索"><a href="#图片检索" class="headerlink" title="图片检索"></a>图片检索</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701192814969.png" alt="image-20220701192814969"></p>
<h4 id="系统管理模块"><a href="#系统管理模块" class="headerlink" title="系统管理模块"></a>系统管理模块</h4><h5 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701192915921.png" alt="image-20220701192915921"></p>
<h5 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701192948947.png" alt="image-20220701192948947"></p>
<h5 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701193057505.png" alt="image-20220701193057505"></p>
<h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701193122498.png" alt="image-20220701193122498"></p>
<h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><p><img src="/2022/04/06/%E5%8F%AF%E8%BF%81%E7%A7%BB%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220701193136870.png" alt="image-20220701193136870"></p>
]]></content>
      <categories>
        <category>项目作品</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>在线人脸识别考勤小程序开发</title>
    <url>/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="在线人脸识别考勤小程序开发"><a href="#在线人脸识别考勤小程序开发" class="headerlink" title="在线人脸识别考勤小程序开发"></a>在线人脸识别考勤小程序开发</h3><h4 id="（一）注册功能"><a href="#（一）注册功能" class="headerlink" title="（一）注册功能"></a>（一）注册功能</h4><h5 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220701174040447.png" alt="image-20220701174040447"></p>
<span id="more"></span>

<h5 id="流程⭐️"><a href="#流程⭐️" class="headerlink" title="流程⭐️"></a>流程⭐️</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220701174152221.png" alt="image-20220701174152221"></p>
<h4 id="（二）登录"><a href="#（二）登录" class="headerlink" title="（二）登录"></a>（二）登录</h4><h5 id="页面-1"><a href="#页面-1" class="headerlink" title="页面"></a>页面</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220701174406856.png" alt="image-20220701174406856"></p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220701175004746.png" alt="image-20220701175004746"></p>
<h5 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220702105215070.png" alt="image-20220702105215070"></p>
<h4 id="（三）人脸考勤签到"><a href="#（三）人脸考勤签到" class="headerlink" title="（三）人脸考勤签到"></a>（三）人脸考勤签到</h4><h5 id="页面-2"><a href="#页面-2" class="headerlink" title="页面"></a>页面</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220701174620303.png" alt="image-20220701174620303"></p>
<h5 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h5><p><img src="/2022/06/01/%E5%9C%A8%E7%BA%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%80%83%E5%8B%A4%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/image-20220220120109370.png" alt="image-20220701174620303"></p>
]]></content>
      <categories>
        <category>项目作品</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>实习经历</title>
    <url>/2022/02/02/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h3><h4 id="1-EMS制造管理系统MFC界面设计"><a href="#1-EMS制造管理系统MFC界面设计" class="headerlink" title="(1) EMS制造管理系统MFC界面设计"></a><strong>(1)</strong> EMS制造管理系统MFC界面设计</h4><p><img src="/2022/02/02/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/wps1.png" alt="img"></p>
 <span id="more"></span>

<h4 id="2-自定义控件，双缓冲技术"><a href="#2-自定义控件，双缓冲技术" class="headerlink" title="(2) 自定义控件，双缓冲技术"></a><strong>(2)</strong> 自定义控件，双缓冲技术</h4><p><img src="/2022/02/02/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/wps2.jpg" alt="img"></p>
<p><img src="/2022/02/02/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/wps3.png" alt="img"></p>
]]></content>
      <categories>
        <category>项目作品</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>莞工教学助手</title>
    <url>/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/image-20220701153300748.png" alt="image-20220701153300748"></p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/image-20220701153519741.png" alt="image-20220701153519741"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/image-20220701153637954.png" alt="image-20220701153637954"></p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/image-20220701153709302.png" alt="image-20220701153709302"></p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/image-20220701154504633.png" alt="image-20220701154504633"></p>
<h3 id="（一）学生模块"><a href="#（一）学生模块" class="headerlink" title="（一）学生模块"></a>（一）学生模块</h3><h4 id="1-1-学生用户登录"><a href="#1-1-学生用户登录" class="headerlink" title="1.1 学生用户登录"></a><strong>1.1</strong> 学生用户登录</h4><p>输入中央认证的账号密码登录，登录后才可以查询成绩，课表等。</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps4.png" alt="img"></p>
<h4 id="1-2-学生用户点击微信授权登录"><a href="#1-2-学生用户点击微信授权登录" class="headerlink" title="1.2 学生用户点击微信授权登录"></a><strong>1.2</strong> 学生用户点击微信授权登录</h4><p> 微信登录才可以发布话题</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps5.png" alt="img"></p>
<h4 id="1-3-点击发布话题"><a href="#1-3-点击发布话题" class="headerlink" title="1.3 点击发布话题"></a><strong>1.3</strong> 点击发布话题</h4><p>点击后就可以进入发布话题界面，就可以发布话题了</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps6.png" alt="img"></p>
<h4 id="1-4-点击发送话题"><a href="#1-4-点击发送话题" class="headerlink" title="1.4 点击发送话题"></a><strong>1.4</strong> 点击发送话题</h4><p> 点击后，就可以跳转到话题列表页面</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps7.png" alt="img"></p>
<h4 id="1-5-点击点赞"><a href="#1-5-点击点赞" class="headerlink" title="1.5 点击点赞"></a><strong>1.5</strong> 点击点赞</h4><p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps8.png" alt="img"></p>
<h4 id="1-6-点击话题"><a href="#1-6-点击话题" class="headerlink" title="1.6 点击话题"></a><strong>1.6</strong> <strong>点击话题</strong></h4><p>进入话题详情页面</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps9.png" alt="img"></p>
<h4 id="1-7-点击发送评论"><a href="#1-7-点击发送评论" class="headerlink" title="1.7 点击发送评论"></a><strong>1.7</strong> 点击发送评论</h4><p>评论区就会出现评论的内容</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps10.png" alt="img"></p>
<h4 id="1-8-点击评论内容进行回复"><a href="#1-8-点击评论内容进行回复" class="headerlink" title="1.8 点击评论内容进行回复"></a><strong>1.8</strong> 点击评论内容进行回复</h4><p>评论区就会出现回复的内容</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps11.png" alt="img"></p>
<h4 id="1-9-用音频进行评论"><a href="#1-9-用音频进行评论" class="headerlink" title="1.9 用音频进行评论"></a><strong>1.9</strong> 用音频进行评论</h4><p>评论区就会出现音频的内容</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps12.png" alt="img"></p>
<h4 id="1-10-点击作业"><a href="#1-10-点击作业" class="headerlink" title="1.10 点击作业"></a><strong>1.10</strong> 点击作业</h4><p>查看作业列表</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps13.png" alt="img"></p>
<h4 id="2-11-点击学生服务中心的成绩"><a href="#2-11-点击学生服务中心的成绩" class="headerlink" title="2.11 点击学生服务中心的成绩"></a><strong>2.11</strong> 点击学生服务中心的成绩</h4><p>查看学业成绩，以此类推可以查询其他服务</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps14.png" alt="img"></p>
<h3 id="（二）倒计时小工具"><a href="#（二）倒计时小工具" class="headerlink" title="（二）倒计时小工具"></a>（二）倒计时小工具</h3><h4 id="2-1-点击添加倒计时"><a href="#2-1-点击添加倒计时" class="headerlink" title="2.1 点击添加倒计时"></a>2.1 点击添加倒计时</h4><p>输入倒数日主题，时间，就可以生成倒数日了</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps15.png" alt="img">    <img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps16.png" alt="img"></p>
<h4 id="2-2-点击某倒计数日"><a href="#2-2-点击某倒计数日" class="headerlink" title="2.2 点击某倒计数日"></a><strong>2.2</strong> 点击某倒计数日</h4><p>进入倒数日详情，可以进行修改</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps17.png" alt="img"></p>
<h3 id="（三）教师模块"><a href="#（三）教师模块" class="headerlink" title="（三）教师模块"></a>（三）教师模块</h3><h4 id="3-1-教师用户登录"><a href="#3-1-教师用户登录" class="headerlink" title="3.1 教师用户登录"></a><strong>3.1</strong> 教师用户登录</h4><p>输入中央认证的账号密码登录，登录后才可以查询成绩，课表等。</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps18.png" alt="img"></p>
<h4 id="3-2-教师点击用户微信授权登录"><a href="#3-2-教师点击用户微信授权登录" class="headerlink" title="3.2 教师点击用户微信授权登录"></a><strong>3.2</strong> 教师点击用户微信授权登录</h4><p> 微信登录才可以发布作业</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps19.png" alt="img"><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps20.png" alt="img"></p>
<h4 id="3-3-教师点击课表"><a href="#3-3-教师点击课表" class="headerlink" title="3.3 教师点击课表"></a><strong>3.3</strong> 教师点击课表</h4><p>查看课表信息</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps21.png" alt="img"></p>
<h4 id="3-4-教师点击数字图像处理的学生名单时"><a href="#3-4-教师点击数字图像处理的学生名单时" class="headerlink" title="3.4 教师点击数字图像处理的学生名单时"></a><strong>3.4</strong> 教师点击数字图像处理的学生名单时</h4><p>查看学生名单</p>
<p>  <img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps22.png" alt="img"><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps23.png" alt="img"> </p>
<h4 id="3-5-教师用户点击数字图像处理实验二的作业提交情况时"><a href="#3-5-教师用户点击数字图像处理实验二的作业提交情况时" class="headerlink" title="3.5 教师用户点击数字图像处理实验二的作业提交情况时"></a><strong>3.5</strong> 教师用户点击数字图像处理实验二的作业提交情况时</h4><p>查看 ftp 上作业的提交情况</p>
<p><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps24.png" alt="img"><img src="/2022/03/02/%E8%8E%9E%E5%B7%A5%E6%95%99%E5%AD%A6%E5%8A%A9%E6%89%8B/wps25.png" alt="img"></p>
]]></content>
      <categories>
        <category>项目作品</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
</search>
