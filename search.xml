<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法</title>
    <url>/2021/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>算法原理：从整个待排序列中选出一个元素插入到已经有序的子序列中去，得到一个有序的、元素加一的子序列，直到整个序列的待插入元素为<code>0</code>，则整个序列全部有序。</p>
<span id="more"></span>

<p>具体的实现的时候，我们一般选择第一个元素作为有序的序列，将后面的元素插入到前面有序的序列直到整个序列有序。</p>
<p>时间复杂度：插入排序在最好情况下，需要比较<code>n-1</code>次，无需交换元素，时间复杂度为<code>O(n)</code>;在最坏情况下，时间复杂度为<code>O(n^2)</code></p>
<p><img src="/2021/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&lt;a[i])<span class="comment">//找到第一个比它小的数的位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;j;k--)<span class="comment">//比它大的数全部后移</span></span><br><span class="line">                    a[k]=a[k<span class="number">-1</span>];</span><br><span class="line">                a[j]=temp;<span class="comment">//将数值附到该位置上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>算法原理：为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止</p>
<p>算法步骤：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。　　</li>
</ul>
<p>时间复杂度：无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动，</p>
<p>在最差情况下，也就是数组倒序的时候，交换次数为<code>n-1</code>次。综合下来，时间复杂度为<code>O(n^2)</code></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[temp]&gt;a[j])</span><br><span class="line">                temp=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=i)</span><br><span class="line">            <span class="built_in">swap</span>(a[temp],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>算法原理：比较相邻的元素。如果第一个比第二个大，就交换他们两个</p>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>时间复杂度分析：最优时间<code>O(n）</code>，最差时间<code>O(n^2)</code>。</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)<span class="comment">//进行几轮比较，确定位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;<span class="comment">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>算法原理：是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<p>时间复杂度：<code>O(nlogn）</code></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-9</span>,<span class="number">5</span>,<span class="number">-6</span>,<span class="number">71</span>,<span class="number">5</span>,<span class="number">-36</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">-15</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergee</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">            T[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">        T[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        T[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        a[l+i]=T[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergr_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p=l,q=mid,i=l;</span><br><span class="line">        <span class="built_in">mergr_sort</span>(l,mid);</span><br><span class="line">        <span class="built_in">mergr_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">mergee</span>(l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">mergr_sort</span>(l,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续递归的对长度较短的序列进行同样的分割，最后到达整体有序。为了实现一次划分，我们可以从数组（假定数据是存在数组中）的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止。为此，我们附设两个指针（下角标）<code>i </code>和<code> j</code>， 通过<code> j</code> 从当前序列的有段向左扫描，越过不小于基准值的记录。当遇到小于基准值的记录时，扫描停止。通过<code>i</code>从当前序列的左端向右扫描，越过小于基准值的记录。当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录 <code>a[j]</code> 与 <code>a[i]</code>。 然后，继续扫描，直至 <code>i</code> 与<code> j</code> 相遇为止。它的平均时间复杂度为<code>O(nlogn)</code>。</p>
<p>当我们每次进行分区划分时，如果每次选择的基准元素都是当前序列中最大或最小的记录，这样每次分区的时候只得到了一个新分区，另一个分区为空，并且新分区只是比分区前少一个元素，这是快速排序的最坏情况，时间复杂度上升为<code>O(n^2)</code>。</p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=a[l];</span><br><span class="line">    <span class="keyword">int</span> i=l;<span class="keyword">int</span> j=r;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=temp&amp;&amp;i&lt;j)</span><br><span class="line">            j--;<span class="comment">/*为什么要从右边，因为我们选择的基数是从左边开始选择的，开始的方向必须是要从基数的对面开始，如果你要从左边开始找那么选择基数的时候就从右边的数作为基数*/</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=temp&amp;&amp;i&lt;j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">    <span class="built_in">quicksort</span>(l,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(i+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">quicksort</span>(<span class="number">0</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归的写法：<a href="https://www.cnblogs.com/ljy2013/p/4003412.html">看解析</a></p>
<p>我们知道递归的本质就是栈，我们每次把需要转换的左边界和右边界存到栈里面，每次找到转换的位置再存到栈里面就可以了。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均O(nlogn)，它也是不稳定排序。</p>
<p><img src="/2021/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p>大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p>
<p>小顶堆：<code>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</code></p>
<p>算法步骤：</p>
<ul>
<li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
</ul>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">package sortdemo;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(arr);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.<span class="built_in">toString</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * @param arr</span></span><br><span class="line"><span class="comment">     * @param i</span></span><br><span class="line"><span class="comment">     * @param length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="几种排序算法的比较示意图"><a href="#几种排序算法的比较示意图" class="headerlink" title="几种排序算法的比较示意图"></a>几种排序算法的比较示意图</h1><p>稳定性定义：排序前后两个相等的数相对位置不变，则算法稳定。</p>
<p>比方说选择排序中在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了：如序列 5 8 5 2 9， 我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了</p>
<p><img src="/2021/10/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png"></p>
]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见的机智题</title>
    <url>/2019/08/13/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%BA%E6%99%BA%E9%A2%98/</url>
    <content><![CDATA[<h1 id="2个人拿一百个东西，一个人一次能拿1-5个，有没有必胜的方法"><a href="#2个人拿一百个东西，一个人一次能拿1-5个，有没有必胜的方法" class="headerlink" title="2个人拿一百个东西，一个人一次能拿1-5个，有没有必胜的方法"></a>2个人拿一百个东西，一个人一次能拿1-5个，有没有必胜的方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种题目是考虑倍数的问题。每次最多取 5 个最少 1 个，这样的话就考虑每次取 6，</span><br><span class="line"></span><br><span class="line">100÷6=16余4。</span><br><span class="line"></span><br><span class="line">先拿的人拿 4 个，不论第二个人拿几个，第一个人把他凑成 6 个，这样永远是第一个人取到最后一个</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="A，B从一堆玻璃球（共100个）里向外拿球，规则如下：-1-A先拿，然后一人一次交替着拿；-2-每次只能拿1个或2个或4个；-3-谁拿最后一个球，谁就是最后的失败者；问A，B谁将是失败者？"><a href="#A，B从一堆玻璃球（共100个）里向外拿球，规则如下：-1-A先拿，然后一人一次交替着拿；-2-每次只能拿1个或2个或4个；-3-谁拿最后一个球，谁就是最后的失败者；问A，B谁将是失败者？" class="headerlink" title="A，B从一堆玻璃球（共100个）里向外拿球，规则如下： (1)A先拿，然后一人一次交替着拿； (2)每次只能拿1个或2个或4个； (3)谁拿最后一个球，谁就是最后的失败者；问A，B谁将是失败者？"></a>A，B从一堆玻璃球（共100个）里向外拿球，规则如下： (1)A先拿，然后一人一次交替着拿； (2)每次只能拿1个或2个或4个； (3)谁拿最后一个球，谁就是最后的失败者；问A，B谁将是失败者？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A是失败者，证明过程如下。</span><br><span class="line">1）经验算，当谁面临着4个球的时候，谁要拿球就是失败者原因：全拿，输了；拿一个，对方拿两个，输了；拿两个，对方拿一个，输了。</span><br><span class="line">2）其余的96（16*6）个球，正好是6的倍数，假设A,在剩下4个球之前，从来没一次拿过1个球。（拿得是2、4），则B可以每次拿4或2，组成和为6的循环，直至剩下4个球给A.</span><br><span class="line">3）假设在上述96（16*6）个球中，A有过一次拿1个球，我们假设前15轮都是每轮6个球（15*6），目前的情况是，完成15轮之后，剩下10个球；</span><br><span class="line">3.1）此时A拿了1个球，B面临9个球。如可以选择1,2,4，但是B会选择拿2个球，（因为拿一个，剩下8个给对方，对方拿4个，自己就输了详见1条；拿4个，剩下5个给对方，对方拿一个，自己也输了）。</span><br><span class="line">3.2）此时A面临7个球，因为是假设A只有一次拿球，所以，A要拿2或4，结果是留给对方5或3，对方拿走4或2之后，自己肯定就输了。</span><br><span class="line">4）假设2中，A有过两次拿1个球，则B可以选择拿两次2个球，有凑成了6，只不过是多了一步，但是不打破16*6的规律。总结就是如果拿偶数次，则不会破坏16*6的趋势，如果拿奇数次，则奇数-1，归到15*6中去</span><br><span class="line">最后一次同3.</span><br></pre></td></tr></table></figure>

<h1 id="有两根不均匀分布的香，香烧完的时间是一个小时，你能用什么方法来确定一段15分钟的时间？"><a href="#有两根不均匀分布的香，香烧完的时间是一个小时，你能用什么方法来确定一段15分钟的时间？" class="headerlink" title="有两根不均匀分布的香，香烧完的时间是一个小时，你能用什么方法来确定一段15分钟的时间？"></a>有两根不均匀分布的香，香烧完的时间是一个小时，你能用什么方法来确定一段15分钟的时间？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一根香先点一端，第二根香在第一根香点燃时候同时把两端点燃，这样第二根香烧完是半小时，此时第一根香也剩半小时，在第二根香烧完的同时把第一根香的另外一端也点燃，那么从第二根香烧完到第一根香烧完的这段时间就是15分钟。</span><br></pre></td></tr></table></figure>

<h1 id="抛硬币，正面继续抛，反面不抛。问抛的次数的期望延伸到连续抛-n-次"><a href="#抛硬币，正面继续抛，反面不抛。问抛的次数的期望延伸到连续抛-n-次" class="headerlink" title="抛硬币，正面继续抛，反面不抛。问抛的次数的期望延伸到连续抛 n 次"></a>抛硬币，正面继续抛，反面不抛。问抛的次数的期望延伸到连续抛 n 次</h1><p>假设已经连续抛出 n-1 次正面，需要 Tn−1 次。想得到 n 次正面，则再进行一次投掷，若硬币为正面则游戏结束，还需要抛 0 次（Tn=Tn−1+1+0.5∗0+?Tn=Tn−1+1+0.5∗0+?）；如果硬币为反面，则游戏重来，还需要投掷0.5∗Tn0.5∗Tn次，递推公式如下所示：<br>Tn=Tn−1+1+0.5∗0+0.5∗Tn</p>
<p>求出通项公式为： Tn=2^(n+1)−2</p>
<p>在n很大时，我们可以用下面的公式来近似估计： Tn≈1/ (p^(n+1))</p>
<h1 id="网页-应用访问慢突然变慢，如何定位问题"><a href="#网页-应用访问慢突然变慢，如何定位问题" class="headerlink" title="网页/应用访问慢突然变慢，如何定位问题"></a>网页/应用访问慢突然变慢，如何定位问题</h1><p><a href="https://blog.csdn.net/weixin_34321977/article/details/93757683">答案1</a>  <a href="https://blog.csdn.net/Lv_Victor/article/details/53148421">答案2</a></p>
<h1 id="有一个日志，里面记录了客户的登入登出时间（以秒为单位），求在线人数最多的时间段以及人数。"><a href="#有一个日志，里面记录了客户的登入登出时间（以秒为单位），求在线人数最多的时间段以及人数。" class="headerlink" title="有一个日志，里面记录了客户的登入登出时间（以秒为单位），求在线人数最多的时间段以及人数。"></a>有一个日志，里面记录了客户的登入登出时间（以秒为单位），求在线人数最多的时间段以及人数。</h1><p>创建一个数组 change[ 24*3600 ] 用来记录一天中，每秒用户的变化情况，在第 i 秒上线一人change[ i ]++，在第i秒下线一人 change[ i ] - -，change[ i ] 若为正，说明这一秒上线人数大于下线人数，反之亦然。再创建一个online[ 24*3600 ]，用来记录每秒在线人数，online[ 0 ] = 0表示第 0 秒在线人数为 0，计算方法为 online[ n ] = online[ n-1 ] + change[ n ]</p>
]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
  </entry>
  <entry>
    <title>几大排序算法</title>
    <url>/2019/07/06/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>算法原理：从整个待排序列中选出一个元素插入到已经有序的子序列中去，得到一个有序的、元素加一的子序列，直到整个序列的待插入元素为<code>0</code>，则整个序列全部有序。</p>
<span id="more"></span>

<p>具体的实现的时候，我们一般选择第一个元素作为有序的序列，将后面的元素插入到前面有序的序列直到整个序列有序。</p>
<p>时间复杂度：插入排序在最好情况下，需要比较<code>n-1</code>次，无需交换元素，时间复杂度为<code>O(n)</code>;在最坏情况下，时间复杂度为<code>O(n^2)</code></p>
<p><img src="/2019/07/06/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&lt;a[i])<span class="comment">//找到第一个比它小的数的位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;j;k--)<span class="comment">//比它大的数全部后移</span></span><br><span class="line">                    a[k]=a[k<span class="number">-1</span>];</span><br><span class="line">                a[j]=temp;<span class="comment">//将数值附到该位置上</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>算法原理：为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止</p>
<p>算法步骤：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。　　</li>
</ul>
<p>时间复杂度：无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动，</p>
<p>在最差情况下，也就是数组倒序的时候，交换次数为<code>n-1</code>次。综合下来，时间复杂度为<code>O(n^2)</code></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[temp]&gt;a[j])</span><br><span class="line">                temp=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=i)</span><br><span class="line">            <span class="built_in">swap</span>(a[temp],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>算法原理：比较相邻的元素。如果第一个比第二个大，就交换他们两个</p>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>时间复杂度分析：最优时间<code>O(n）</code>，最差时间<code>O(n^2)</code>。</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)<span class="comment">//进行几轮比较，确定位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;<span class="comment">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>算法原理：是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<p>时间复杂度：<code>O(nlogn）</code></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-9</span>,<span class="number">5</span>,<span class="number">-6</span>,<span class="number">71</span>,<span class="number">5</span>,<span class="number">-36</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">-15</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergee</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">            T[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">        T[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        T[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        a[l+i]=T[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergr_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p=l,q=mid,i=l;</span><br><span class="line">        <span class="built_in">mergr_sort</span>(l,mid);</span><br><span class="line">        <span class="built_in">mergr_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">mergee</span>(l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">mergr_sort</span>(l,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续递归的对长度较短的序列进行同样的分割，最后到达整体有序。为了实现一次划分，我们可以从数组（假定数据是存在数组中）的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止。为此，我们附设两个指针（下角标）<code>i </code>和<code> j</code>， 通过<code> j</code> 从当前序列的有段向左扫描，越过不小于基准值的记录。当遇到小于基准值的记录时，扫描停止。通过<code>i</code>从当前序列的左端向右扫描，越过小于基准值的记录。当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录 <code>a[j]</code> 与 <code>a[i]</code>。 然后，继续扫描，直至 <code>i</code> 与<code> j</code> 相遇为止。它的平均时间复杂度为<code>O(nlogn)</code>。</p>
<p>当我们每次进行分区划分时，如果每次选择的基准元素都是当前序列中最大或最小的记录，这样每次分区的时候只得到了一个新分区，另一个分区为空，并且新分区只是比分区前少一个元素，这是快速排序的最坏情况，时间复杂度上升为<code>O(n^2)</code>。</p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> a[len]=&#123;<span class="number">1</span>,<span class="number">87</span>,<span class="number">64</span>,<span class="number">19</span>,<span class="number">53</span>,<span class="number">14</span>,<span class="number">57</span>,<span class="number">62</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">48</span>,<span class="number">9</span>,<span class="number">91</span>,<span class="number">45</span>,<span class="number">81</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=a[l];</span><br><span class="line">    <span class="keyword">int</span> i=l;<span class="keyword">int</span> j=r;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=temp&amp;&amp;i&lt;j)</span><br><span class="line">            j--;<span class="comment">/*为什么要从右边，因为我们选择的基数是从左边开始选择的，开始的方向必须是要从基数的对面开始，如果你要从左边开始找那么选择基数的时候就从右边的数作为基数*/</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=temp&amp;&amp;i&lt;j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">    <span class="built_in">quicksort</span>(l,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(i+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">quicksort</span>(<span class="number">0</span>,<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归的写法：<a href="https://www.cnblogs.com/ljy2013/p/4003412.html">看解析</a></p>
<p>我们知道递归的本质就是栈，我们每次把需要转换的左边界和右边界存到栈里面，每次找到转换的位置再存到栈里面就可以了。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均O(nlogn)，它也是不稳定排序。</p>
<p><img src="/2019/07/06/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p>大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p>
<p>小顶堆：<code>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</code></p>
<p>算法步骤：</p>
<ul>
<li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
</ul>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">package sortdemo;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(arr);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.<span class="built_in">toString</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * @param arr</span></span><br><span class="line"><span class="comment">     * @param i</span></span><br><span class="line"><span class="comment">     * @param length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="几种排序算法的比较示意图"><a href="#几种排序算法的比较示意图" class="headerlink" title="几种排序算法的比较示意图"></a>几种排序算法的比较示意图</h1><p>稳定性定义：排序前后两个相等的数相对位置不变，则算法稳定。</p>
<p>比方说选择排序中在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了：如序列 5 8 5 2 9， 我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了</p>
<p><img src="/2019/07/06/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png"></p>
]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>面试涉及到的一些算法题</title>
    <url>/2019/07/27/%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="House-Robber-打家劫舍"><a href="#House-Robber-打家劫舍" class="headerlink" title="House Robber 打家劫舍"></a>House Robber 打家劫舍</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<span id="more"></span>

<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>

<p>维护一个一位数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值，对当前i来说，有抢和不抢两种互斥的选择，不抢即为 dp[i-1]（等价于去掉 nums[i] 只抢 [0, i-1] 区间最大值），抢即为 dp[i-2] + nums[i]（等价于去掉 nums[i-1]）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> num.<span class="built_in">empty</span>() ? <span class="number">0</span> : num[<span class="number">0</span>];</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;num[<span class="number">0</span>], <span class="built_in">max</span>(num[<span class="number">0</span>], num[<span class="number">1</span>])&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(<span class="built_in">max</span>(num[i] + dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>有向无环图该序列必须满足下面两个条件每个顶点出现且只出现一次。若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。当然有向无环图（DAG）才有拓扑排序。</p>
<p><img src="/2019/07/27/%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98/3.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"><span class="keyword">int</span> indrgee[maxn];</span><br><span class="line"><span class="keyword">int</span> order[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//找到初始情况下入度为0的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indrgee[i]==<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        order[cnt++]=temp;</span><br><span class="line">        <span class="keyword">int</span> len=v[temp].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indrgee[v[temp][i]]--;</span><br><span class="line"><span class="comment">//每次删去该顶点和所有以它为起点的有向边故对应点的入度减一，如果为0，就放入队列</span></span><br><span class="line">            <span class="keyword">if</span>(indrgee[v[temp][i]]==<span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(v[temp][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,order[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,order[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i].<span class="built_in">clear</span>();</span><br><span class="line">            indrgee[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            v[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            indrgee[b]++;<span class="comment">//对应的入度加1.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">toposort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有多个集合，有交集的就合并，输出合并后的结果。"><a href="#有多个集合，有交集的就合并，输出合并后的结果。" class="headerlink" title="有多个集合，有交集的就合并，输出合并后的结果。"></a>有多个集合，有交集的就合并，输出合并后的结果。</h1><p>思路很简单，就是对于多个集合进行排序，x 相同 y 小的放前面，否则 x 小的放前面。</p>
<p>然后一遍遍历，我维护当前集合的最右边的值 tempy，如果 tempy 大于下一个集合的初始点的值说明这两个集合有交集，更新 tempy 的值，否则更新 tempy 值为下一个集合的最右边的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Node node[maxn];</span><br><span class="line">vector&lt;Node&gt;v;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;node[i].x, &amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, node[i].x, node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tempx = node[<span class="number">0</span>].x;</span><br><span class="line">    <span class="keyword">int</span> tempy = node[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempy &gt; node[i].x) &#123;</span><br><span class="line">            tempy = node[i].y;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node temp;</span><br><span class="line">            temp.x = tempx;</span><br><span class="line">            temp.y = tempy;</span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            tempx = node[i].x;</span><br><span class="line">            tempy = node[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp;</span><br><span class="line">    temp.x = tempx;</span><br><span class="line">    temp.y = tempy;</span><br><span class="line">    v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, v[i].x, v[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语"><a href="#给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语" class="headerlink" title="给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语"></a>给一个词典的集合，一组不重复字母，问这些字母可以组成几个词语</h1><p>先 Hash 一下字母，然后遍历和这个词典的集合，对于每个词语去 Hash 里面查一下，都有就能组成。</p>
<p>时间复杂度是O(集合的词语的长度之和)</p>
<h1 id="有序的数组中找到某一目标值首次出现的下标"><a href="#有序的数组中找到某一目标值首次出现的下标" class="headerlink" title="有序的数组中找到某一目标值首次出现的下标"></a>有序的数组中找到某一目标值首次出现的下标</h1><p>给定一个升序的数组，这个数组中可能含有相同的元素，并且给定一个目标值。要求找出目标值在数组中首次出现的下标。<br>思想：题目给出有序数组，应该想到利用二分查找来做。找到左邻居，使其值加一。利用二分查找，算法复杂度为O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findsearch</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> length, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length<span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p[right - <span class="number">1</span>] &lt; target&amp;&amp;length&lt;<span class="number">0</span>&amp;&amp;p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123; <span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> target =<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">findsearch</span>(p, length, target);</span><br><span class="line">    cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到有序数组中某一目标值在数组中的开始下标以及终止下标以及目标值出现的次数，也是同样的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//查找指定数字在有序数组中出现的次数，isLeft标记最左和最右</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindCntofNum</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> num, <span class="keyword">bool</span> isLeft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)<span class="comment">//二分查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; num)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; num)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = mid;</span><br><span class="line">            <span class="keyword">if</span> (isLeft)<span class="comment">//查找最左值</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//查找最右值</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;<span class="comment">//返回最终查找到的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">7</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span> ,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> left, right, dst;</span><br><span class="line">    left = <span class="built_in">FindCntofNum</span>(a, <span class="number">7</span>, <span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">    right = <span class="built_in">FindCntofNum</span>(a, <span class="number">7</span>, <span class="number">4</span>, <span class="literal">false</span>);</span><br><span class="line">    dst = right - left + <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt; dst&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h1><p>将这串数字逆序，然后判断逆序后的数字是否和正序后的数字完全一样，如果完全一样，就是回文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">palindrome</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> i, j,count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n, j &gt;= <span class="number">0</span>; i++, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*(s + i) == *(s + j))</span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == n)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断一个链表是不是回文数"><a href="#判断一个链表是不是回文数" class="headerlink" title="判断一个链表是不是回文数"></a>判断一个链表是不是回文数</h1><p> 使用 2 个指针，快慢指针各一个，每次慢指针移动一个，快指针移动两个。</p>
<p>当快指针不为 NULL 时候，将慢指针 push 到栈中。</p>
<p>当快指针等于 NULL 时候，说明链表前半部分已经被压入栈中。</p>
<p>每次栈 Top 元素与当前慢指针元素比较，如果不相等则返回 false。如果相等，则栈 Pop，慢指针 ++。</p>
<p>链表奇数或者偶数节点需要判断（如果为奇数那么就删除最后的栈顶）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断单链表是不是回文链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(LinkedList *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; sk;</span><br><span class="line">    LinkedList *fast = head-&gt;next;</span><br><span class="line">    LinkedList *slow = head-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        sk.<span class="built_in">push</span>(slow-&gt;data);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">        sk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk.<span class="built_in">top</span>() == slow-&gt;data)&#123;</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文序列"><a href="#最长回文序列" class="headerlink" title="最长回文序列"></a>最长回文序列</h1><p>回文子序列，因为是不连续的肯定是不能直接枚举，那么利用动态规划</p>
<p>我们知道对于任意字符串，如果头尾字符相同，那么字符串的最长子序列等于去掉首尾的字符串的最长子序列加上首尾；如果首尾字符不同，则最长子序列等于去掉头的字符串的最长子序列和去掉尾的字符串的最长子序列的较大者。那么转移方程：</p>
<p><code>dp[i][j]=dp[i+1][j-1] + 2  if（s[i] == s[j]）</code></p>
<p><code> dp[i][j]=max(dp[i+1][j],dp[i][j-1])  if （s[i] != s[j]）</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">0</span>][len<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(len,vector&lt;<span class="keyword">int</span>&gt;(len));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                start=i;</span><br><span class="line">                longest=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= len; l++)<span class="comment">//子串长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+l<span class="number">-1</span> &lt; len; i++)<span class="comment">//枚举子串的起始点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=l+i<span class="number">-1</span>;<span class="comment">//终点</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                start=i;</span><br><span class="line">                longest = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,longest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>根节点—&gt;左子树—&gt;右字树</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tnode*  root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>先序遍历时，每当我们压入一个结点，我们压入结点前对其进行访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tnode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    stack&lt;Tnode *&gt;s;</span><br><span class="line">    Tnode *now=root;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;now-&gt;val&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now=now-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        now=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        now=now-&gt;rchild;　　</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>左子树—&gt;根节点—&gt;右字树</p>
<h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tnode*  root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归遍历-1"><a href="#非递归遍历-1" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>中序时我们需要在遍历完左子树后访问根节点，再去遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tnode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    stack&lt;Tnode *&gt;s;</span><br><span class="line">    Tnode *now=root;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now=now-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        now=s.<span class="built_in">top</span>();</span><br><span class="line">        cout&lt;&lt;now-&gt;val&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        now=now-&gt;rchild;　　</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>左子树—&gt;右字树—&gt;根节点</p>
<h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tnode*  root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;rchild);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归遍历-2"><a href="#非递归遍历-2" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>后序遍历时由于访问完左右子树后才能访问根结点，因此需要将根结点在栈内保留到左右子树被访问后，但同时会出现一个问题，当右子树弹出后遇到根结点又会将右子树结点压入栈中，造成死循环，因此我们需要在定义一个变量<code>last</code>代表最后一个访问的结点，当<code>last</code>与栈顶结点的右子树结点相同时，则不再将右子树结点压入栈中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tnode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    stack&lt;Tnode *&gt;s;</span><br><span class="line">    Tnode *now=root;</span><br><span class="line">    Tnode *last=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now=now-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        now=s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild &amp;&amp; last!=now-&gt;rchild)</span><br><span class="line">            now=now-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(now-&gt;rchild ==<span class="literal">NULL</span> || last ==now-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&lt;now-&gt;val&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            last=now;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            now=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给定中序和前序求层序或者后序"><a href="#给定中序和前序求层序或者后序" class="headerlink" title="给定中序和前序求层序或者后序"></a>给定中序和前序求层序或者后序</h2><p>不管是求层序还是后序，主要过程都是一样的都是建树。</p>
<p>首先我们在上面介绍了前序，中序，后序遍历的特性。所以我们基本的思路就是先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。给个例子介绍一下：</p>
<p>前序遍历：<code>GDAFEMHZ</code></p>
<p>中序遍历：<code>ADEFGHMZ</code></p>
<p>画树求法：</p>
<ul>
<li>根据前序遍历的特点，我们知道根结点为<code>G</code></li>
<li>观察中序遍历<code>ADEFGHMZ</code>。其中<code>root</code>节点<code>G</code>左侧的<code>ADEF</code>必然是<code>root</code>的左子树，<code>G</code>右侧的<code>HMZ</code>必然是<code>root</code>的右子树。</li>
<li>观察左子树<code>ADEF</code>，左子树的中的根节点必然是大树的<code>root</code>的<code>leftchild</code>。在前序遍历中，大树的<code>root</code>的<code>leftchild</code>位于<code>root</code>之后，所以左子树的根节点为<code>D</code>。</li>
<li>同样的道理，<code>root</code>的右子树节点<code>HMZ</code>中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把<code>root</code>和<code>root</code>的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,d;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildtree</span><span class="params">(<span class="keyword">int</span> la,<span class="keyword">int</span> ra,<span class="keyword">int</span> lb,<span class="keyword">int</span> rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(la&gt;ra)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> root=b[lb];</span><br><span class="line">    <span class="keyword">int</span> len1,len2;</span><br><span class="line">    len1=la;</span><br><span class="line">    <span class="keyword">while</span>(a[len1]!=root)</span><br><span class="line">        len1++;</span><br><span class="line">    len2=len1-la;</span><br><span class="line">    node[root].l=<span class="built_in">buildtree</span>(la,len1<span class="number">-1</span>,lb+<span class="number">1</span>,lb+len2);</span><br><span class="line">    node[root].r=<span class="built_in">buildtree</span>(len1+<span class="number">1</span>,ra,lb+len2+<span class="number">1</span>,rb);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(w);</span><br><span class="line">        <span class="keyword">if</span>(node[w].l!=<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node[w].l);</span><br><span class="line">        <span class="keyword">if</span>(node[w].r!=<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node[w].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len=v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,v[i],i==len<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="built_in">buildtree</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> root=b[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给定二叉树，给出S型打印"><a href="#给定二叉树，给出S型打印" class="headerlink" title="给定二叉树，给出S型打印"></a>给定二叉树，给出S型打印</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S_LevelOrderPrint</span><span class="params">(TreeNode t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode&gt; s1;</span><br><span class="line">    stack&lt;TreeNode&gt; s2;</span><br><span class="line">    s1.<span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() || !s2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tn = s1.<span class="built_in">top</span>();</span><br><span class="line">                cout&lt;&lt;tn.val&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tn.right != null)</span><br><span class="line">                    s2.<span class="built_in">push</span>(tn.right);</span><br><span class="line">                <span class="keyword">if</span>(tn.left != null)</span><br><span class="line">                    s2.<span class="built_in">push</span>(tn.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tn = s2.<span class="built_in">top</span>();</span><br><span class="line">                cout&lt;&lt;tn.val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tn.left != null)</span><br><span class="line">                    s1.<span class="built_in">push</span>(tn.left);</span><br><span class="line">                <span class="keyword">if</span>(tn.right != null)</span><br><span class="line">                    s1.<span class="built_in">push</span>(tn.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="N-阶乘末尾0的个数。"><a href="#N-阶乘末尾0的个数。" class="headerlink" title="N 阶乘末尾0的个数。"></a>N 阶乘末尾0的个数。</h1><p>要判断末尾有几个0就是判断可以整除几次10。10的因子有5和2，而在0~9之间5的倍数只有一个，2的倍数相对较多，所以本题也就转换成了求N阶乘中有几个5的倍数。<br>也就是每多出来一个5，阶乘末尾就会多出来一个0，这样n / 5就能统计完第一层5的个数，依次处理，就能统计出来所有5的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        n /= <span class="number">5</span>;     <span class="comment">//算出当前数字中可以匹配5（5和5的倍数）的个数</span></span><br><span class="line">        count += n; <span class="comment">//累加之</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="给定数组，从数组中取出n个不复用的数的和为sum"><a href="#给定数组，从数组中取出n个不复用的数的和为sum" class="headerlink" title="给定数组，从数组中取出n个不复用的数的和为sum"></a>给定数组，从数组中取出n个不复用的数的和为sum</h1><p>深搜</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findd</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;vr,<span class="keyword">int</span> pos,<span class="keyword">int</span> sum,<span class="keyword">int</span> m,<span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum==m)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;m)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;vr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            sum+=vr[pos];</span><br><span class="line">            <span class="built_in">findd</span>(vr,pos+<span class="number">1</span>,sum,m,res);</span><br><span class="line">            sum-=vr[pos];</span><br><span class="line">            <span class="built_in">findd</span>(vr,pos+<span class="number">1</span>,sum,m,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DP</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            cin&gt;&gt;vr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vr.<span class="built_in">begin</span>(),vr.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;&gt;<span class="built_in">dp</span>(n,vector&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vr[<span class="number">0</span>]&gt;m)<span class="comment">//过滤</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(vr[<span class="number">0</span>]==i)</span><br><span class="line">                dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vr[i]&gt;m)  <span class="comment">//过滤</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-vr[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j-vr[i]];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n<span class="number">-1</span>][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求一个无序数组的中位数"><a href="#求一个无序数组的中位数" class="headerlink" title="求一个无序数组的中位数"></a>求一个无序数组的中位数</h1><p>利用快排的思想。任意挑一个元素，以该元素为支点，划分集合为两部分，如果左侧集合长度恰为 (n-1)/2，那么支点恰为中位数。如果左侧长度 &lt;(n-1)/2, 那么中位点在右侧，反之，中位数在左侧。 进入相应的一侧继续寻找中位点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排方法，分治思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PartSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[right];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//key右边，先从左找比key值大</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">            ++left;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右找比key小</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">            --right;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMid3</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="built_in">PartSort</span>(arr, left, right);</span><br><span class="line">    <span class="keyword">while</span> (div != mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (div &lt; mid)<span class="comment">//右半区间</span></span><br><span class="line">            div = <span class="built_in">PartSort</span>(arr, div + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            div = <span class="built_in">PartSort</span>(arr, left, div - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中位数&quot;</span> &lt;&lt; arr[div] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=e;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[s]);</span><br><span class="line">            <span class="built_in">perm</span>(s+<span class="number">1</span>,e);</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[s]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">perm</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="36进制加法"><a href="#36进制加法" class="headerlink" title="36进制加法"></a>36进制加法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String chars = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(add_36(<span class="string">&quot;1b&quot;</span>, <span class="string">&quot;10&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">add_36</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alength = a.length();</span><br><span class="line">        <span class="keyword">int</span> blength = b.length();</span><br><span class="line">        <span class="keyword">int</span> m = Math.max(alength, blength);</span><br><span class="line">        <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> clength = chars.length();</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ia = i &lt; alength ? chars.indexOf(a.charAt(alength - i - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ib = i &lt; blength ? chars.indexOf(b.charAt(blength - i - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> add = ia + ib + inc;</span><br><span class="line">            <span class="keyword">if</span> (add &gt; clength) &#123;</span><br><span class="line">                inc = add / clength;</span><br><span class="line">            &#125;</span><br><span class="line">            result = chars.charAt(add % clength) + result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = chars.charAt(inc) + result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="n条直线最多把平面分割成几部分"><a href="#n条直线最多把平面分割成几部分" class="headerlink" title="n条直线最多把平面分割成几部分?"></a>n条直线最多把平面分割成几部分?</h1><p><code>n</code>条直线最多把平面分成<code>An</code>部分，于是<code>A0=1</code> <code>A1=2</code> <code>A2=4</code></p>
<p>对于已经有<code>n</code>条直线 将平面分成了最多的<code>An</code>块</p>
<p>那么加一条直线 他最多与前<code>n</code>条直线有<code>n</code>个交点 于是被它穿过的区域都被一分为二 那么增加的区域数就是穿过的区域</p>
<p>数 也就是这条直线自身被分成的段数 就是<code>n+1</code> 故 <code>A(n+1) = A(n)+n+1</code></p>
<p><code>An = n+(n-1)+...+2+A1 = n(n+1)/2 +1</code></p>
<h1 id="n条折线分割平面"><a href="#n条折线分割平面" class="headerlink" title="n条折线分割平面"></a>n条折线分割平面</h1><p>根据直线分平面可知，由交点决定了射线和线段的条数，进而决定了新增的区域数。当<code>n-1</code>条折线时，区域数为<code>f（n-1）</code>。为了使增加的区域最多，则折线的两边的线段要和<code>n-1</code>条折线的边，即<code>2*（n-1）</code>条线段相交。那么新增的线段数为<code>4*（n-1）</code>，射线数为2。但要注意的是，折线本身相邻的两线段只能增加一个区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n)=f(n-1)+4(n-1)+2-1</span><br><span class="line">=f(n-1)+4(n-1)+1</span><br><span class="line">=f(n-2)+4(n-2)+4(n-1)+2</span><br><span class="line">……</span><br><span class="line">=f(1)+4+4*2+……+4(n-1)+(n-1)   </span><br><span class="line">=2n^2-n+1</span><br></pre></td></tr></table></figure>

<h1 id="n个平面分割空间"><a href="#n个平面分割空间" class="headerlink" title="n个平面分割空间"></a>n个平面分割空间</h1><p><code>n</code>个平面最多把空间分成<code>bn</code>个部分</p>
<p>于是<code>b0=1</code> <code>b1=2</code> <code>b2=4</code></p>
<p>对于已经有<code>n</code>个平面 将空间分成了最多的<code>bn</code>块</p>
<p>那么加入一个平面 它最多与每个平面相交 在它的上面就会得到至多<code>n</code>条交线 </p>
<p>同时被它穿过的空间区域也被它一分为二 那么增加的区域数仍旧是它穿过的区域数 也就是这个平面自身被直线分割成的块数 就是<code>an</code>于是<code>b(n+1)=bn+an</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bn=a(n-1)+b(n-1)=...=a(n-1)+a(n-2)+...+a1+b1</span><br><span class="line">=(n-1)n/2 +(n-2)(n-1)/2+...+1*(1+1)/2+n+2</span><br><span class="line">=求和[1方到(n-1)方]/2 + 求和[1到(n-1)]/2 +n+1</span><br><span class="line">=n(n-1)(2n-1)/12 +n(n-1)/4 +n+1</span><br><span class="line">=n(n+1)(n-1)/6 +n+1</span><br><span class="line">=(n^3+5n+6)/6</span><br></pre></td></tr></table></figure>

<h1 id="数组中唯一出现过一次的数"><a href="#数组中唯一出现过一次的数" class="headerlink" title="数组中唯一出现过一次的数"></a>数组中唯一出现过一次的数</h1><p>利用异或的特性：<code>x ^ y ^ x = y ^ x ^ x = y</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一个数组里除了一个数字之外，其他数字出现了n次"><a href="#一个数组里除了一个数字之外，其他数字出现了n次" class="headerlink" title="一个数组里除了一个数字之外，其他数字出现了n次"></a>一个数组里除了一个数字之外，其他数字出现了n次</h1><p>我们把这个数分解成二进制，计算出每一位出现<code>1</code>的个数，我们知道如果多次出现的话，<code>1</code>的个数是能够整除这个<code>n</code>，如果发现这个<code>n </code>不能够被 整除的时候，我们就知道那个唯一的数字转换为二进制的时候在这一位上会分解到，我们把这个再转换为十进制的数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[j]+=((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]%<span class="number">3</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="找1到n中缺失的数字"><a href="#找1到n中缺失的数字" class="headerlink" title="找1到n中缺失的数字"></a>找1到n中缺失的数字</h1><h2 id="数组有序"><a href="#数组有序" class="headerlink" title="数组有序"></a>数组有序</h2><p>直接二分时间复杂度为<code>O(logN)</code>。如果中间元素的值和下标相等，那么下一轮查找只需要查找右半边；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标不相等，这意味着下一轮查找我们只需要在左半边查找即可。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLoseNum</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == mid + <span class="number">2</span>) <span class="comment">//缺失的数据在后半部分</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] == mid + <span class="number">1</span>)  <span class="comment">//缺失的数据在前半部分</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组无序"><a href="#数组无序" class="headerlink" title="数组无序"></a>数组无序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用异或运算， </span></span><br><span class="line"><span class="comment">任何数异或自己都等于0，x^x=0，任何数异或0都等于他自己x^0=x； </span></span><br><span class="line"><span class="comment">假如缺的为3。result = 1^2^4^5^N </span></span><br><span class="line"><span class="comment">第二次异或后 result = 1^2^4^5^N ^1^2^3^4^5^N = 0^3 = 3 </span></span><br><span class="line"><span class="comment">时间复杂度：O(n) 空间复杂度：O(1) </span></span><br><span class="line"><span class="comment">异或方法，n：最大元素的值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLose</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        t = t ^ i;</span><br><span class="line">    <span class="comment">//最大值为n，缺失一个元素，则元素个数为n-2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</span><br><span class="line">        t = t ^ a[i];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*用1+2+…+n减去当前输入数据的总和，则所得的差就是缺失的那个数。 </span></span><br><span class="line"><span class="comment">时间复杂度：O(n) 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//n：最大元素的值而不是元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对输入数据进行Hash，然后从头到尾遍历一次。时间复杂度O(n) 空间复杂度O(n) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMiss</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//hash表的长度比max大1</span></span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//数组的值从1开始，因此hash表的0位不用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=max; i++)</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对数组遍历，缺失一个数，数组的长度为max-2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;max-<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=max; i++)</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找1到n中缺失的两个数字"><a href="#找1到n中缺失的两个数字" class="headerlink" title="找1到n中缺失的两个数字"></a>找1到n中缺失的两个数字</h1><p>也是采用异或。假设，缺失的数为<code>s1</code>和<code>s2</code>。则<code>s1^s2=1^2^3.....^n^a[0]^a[1]^....a[n-3]</code>。这个式子一目了然，无需多解释。</p>
<p>问题是如何通过这个式子求出<code>s1</code>与<code>s2</code>的值。只要能求出一个值，比如说<code>s1</code>，则<code>s2=s1^(s1^s2)</code>。</p>
<p>   <code>s1^s2</code>的值必然不为0，则必然存在一位，<code>s1</code>与<code>s2</code>在此对应位不同。我们就可以按照此对应位是0或者1，将<code>1-n</code>分为两堆，将<code>a[0]-a[n-3]</code>分为两堆。将该为为1的两堆数相异或就能求出缺失的一个数。</p>
<p>举个例子。<code>1-7</code>中缺失<code>3,4</code>。转化为二进制位：<code>011</code>和<code>100</code>。三位都不同，我们用最后一位来判别，将<code>1-n</code>和数组非为两堆。则结果为：</p>
<table>
<thead>
<tr>
<th>标志位(最后一位）</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>1-n</td>
<td>1、3、5、7</td>
<td>2、4、6</td>
</tr>
<tr>
<td>a[0]-a[n-3]</td>
<td>1、5、7</td>
<td>2、6</td>
</tr>
</tbody></table>
<p>用标志位为1的数进行异或</p>
<p><code> 1^3^5^7^1^5^7=3</code>。这样就求出了一个缺失数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_missing_number2</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span>&amp; miss1, <span class="keyword">int</span>&amp; miss2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    miss1 = <span class="number">0</span>;</span><br><span class="line">    miss2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        number ^= ((i+<span class="number">1</span>)^a[i]);</span><br><span class="line">    number ^= (size+<span class="number">1</span>);</span><br><span class="line">    number ^= (size+<span class="number">2</span>);    </span><br><span class="line">    <span class="keyword">int</span> k = number - (number&amp;(number-<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (i+<span class="number">1</span>)&amp;k )</span><br><span class="line">            miss1 ^= (i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( a[i]&amp;k )</span><br><span class="line">            miss1 ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (size+<span class="number">1</span>) &amp; k )</span><br><span class="line">        miss1 ^= size+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (size+<span class="number">2</span>) &amp; k )</span><br><span class="line">        miss1 ^= size+<span class="number">2</span>;</span><br><span class="line">    miss2 = number ^ miss1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="下一个最大数系列"><a href="#下一个最大数系列" class="headerlink" title="下一个最大数系列"></a>下一个最大数系列</h1><h2 id="给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字-x-的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。"><a href="#给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字-x-的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。" class="headerlink" title="给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。"></a>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</h2><p>在遍历数组的过程中，如果是往后遇到大的数，那就是第一个更大的数，如果一直遇到不断小的数，才会一直找不到，我们可以用一个栈来记录，遇到比栈顶小的数字就放入栈中，遇到比栈顶大的数字就说明这是栈顶数字的下一个更大的数，就将其放在结果数组的对应位置上，栈顶的元素出栈，继续比较新的栈顶的数，如果还是大，那么继续记录，出栈，直到栈顶的数比新数要小，那么就可以将新数入栈了。因为我们要将找到的更大的数放在对应位置上，所以栈中记录的应该是元素位置，而不是具体的数字，但比较的时候还是比较原来的数组中这个位置的数字，此外，因为会出现循环寻找的情况，所以数组我们可能遍历两次。算法的时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(N, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() &amp;&amp; nums[stack.<span class="built_in">top</span>()] &lt; nums[i % N]) &#123;</span><br><span class="line">                res[stack.<span class="built_in">top</span>()] = nums[i % N];</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; N)</span><br><span class="line">                stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="输入一个数组，代表每天的温度，求解每天需要经过几天会升温，即需找数组每个元素右边第一个比自己大的数。"><a href="#输入一个数组，代表每天的温度，求解每天需要经过几天会升温，即需找数组每个元素右边第一个比自己大的数。" class="headerlink" title="输入一个数组，代表每天的温度，求解每天需要经过几天会升温，即需找数组每个元素右边第一个比自己大的数。"></a>输入一个数组，代表每天的温度，求解每天需要经过几天会升温，即需找数组每个元素右边第一个比自己大的数。</h2><p>利用单调栈性质创建单调递减栈，遍历数组入栈，当将要入栈元素小于栈顶元素时入栈，若要入栈元素大于栈顶元素时，表示入栈元素为所求元素，记录索引，弹出栈顶元素，将此元素压栈，重新比较，一次循环时间复杂度<code>O(n)</code>。</p>
<p>样例输入：<code>[73, 74, 75, 71, 69, 72, 76, 73]</code></p>
<p>样例输出： <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例解析：</span></span><br><span class="line"><span class="comment">73入栈，74&gt;73，73出栈，74入栈，74使得73出栈，所以73需要等待1-0=1天 ，栈内元素74.</span></span><br><span class="line"><span class="comment">75入栈，75&gt;74, 74出栈，75入栈，75使得74出栈，所以74需要等待2-1=1天，栈内元素75.</span></span><br><span class="line"><span class="comment">71入栈，71&lt;75，直接入栈，栈内元素 75,71</span></span><br><span class="line"><span class="comment">69直接入栈，栈内元素75,71,69</span></span><br><span class="line"><span class="comment">72入栈，72&gt;69,69出栈，72使69出栈，所以69需要等待5-4=1天，此时栈内元素75,71，由与72&gt;71,任不满足单调栈性质，71出栈，72使71出栈，所以71需要等待5-3=2天，站内元素75,75&gt;72,72直接入栈，栈内元素为：75,72.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temperatures.length;i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(s.isEmpty()||temperatures[i]&lt;temperatures[s.peek()])&#123;</span><br><span class="line">        		s.push(i);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">while</span>(!s.isEmpty()&amp;&amp;temperatures[s.peek()]&lt;temperatures[i])&#123;</span><br><span class="line">        			<span class="keyword">int</span> index = s.pop();</span><br><span class="line">        			res[index] = i-index;</span><br><span class="line">        		&#125;</span><br><span class="line">        		s.push(i);</span><br><span class="line">        	&#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表中的下一个更大节点"><a href="#链表中的下一个更大节点" class="headerlink" title="链表中的下一个更大节点"></a>链表中的下一个更大节点</h2><h1 id="未排序的数组第-k-大的数"><a href="#未排序的数组第-k-大的数" class="headerlink" title="未排序的数组第 k 大的数"></a>未排序的数组第 k 大的数</h1><p>第一种解法，利用优先队列，维护一个 size == k 的优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/** priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; **/</span></span><br><span class="line">            priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> val:nums)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; len-k+<span class="number">1</span>)&#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种解法：利用快排的思想，就跟无序数组中找中位数一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = low;</span><br><span class="line">            <span class="keyword">int</span> j = high<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &gt;= pivot)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &lt; pivot)</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i++],nums[j--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[low],nums[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == k<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k<span class="number">-1</span>)</span><br><span class="line">                low = j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="计算数字-n-有多少个二进制-1"><a href="#计算数字-n-有多少个二进制-1" class="headerlink" title="计算数字 n 有多少个二进制 1"></a>计算数字 n 有多少个二进制 1</h1><p>利用 n&amp;(n-1) 清除最右边的 1，记录 1 的个数就可以了。</p>
<p>因为从二进制的角度讲，n 相当于在 n - 1 的最低位加上 1。举个例子，8（1000）= 7（0111）+ 1（0001），所以 8 &amp; 7 = （1000）&amp;（0111）= 0（0000），清除了 8 最右边的 1（其实就是最高位的 1，因为 8 的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 &amp; 6 = （0111）&amp;（0110）= 6（0110），清除了7的二进制表示中最右边的 1（也就是最低位的 1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BitCount2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c =<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (c =<span class="number">0</span>; n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        n &amp;= (n <span class="number">-1</span>) ; <span class="comment">// 清除最低位的1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的解法，我们可以判断一个数是 2 的幂数的最快方法是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(n&amp;(n-1)) </span><br><span class="line">	then n不是2的幂数;</span><br><span class="line">else </span><br><span class="line">	n是2的幂数;</span><br><span class="line">因为如果n=2^K,那么n = 1000...0(k个0）,则n-1 = 111...0(k个1);相与之后则为0</span><br><span class="line"></span><br><span class="line">如果 n!=2^k，那么n跟（n-1)第一位都为1，则相与这后然后第一位为1，则不为0.</span><br></pre></td></tr></table></figure>

<h1 id="1-n-中有多少个二进制-1"><a href="#1-n-中有多少个二进制-1" class="headerlink" title="1-n 中有多少个二进制 1"></a>1-n 中有多少个二进制 1</h1><p>我觉得 for 一遍循环，就很快了差不多 O(n) 的时间复杂度。</p>
<h1 id="找出只由-a-b-c-组成的字符串中包含-abc-的个数"><a href="#找出只由-a-b-c-组成的字符串中包含-abc-的个数" class="headerlink" title="找出只由 a,b,c 组成的字符串中包含 abc 的个数"></a>找出只由 a,b,c 组成的字符串中包含 abc 的个数</h1><p>给个样例，abccc 可以找到 3 个 abc。</p>
<p>思路就是</p>
<h1 id="一个数组中只有0-1-2三个元素，进行排序，要求时间复杂度为O-n"><a href="#一个数组中只有0-1-2三个元素，进行排序，要求时间复杂度为O-n" class="headerlink" title="一个数组中只有0,1,2三个元素，进行排序，要求时间复杂度为O(n)"></a>一个数组中只有0,1,2三个元素，进行排序，要求时间复杂度为O(n)</h1><p>设置三个标记指针，pos0，pos2，cur ，令 pos0 从前往后遍历，指向第一个非 0 的位置，pos2 从后往前遍历，指向第一个非 2 的位置<br>然后 cur 从 pos0 开始往后遍历：<br>遇到 0 就和pos0交换，pos0++;<br>遇到 1 什么也不做;<br>遇到 2 就和 pos2 交换，pos2 向前滑动到下一个非2的位置，交换后还要重新检查 cur 的值；<br>直到 cur 与 pos2 相遇。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">nt <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">14</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pos0=<span class="number">0</span>, pos2=<span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="number">4</span> <span class="number">-1</span>, pcur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> == arr[pos0])</span><br><span class="line">        ++pos0;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> == arr[pos2])</span><br><span class="line">        --pos2;</span><br><span class="line">    pcur = pos0;</span><br><span class="line">    <span class="keyword">while</span>(pcur &lt;= pos2)&#123;        </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == arr[pcur])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[pcur], arr[pos0]);</span><br><span class="line">            ++pos0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span> == arr[pcur])&#123;            </span><br><span class="line">            <span class="built_in">swap</span>(arr[pcur], arr[pos2]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == arr[pcur])&#123;<span class="comment">//若交换之后，pcur当前指向的元素为0，则继续将pcur指向的元素和pos0指向的元素进行交换</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[pcur], arr[pos0]); </span><br><span class="line">                ++pos0;<span class="comment">//交换之后，将pos0向前移动一位</span></span><br><span class="line">            &#125;           </span><br><span class="line">            --pos2;<span class="comment">//pos2向后移动一位</span></span><br><span class="line">            <span class="keyword">while</span>(arr[pos2] == <span class="number">2</span>)<span class="comment">//若移动之后指向的元素还是2，则继续向前移动，直到指向第一个非2的元素</span></span><br><span class="line">                --pos2;</span><br><span class="line">        &#125;   </span><br><span class="line">        ++pcur;<span class="comment">//将pcur向前移动</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//将原数组打印出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="number">4</span>;++i)</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="输出一个递增排序数组的旋转数组中的最小元素-或者-下标"><a href="#输出一个递增排序数组的旋转数组中的最小元素-或者-下标" class="headerlink" title="输出一个递增排序数组的旋转数组中的最小元素 或者 下标"></a>输出一个递增排序数组的旋转数组中的最小元素 或者 下标</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_min_num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *arr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>((arr[left] &lt;= arr[mid]) &amp;&amp; (arr[mid] &lt;= arr[right]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//当数组区间为递增时，最小值就为最左值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((arr[mid<span class="number">-1</span>] &gt; arr[mid]) &amp;&amp; (arr[mid+<span class="number">1</span>] &gt; arr[mid]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[mid];<span class="comment">//当取到的中间值就为旋转点时，最小值就为中间值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((arr[left] &lt;= arr[mid]) &amp;&amp; (arr[mid] &gt;= arr[right]))</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//当中间值比左边大且比右边大时</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;<span class="comment">//除去上面的三种情况就只剩一种了，那就是中间值比左线小且比右边小</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mid = (right-left)/<span class="number">2</span> + left;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> arr[left];</span><br><span class="line">    <span class="comment">// return left;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求二叉树中节点的差的最大值"><a href="#求二叉树中节点的差的最大值" class="headerlink" title="求二叉树中节点的差的最大值"></a>求二叉树中节点的差的最大值</h1><p>其实就是求出二叉树中结点的最大值和最小值，相减就是结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;binarytree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binarytree *p, <span class="keyword">int</span> &amp;max, <span class="keyword">int</span> &amp;min)</span><span class="comment">//先序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span>==p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;value&gt;max)</span><br><span class="line">		max=p-&gt;value;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;value&lt;min)</span><br><span class="line">		min=p-&gt;value;</span><br><span class="line">	<span class="built_in">preorder</span>(head-&gt;lchild, max, min);</span><br><span class="line">	<span class="built_in">preorder</span>(head-&gt;rchild, max, min);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chazhi_max</span><span class="params">(binarytree *head)</span><span class="comment">//返回最大差值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span>==head)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> max, min;</span><br><span class="line">	max = min = head-&gt;value;</span><br><span class="line">	<span class="built_in">preorder</span>(head, max, min);</span><br><span class="line">	<span class="keyword">return</span> max-min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现pow函数求x的y次方"><a href="#实现pow函数求x的y次方" class="headerlink" title="实现pow函数求x的y次方"></a>实现pow函数求x的y次方</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//分治法：分而治之</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">power</span>(x, -n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">power</span>(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> temp = <span class="built_in">pow</span>(x, n/<span class="number">2</span>);<span class="comment">//递归的处理相乘的幂，重复利用已经的出来的值。</span></span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            result = x * temp * temp;<span class="comment">//当幂为奇数的时候，多乘一个就变为偶数问题了。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = temp * temp;<span class="comment">//当幂为偶数的时候，</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x / mid &gt;= mid) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二维坐标系，有一组点，若一个点的x-y都小于某个点，那么这个点就包含它，它的价值是它包含的点的个数，求最大价值的点的价值？-提示可以先排序"><a href="#二维坐标系，有一组点，若一个点的x-y都小于某个点，那么这个点就包含它，它的价值是它包含的点的个数，求最大价值的点的价值？-提示可以先排序" class="headerlink" title="二维坐标系，有一组点，若一个点的x y都小于某个点，那么这个点就包含它，它的价值是它包含的点的个数，求最大价值的点的价值？ (提示可以先排序)"></a>二维坐标系，有一组点，若一个点的x y都小于某个点，那么这个点就包含它，它的价值是它包含的点的个数，求最大价值的点的价值？ (提示可以先排序)</h1><h1 id="一个模拟Windows窗体管理的类，-x1-y1-和-x2-y2-分别是窗体左上角和右下角像素点座标有很多个矩形，求覆盖的总面积"><a href="#一个模拟Windows窗体管理的类，-x1-y1-和-x2-y2-分别是窗体左上角和右下角像素点座标有很多个矩形，求覆盖的总面积" class="headerlink" title="一个模拟Windows窗体管理的类，(x1,y1)和(x2,y2)分别是窗体左上角和右下角像素点座标有很多个矩形，求覆盖的总面积"></a>一个模拟Windows窗体管理的类，(x1,y1)和(x2,y2)分别是窗体左上角和右下角像素点座标有很多个矩形，求覆盖的总面积</h1><h1 id="Java-判断字符串是否是网址"><a href="#Java-判断字符串是否是网址" class="headerlink" title="Java 判断字符串是否是网址"></a>Java 判断字符串是否是网址</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHttpUrl</span><span class="params">(String urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isurl = <span class="keyword">false</span>;</span><br><span class="line">    String regex = <span class="string">&quot;(((https|http)?://)?([a-z0-9]+[.])|(www.))&quot;</span></span><br><span class="line">            + <span class="string">&quot;\\w+[.|\\/]([a-z0-9]&#123;0,&#125;)?[[.]([a-z0-9]&#123;0,&#125;)]+((/[\\S&amp;&amp;[^,;\u4E00-\u9FA5]]+)+)?([.][a-z0-9]&#123;0,&#125;+|/?)&quot;</span>;<span class="comment">//设置正则表达式</span></span><br><span class="line"></span><br><span class="line">    Pattern pat = Pattern.compile(regex.trim());<span class="comment">//比对</span></span><br><span class="line">    Matcher mat = pat.matcher(urls.trim());</span><br><span class="line">    isurl = mat.matches();<span class="comment">//判断是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (isurl) &#123;</span><br><span class="line">        isurl = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isurl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3个线程顺序打印数字"><a href="#3个线程顺序打印数字" class="headerlink" title="3个线程顺序打印数字"></a>3个线程顺序打印数字</h1><p>问题：启动3个线程A、B、C，使A打印0，然后B打印1，然后C打印2，A打印3，B打印4，C打印5，依次类推。</p>
<p>思路：每个线程给定一个编号，每个线程判断当前是否已经轮到自己打印：如果没轮到，就wait等待；如果轮到，则打印当前数字，并唤醒其他线程。</p>
<p>判断是否已经轮到自己打印：</p>
<p>每个线程给定一个编号N，N从0开始；</p>
<p>使用一个全局变量记录当前需要打印的数字C，C从0开始，每次打印之后加1；</p>
<p>线程数量M；</p>
<p>判断逻辑：C%M ==N</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintSequenceThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前即将打印的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程编号，从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNo;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadCount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印的最大数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintSequenceThread</span><span class="params">(<span class="keyword">int</span> threadNo, <span class="keyword">int</span> threadCount, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadNo = threadNo;</span><br><span class="line">        <span class="keyword">this</span>.threadCount = threadCount;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 判断是否轮到当前线程执行</span></span><br><span class="line">                <span class="keyword">while</span> (current % threadCount != threadNo) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current &gt; max) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果不是，则当前线程进入wait</span></span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 最大值跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (current &gt; max) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread-&quot;</span> + threadNo + <span class="string">&quot; : &quot;</span> + current);</span><br><span class="line">                current++;</span><br><span class="line">                <span class="comment">// 唤醒其他wait线程</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintSequenceThread(i,threadCount, max)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="从左（右）边看二叉树"><a href="#从左（右）边看二叉树" class="headerlink" title="从左（右）边看二叉树"></a>从左（右）边看二叉树</h1><p>二叉树的层次遍历，每层按照从左向右的顺序依次访问节点（每一层取最（左）右边的节点）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; views;</span><br><span class="line">        <span class="built_in">scan</span>(root, <span class="number">0</span>, views);</span><br><span class="line">        <span class="keyword">return</span> views;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(TreeNode* root, <span class="keyword">int</span> h, vector&lt;<span class="keyword">int</span>&gt;&amp; views)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(h &gt;= views.<span class="built_in">size</span>())</span><br><span class="line">            views.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">/* 先遍历右侧，这样就可以先选择右边的元素 */</span></span><br><span class="line">        <span class="built_in">scan</span>(root-&gt;right, h + <span class="number">1</span>, views);</span><br><span class="line">        <span class="built_in">scan</span>(root-&gt;left, h + <span class="number">1</span>, views);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  如果是左边的话就先遍历左边</span></span><br></pre></td></tr></table></figure>

<h1 id="给定一个数组，与数字m最接近的k个数"><a href="#给定一个数组，与数字m最接近的k个数" class="headerlink" title="给定一个数组，与数字m最接近的k个数"></a>给定一个数组，与数字m最接近的k个数</h1><h1 id="在排序数组中找最接近的K个数"><a href="#在排序数组中找最接近的K个数" class="headerlink" title="在排序数组中找最接近的K个数"></a>在排序数组中找最接近的K个数</h1><h1 id="Java-List转Tree"><a href="#Java-List转Tree" class="headerlink" title="Java List转Tree"></a>Java List转Tree</h1><p>细节实现看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/MassiveStars/article/details/53911620</span><br></pre></td></tr></table></figure>

<h1 id="字符串排序，要求O-n"><a href="#字符串排序，要求O-n" class="headerlink" title="字符串排序，要求O(n)"></a>字符串排序，要求O(n)</h1><p>我们知道字符 char 的范围是 -128-127，开一个 255 大小的数组排序。一次遍历字符串，对应的数组位置值 ++</p>
<p>然后一遍遍历输出即可。</p>
<h1 id="不相邻和最大"><a href="#不相邻和最大" class="headerlink" title="不相邻和最大"></a>不相邻和最大</h1><p>对于一个给定的数组，在其中选取其子数组，要求相邻的元素不能选取，且要保证选出的子数组元素和最大。输入数组长度及其元素，输出所选子数组的和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试输入</span><br><span class="line">7</span><br><span class="line">4 2 6 1 3 5 8</span><br><span class="line">测试输出</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>为了让子数组和最大，应该尽可能让它包含更多的元素，并且相邻元素不能选取，所以选取的任意两个数字之间最多间隔两个数，因为假设如果间隔了三个而子数组和最大，那么最中间的那个数一定可以选中，此时子数组和也一定比之前更大，产生矛盾。由此可见，本题只需要分析连续的三个元素的关系即可。<br>按照第 i 个元素是否被选取，前 i 个元素的和要么与前 i−1 个元素的和相同(不选取)，要么是前 i−2 个元素的和加上此第 i 个元素(选取)，这两种情况取最大。这很容易通过递归实现出来，也可以使用动态规划实现。要用动态规划，子问题的选取需要具有无后效性，即前 i 个元素的选取只能和之前的选取有关，和未来的情况无关。对于数组array[i]，i=0∼n−1，定义 s[i] 表示前 i 个元素的最大和，则递归式为</p>
<p><img src="/2019/07/27/%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98/1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotAdjacentLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(solution(array, n - <span class="number">1</span>), </span><br><span class="line">                        solution(array, n - <span class="number">2</span>) + array[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        s[<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> takei = s[i - <span class="number">2</span>] + array[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> skipi = s[i - <span class="number">1</span>];</span><br><span class="line">            s[i] = Math.max(takei, skipi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            array[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution2(array, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果是在一个环上呢：<a href="https://blog.csdn.net/zhufenghao/article/details/71791777">看解析</a></p>
<h1 id="一个环路加油站，是否能走一圈"><a href="#一个环路加油站，是否能走一圈" class="headerlink" title="一个环路加油站，是否能走一圈"></a>一个环路加油站，是否能走一圈</h1><p>城市的环形路有n个加油站，第i个加油站的油量用gas[i]来表示，你有如下的一辆车：</p>
<p>它的油缸是无限量的，初始是空的</p>
<p>它从第i个加油站到第i+1个加油站消耗油量为cost[i]</p>
<p>现在你可以从任意加油站开始，路过加油站可以不断的加油，问是否能够走完环形路。如果可以返回开始加油站的编号，如果不可以返回-1。</p>
<p>思路：假设起始的加油站是src，最后一个加油站是dst，在从src出发达到下一个加油站的油剩下sum。那么需要能够从src到dst中的每个点的油剩余量都有&gt;=0。</p>
<p>假设从src出发，某点的油量sum&lt;0，那么我们就从src-1站出发，此时达到这个“某点”的油量剩余就是sum += gas[src-1]-cost[src-1]，此时的dst将是src -1 再 -1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = (src<span class="number">-1</span>+gas.<span class="built_in">size</span>())%gas.<span class="built_in">size</span>();;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = src;</span><br><span class="line">        <span class="keyword">while</span>(i != dst +<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                src = (src<span class="number">-1</span>+gas.<span class="built_in">size</span>())%gas.<span class="built_in">size</span>();</span><br><span class="line">                dst = (src<span class="number">-1</span>+gas.<span class="built_in">size</span>())%gas.<span class="built_in">size</span>();</span><br><span class="line">                sum+=gas[src] - cost[src];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += gas[i] - cost[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>) <span class="keyword">return</span> src;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="堆的中位数算法"><a href="#堆的中位数算法" class="headerlink" title="堆的中位数算法"></a>堆的中位数算法</h1><p><a href="https://blog.csdn.net/Little_Fire/article/details/81098584">看解析</a></p>
<h1 id="桌子上有一副牌，循环进行以下操作：（1）将顶部的牌放到桌上-（2）再将当前顶部的牌放入底部，循环到所有牌都放到桌上，假设最后放到桌子上的牌顺序是-13-12-11-…-1，问初始的牌堆是怎么放的"><a href="#桌子上有一副牌，循环进行以下操作：（1）将顶部的牌放到桌上-（2）再将当前顶部的牌放入底部，循环到所有牌都放到桌上，假设最后放到桌子上的牌顺序是-13-12-11-…-1，问初始的牌堆是怎么放的" class="headerlink" title="桌子上有一副牌，循环进行以下操作：（1）将顶部的牌放到桌上 （2）再将当前顶部的牌放入底部，循环到所有牌都放到桌上，假设最后放到桌子上的牌顺序是 13 12 11 …. 1，问初始的牌堆是怎么放的"></a>桌子上有一副牌，循环进行以下操作：（1）将顶部的牌放到桌上 （2）再将当前顶部的牌放入底部，循环到所有牌都放到桌上，假设最后放到桌子上的牌顺序是 13 12 11 …. 1，问初始的牌堆是怎么放的</h1><h1 id="找到数组中的两个数-A-和-B，要求将-A-和-B-交换之后自区间和是最大的，输出-A、B-和-最大自区间和"><a href="#找到数组中的两个数-A-和-B，要求将-A-和-B-交换之后自区间和是最大的，输出-A、B-和-最大自区间和" class="headerlink" title="找到数组中的两个数 A 和 B，要求将 A 和 B 交换之后自区间和是最大的，输出 A、B 和 最大自区间和"></a>找到数组中的两个数 A 和 B，要求将 A 和 B 交换之后自区间和是最大的，输出 A、B 和 最大自区间和</h1><h1 id="LeetCode-4-两个排序数组的中位数-数组、二分查找、分治法"><a href="#LeetCode-4-两个排序数组的中位数-数组、二分查找、分治法" class="headerlink" title="LeetCode 4 两个排序数组的中位数(数组、二分查找、分治法)"></a>LeetCode 4 两个排序数组的中位数(数组、二分查找、分治法)</h1><h1 id="Leetcode-400-找到第-N-位"><a href="#Leetcode-400-找到第-N-位" class="headerlink" title="Leetcode 400 找到第 N 位"></a>Leetcode 400 找到第 N 位</h1><p>Find the <em>n</em>th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …</p>
<p><strong>Note:</strong><br><em>n</em> is positive and will fit within the range of a 32-bit signed integer (<em>n</em> &lt; 231).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>自然数序列看成一个长字符串，问我们第N位上的数字是什么。那么我们首先来分析自然数序列和其位数的关系，前九个数都是1位的，然后10到99总共90个数字都是两位的，100到999这900个数都是三位的，那么这就很有规律了，我们可以定义个变量cnt，初始化为9，然后每次循环扩大10倍，再用一个变量len记录当前循环区间数字的位数，另外再需要一个变量start用来记录当前循环区间的第一个数字，我们n每次循环都减去len*cnt (区间总位数)，当n落到某一个确定的区间里了，那么(n-1)/len就是目标数字在该区间里的坐标，加上start就是得到了目标数字，然后我们将目标数字start转为字符串，(n-1)%len就是所要求的目标位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> len = <span class="number">1</span>, cnt = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到n是几位数</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; len * cnt) &#123;</span><br><span class="line">            n -= len * cnt;</span><br><span class="line">            ++len;</span><br><span class="line">            cnt *= <span class="number">10</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到n应该落在哪个自然数上</span></span><br><span class="line">        start += (n - <span class="number">1</span>) / len;</span><br><span class="line">        string t = <span class="built_in">to_string</span>(start);</span><br><span class="line">        <span class="comment">// 求这个自然数会落在自然数的那一位上</span></span><br><span class="line">        <span class="keyword">return</span> t[(n - <span class="number">1</span>) % len] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Reverse-Nodes-in-k-Group-每k个一组翻转链表"><a href="#Reverse-Nodes-in-k-Group-每k个一组翻转链表" class="headerlink" title="Reverse Nodes in k-Group 每k个一组翻转链表"></a>Reverse Nodes in k-Group 每k个一组翻转链表</h1><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>实际上是把原链表分成若干小段，然后分别对其进行翻转，那么肯定总共需要两个函数，一个是用来分段的，一个是用来翻转的。</p>
<p>pre 和 next 分别指向要翻转的链表的前后的位置，然后翻转后 pre 的位置更新到如下新的位置</p>
<p><img src="/2019/07/27/%E9%9D%A2%E8%AF%95%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98/2.png"></p>
<p>以此类推，只要 cur 走过k个节点，那么 next 就是 cur-&gt;next，就可以调用翻转函数来进行局部翻转了，注意翻转之后新的 cur 和 pre 的位置都不同了，那么翻转之后，cur 应该更新为 pre-&gt;next，而如果不需要翻转的话，cur 更新为 cur-&gt;next。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy, *cur = head;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; cur; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = <span class="built_in">reverseOneGroup</span>(pre, cur-&gt;next);</span><br><span class="line">                cur = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseOneGroup</span><span class="params">(ListNode* pre, ListNode* next)</span> </span>&#123;</span><br><span class="line">        ListNode *last = pre-&gt;next, *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h1><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>

<p>引入动态规划思想，记忆化搜索，用一个数组 len[][] 记录任意点的递增路径长度，再利用一个 visited[][] 数组记录当前位置是否遍历过，如果已经处理过该点，那么直接返回该点对应的路径长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] row = &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] col = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length ==<span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span>[][] len = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                max = Math.max(max,find(matrix,visited,len,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">boolean</span>[][] visited,<span class="keyword">int</span>[][] len,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[x][y])</span><br><span class="line">            <span class="keyword">return</span> len[x][y];</span><br><span class="line">        len[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curX = x + row[i];</span><br><span class="line">            <span class="keyword">int</span> curY = y + col[i];</span><br><span class="line">            <span class="keyword">if</span>(curX &gt;=<span class="number">0</span> &amp;&amp; curX &lt; matrix.length &amp;&amp; curY &gt;=<span class="number">0</span> &amp;&amp; curY&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[curX][curY] &lt; matrix[x][y])&#123;</span><br><span class="line">                len[x][y] = Math.max(len[x][y],find(matrix,visited,len,curX,curY)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> len[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求数组中区间中最小数-区间所有数和的最大值"><a href="#求数组中区间中最小数-区间所有数和的最大值" class="headerlink" title="求数组中区间中最小数*区间所有数和的最大值"></a>求数组中区间中最小数*区间所有数和的最大值</h1><p>给定一段数组，求每个区间的最小值乘这段区间的和，输出每个区间得到的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样例输入：[1 2 6]，可能有以下几种情况：</span><br><span class="line">[1]：结果为1*1=1；</span><br><span class="line">[2]：结果为2*2=4；</span><br><span class="line">[6]：结果为6*6=36；</span><br><span class="line">[1,2]：结果为1*(1+2)=3;</span><br><span class="line">[2,6]：结果为2*(2+6)=16;</span><br><span class="line">[1,2,6]：结果为1*(1+2+6)=9;</span><br><span class="line">最大值为36，输出36即可。</span><br></pre></td></tr></table></figure>

<p>以数组中每一个值为最小值，假设这个最小值为num[k], 分别找到以该值num[k]为最小值，数组最左边的小于该值的下标i，和数组最右边的小于该值的下标j, 则区间num[i+1,j-1]为以num[k]为最小值所能达到的最大区间，则此区间能达到的最大值为 num[k]*Sum(i+1,j-1)，其中 Sum 函数为数组中区间[i+1,j+1]的所有数的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//右边界</span></span><br><span class="line">            sum[i] = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt;= arr[i]) &#123;</span><br><span class="line">                    sum[i] += arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt;= arr[i]) &#123;</span><br><span class="line">                    sum[i] += arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,sum[i]*arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a>LeetCode 31. 下一个排列</h1><p>实现获取下一个排列函数，这个算法需要将数字重新排列成字典序中数字更大的排列。</p>
<p>如果不存在更大的排列，则重新将数字排列成最小的排列（即升序排列）</p>
<p>以一个例子来分析，给定325421，求其下一个比它大的数，怎么办呢？我们应该从最低位开始，1-&gt;2-&gt;4-&gt;5,这一段是升序的，也就是5421已经是最大数，不存在比它大的组合，我们继续找，1-&gt;2-&gt;4-&gt;5-&gt;2，出现降序这个位置就是我们要找的关键点，只需要将2与其后的数字中的（1,2,4,5）比它大的最小数，也就4替换，然后再将后面的数（1,2,2,5）升序排列便可得到下一个数，过程为：325421-&gt;345221-&gt;345122</p>
<p>解法：从后往前遍历数组，找到当前节点右侧第一个比当前节点大的数，交换他们，然后使当前右侧有序即可。<br>假设数组nums长度为n（从0开始编号），数组中nums[i]到第nums[n-1]逆序（降序排列），且nums[i-1]&lt;nums[i]，则下一个全排列时只需要考虑nums[i-1]到nums[n-1]即可，在i-1 右侧找到第一个大于nums[i-1] 的数，交换他们顺序，则后面升序排列就是最小的数，即下一个全排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>;j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                    swap(nums[i],nums[j]);</span><br><span class="line">                    sort(nums.begin()+i+<span class="number">1</span>,nums.end());</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="划分为k个相等的子集"><a href="#划分为k个相等的子集" class="headerlink" title="划分为k个相等的子集"></a>划分为k个相等的子集</h1><p>给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4</span><br><span class="line">输出： True</span><br><span class="line">说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</span><br></pre></td></tr></table></figure>

<p>先求出平均数avg，假如平均数avg不为整数，也就是说数组的数字总和不能平均的分为k份，那么直接返回false。</p>
<p>创建一个布尔数组flag，来记录nums数组中数字的状态（已用还是未用）， temp 初始为avg ，temp的作用为记录当前子集的数字总和，当temp等于0时，当前这个子集也就可以确定。index是用来记录遍历数组时从哪个位置开始遍历，以防将前面的数字重新计算。</p>
<p>当k个子集全部求解完，返回true，如果一直求解不出，则返回false。当temp = 0 的时候，也就是新一个子集求解完，那么继续求解下一个子集，k-1，temp重新置为avg；当temp ！= 0 时，就是子集还未求解完，那么继续求解子集，继续从数组中取数字，递归求解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">            sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = sum / k;</span><br><span class="line">        boolean[] flag = <span class="keyword">new</span> boolean[len];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(nums,flag,avg,k,avg,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] nums, boolean[] flag, <span class="keyword">int</span> avg, <span class="keyword">int</span> k, <span class="keyword">int</span> temp, <span class="keyword">int</span> index )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">help</span>(nums,flag,avg,k<span class="number">-1</span>,avg,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp-nums[i]&gt;=<span class="number">0</span> &amp;&amp; <span class="built_in">help</span>(nums,flag,avg,k,temp-nums[i],index+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题训练</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
