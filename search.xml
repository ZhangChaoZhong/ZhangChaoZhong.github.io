<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人资源分享</title>
    <url>/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="计算机视觉（持续更新）"><a href="#计算机视觉（持续更新）" class="headerlink" title="计算机视觉（持续更新）"></a>计算机视觉（持续更新）</h1><h2 id="（一）工具"><a href="#（一）工具" class="headerlink" title="（一）工具"></a>（一）工具</h2><h3 id="1-0-PPT模板"><a href="#1-0-PPT模板" class="headerlink" title="1.0 PPT模板"></a>1.0 PPT模板</h3><h4 id="学术模板"><a href="#学术模板" class="headerlink" title="学术模板"></a><a href="ppt/%E5%AD%A6%E6%9C%AF%E6%A8%A1%E6%9D%BF.pptx">学术模板</a></h4><h4 id="创新项目模板"><a href="#创新项目模板" class="headerlink" title="创新项目模板"></a><a href="ppt/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF.pptx">创新项目模板</a></h4><h4 id="项目介绍模板"><a href="#项目介绍模板" class="headerlink" title="项目介绍模板"></a><a href="ppt/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E6%A8%A1%E6%9D%BF.pptx">项目介绍模板</a></h4><h4 id="开题报告模板16-9"><a href="#开题报告模板16-9" class="headerlink" title="开题报告模板16:9"></a><a href="ppt/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF.pptx">开题报告模板16:9</a></h4><h4 id="开题报告模板4-3"><a href="#开题报告模板4-3" class="headerlink" title="开题报告模板4:3"></a><a href="ppt/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF2.pptx">开题报告模板4:3</a></h4><h3 id="1-1-绘图"><a href="#1-1-绘图" class="headerlink" title="1.1 绘图"></a>1.1 绘图</h3><h4 id="1-PPT-🌟"><a href="#1-PPT-🌟" class="headerlink" title="(1) PPT 🌟"></a>(1) PPT 🌟</h4><blockquote>
<p>一般用来画神经网络图，当然，画流程图，技术路线图都可以，全能的</p>
<p>推荐一个PPT科研绘图实例库  <a href="https://docs.google.com/presentation/d/11mR1nkIR9fbHegFkcFq8z9oDQ5sjv8E3JJp1LfLGKuk/edit?usp=sharing">PPT好看的科研图</a></p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230246901.png" alt="image-20211225230246901"></p>
<p><code>上面是我画的一个神经网络图</code></p>
<span id="more"></span>

<h4 id="2-processon-🌟"><a href="#2-processon-🌟" class="headerlink" title="(2) processon 🌟"></a><a href="https://www.processon.com/">(2) processon</a> 🌟</h4><blockquote>
<p>一般用来画技术路线图，系统架构图<br>唯一缺点：无法导出高清图（需要付费），不过清晰度也够用了</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230536808.png" alt="image-20211225230536808"></p>
<h4 id="3-diagrams-🌟"><a href="#3-diagrams-🌟" class="headerlink" title="(3) diagrams 🌟"></a><a href="https://app.diagrams.net/">(3) diagrams</a> 🌟</h4><blockquote>
<p>跟上面基本一样，但可以导出高清图，下面是我画的一个图</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225231147475.png" alt="image-20211225231147475"></p>
<h4 id="4-codeimg"><a href="#4-codeimg" class="headerlink" title="(4) codeimg"></a><a href="https://codeimg.io/">(4) codeimg</a></h4><h4 id="5-carbon"><a href="#5-carbon" class="headerlink" title="(5) carbon"></a><a href="https://carbon.now.sh/">(5) carbon</a></h4><blockquote>
<p>上面2个都可以将代码块转为图片</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230347535.png" alt="image-20211225230347535"></p>
<h4 id="6-在线PS"><a href="#6-在线PS" class="headerlink" title="(6) 在线PS"></a><a href="https://ps.gaoding.com/#/">(6) 在线PS</a></h4><h4 id="7-python科研图"><a href="#7-python科研图" class="headerlink" title="(7) python科研图"></a>(7) python科研图</h4><p><a href="https://github.com/garrettj403/SciencePlots">https://github.com/garrettj403/SciencePlots</a> 🌟🌟🌟🌟🌟</p>
<p><a href="https://github.com/reiinakano/scikit-plot">https://github.com/reiinakano/scikit-plot</a></p>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230436063.png" alt="image-20211225230436063"></p>
<h3 id="1-2-论文搜索"><a href="#1-2-论文搜索" class="headerlink" title="1.2 论文搜索"></a>1.2 论文搜索</h3><h4 id="1-中文SCIHUB"><a href="#1-中文SCIHUB" class="headerlink" title="(1) 中文SCIHUB"></a><a href="https://www.scihub.net.cn/">(1) 中文SCIHUB</a></h4><blockquote>
<p>非常全的一个论文检索网站</p>
</blockquote>
<h4 id="2-connectedpapers-🌟"><a href="#2-connectedpapers-🌟" class="headerlink" title="(2) connectedpapers 🌟"></a><a href="https://www.connectedpapers.com/">(2) connectedpapers</a> 🌟</h4><blockquote>
<p>可以生成查找论文的关系网络，理清某方向的研究脉络，写文献综述方便</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225230143574.png" alt="image-20211225230143574"></p>
<h4 id="3-researchrabbitapp-🌟"><a href="#3-researchrabbitapp-🌟" class="headerlink" title="(3) researchrabbitapp 🌟"></a><a href="https://researchrabbitapp.com/">(3) researchrabbitapp</a> 🌟</h4><blockquote>
<p>又一个写文献综述神器，注册时，随便网上找一个学校邮箱注册就行</p>
</blockquote>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211225225937935.png" alt="image-20211225225937935"></p>
<h4 id="4-SCIHUB-🌟"><a href="#4-SCIHUB-🌟" class="headerlink" title="(4) SCIHUB 🌟"></a><a href="https://www.sci-hub.ren/">(4) SCIHUB</a> 🌟</h4><blockquote>
<p>无敌，几乎可以搜索到所有论文</p>
</blockquote>
<h4 id="5-paperswithcode-🌟"><a href="#5-paperswithcode-🌟" class="headerlink" title="(5) paperswithcode 🌟"></a><a href="https://paperswithcode.com/">(5) paperswithcode</a> 🌟</h4><blockquote>
<p><strong>可以找到论文的代码</strong>，以及当前研究任务的排行榜</p>
</blockquote>
<h4 id="6-arxiv"><a href="#6-arxiv" class="headerlink" title="(6) arxiv"></a><a href="https://arxiv.org/">(6) arxiv</a></h4><h4 id="7-谷歌学术"><a href="#7-谷歌学术" class="headerlink" title="(7) 谷歌学术"></a><a href="https://scholar.google.com/">(7) 谷歌学术</a></h4><h4 id="8-X-MOL"><a href="#8-X-MOL" class="headerlink" title="(8) X-MOL"></a><a href="https://www.x-mol.com/">(8) X-MOL</a></h4><blockquote>
<p>支持订阅的论文网站（有手机端，网页端）</p>
</blockquote>
<h4 id="9-easyScholar"><a href="#9-easyScholar" class="headerlink" title="(9) easyScholar"></a><a href>(9) easyScholar</a></h4><blockquote>
<p>判断文献质量（浏览器插件就可以安装）</p>
</blockquote>
<h3 id="期刊选择"><a href="#期刊选择" class="headerlink" title="期刊选择"></a>期刊选择</h3><h4 id="1-Journalrank"><a href="#1-Journalrank" class="headerlink" title="(1)Journalrank"></a><a href="https://www.scimagojr.com/journalrank.php">(1)Journalrank</a></h4><h4 id="2-Journalguide"><a href="#2-Journalguide" class="headerlink" title="(2)Journalguide"></a><a href="https://www.journalguide.com/">(2)Journalguide</a></h4><h3 id="1-3-转转小工具"><a href="#1-3-转转小工具" class="headerlink" title="1.3 转转小工具"></a>1.3 转转小工具</h3><h4 id="1-PDF转PPT"><a href="#1-PDF转PPT" class="headerlink" title="(1) PDF转PPT"></a><a href="https://smallpdf.com/pdf-to-ppt">(1) PDF转PPT</a></h4><h4 id="2-视频转文字-🌟"><a href="#2-视频转文字-🌟" class="headerlink" title="(2) 视频转文字 🌟"></a><a href="https://www.feishu.cn/product/minutes">(2) 视频转文字</a> 🌟</h4><blockquote>
<p>类似于自动生成字幕，还可以提取里面对话的关键信息</p>
</blockquote>
<h4 id="3-B站视频下载"><a href="#3-B站视频下载" class="headerlink" title="(3) B站视频下载"></a><a href="https://xbeibeix.com/api/bilibili/">(3) B站视频下载</a></h4><h3 id="1-4-素材"><a href="#1-4-素材" class="headerlink" title="1.4 素材"></a>1.4 素材</h3><h4 id="（1）插图"><a href="#（1）插图" class="headerlink" title="（1）插图"></a>（1）插图</h4><p><a href="https://undraw.co/search">https://undraw.co/search</a></p>
<p><a href="https://www.manypixels.co/gallery">https://www.manypixels.co/gallery</a></p>
<h4 id="（2）图标"><a href="#（2）图标" class="headerlink" title="（2）图标"></a>（2）图标</h4><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p>
<p><a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a></p>
<h3 id="1-5-写作"><a href="#1-5-写作" class="headerlink" title="1.5 写作"></a>1.5 写作</h3><h4 id="（1）latex写论文"><a href="#（1）latex写论文" class="headerlink" title="（1）latex写论文"></a>（1）latex写论文</h4><p><a href="https://www.overleaf.com/">https://www.overleaf.com/</a></p>
<h4 id="（2）语法纠错"><a href="#（2）语法纠错" class="headerlink" title="（2）语法纠错"></a>（2）语法纠错</h4><p><a href="https://www.grammarly.com/grammar-check">https://www.grammarly.com/grammar-check</a></p>
<h4 id="（3）句子改写"><a href="#（3）句子改写" class="headerlink" title="（3）句子改写"></a>（3）句子改写</h4><p><a href="https://app.wordtune.com/">https://app.wordtune.com</a></p>
<p><a href="https://quillbot.com/">https://quillbot.com/</a></p>
<p><a href="https://paraphrasing-tool.com/">https://paraphrasing-tool.com/</a></p>
<h4 id="（4）句式套路"><a href="#（4）句式套路" class="headerlink" title="（4）句式套路"></a>（4）句式套路</h4><p><a href="https://www.phrasebank.manchester.ac.uk/describing-methods/">https://www.phrasebank.manchester.ac.uk/describing-methods/</a></p>
<h4 id="（5）翻译软件"><a href="#（5）翻译软件" class="headerlink" title="（5）翻译软件"></a>（5）翻译软件</h4><p><a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></p>
<p><a href="https://fanyi.baidu.com/">https://fanyi.baidu.com/</a></p>
<p><a href="https://fanyi.youdao.com/">https://fanyi.youdao.com/</a></p>
<h3 id="1-6-搜索途径"><a href="#1-6-搜索途径" class="headerlink" title="1.6 搜索途径"></a>1.6 搜索途径</h3><h4 id="（1）微信公众号文章-🌟"><a href="#（1）微信公众号文章-🌟" class="headerlink" title="（1）微信公众号文章 🌟"></a>（1）微信公众号文章 🌟</h4><blockquote>
<p>质量比较高，毕竟为了运营</p>
</blockquote>
<h4 id="（2）知乎"><a href="#（2）知乎" class="headerlink" title="（2）知乎"></a>（2）知乎</h4><h4 id="（3）谷歌"><a href="#（3）谷歌" class="headerlink" title="（3）谷歌"></a>（3）谷歌</h4><h4 id="（4）必应"><a href="#（4）必应" class="headerlink" title="（4）必应"></a>（4）必应</h4><h4 id="（5）百度"><a href="#（5）百度" class="headerlink" title="（5）百度"></a>（5）百度</h4><h2 id="（二）社区网站"><a href="#（二）社区网站" class="headerlink" title="（二）社区网站"></a>（二）社区网站</h2><h3 id="1-极市开发者社区-🌟"><a href="#1-极市开发者社区-🌟" class="headerlink" title="(1) 极市开发者社区 🌟"></a><a href="https://bbs.cvmart.net/">(1) 极市开发者社区</a> 🌟</h3><h3 id="2-智源社区"><a href="#2-智源社区" class="headerlink" title="(2) 智源社区"></a><a href="https://hub.baai.ac.cn/">(2) 智源社区</a></h3><h3 id="3-飞浆"><a href="#3-飞浆" class="headerlink" title="(3) 飞浆"></a><a href="https://www.paddlepaddle.org.cn/developercommunity">(3) 飞浆</a></h3><h3 id="4-和鲸社区"><a href="#4-和鲸社区" class="headerlink" title="(4) 和鲸社区"></a><a href="https://www.heywhale.com/home/project">(4) 和鲸社区</a></h3><h3 id="5-红色石头"><a href="#5-红色石头" class="headerlink" title="(5) 红色石头"></a><a href="https://redstonewill.com/">(5) 红色石头</a></h3><h3 id="6-我爱计算机视觉-🌟"><a href="#6-我爱计算机视觉-🌟" class="headerlink" title="(6) 我爱计算机视觉 🌟"></a><a href="https://www.52cv.net/">(6) 我爱计算机视觉</a> 🌟</h3><h3 id="7-GiantPandaCV-🌟"><a href="#7-GiantPandaCV-🌟" class="headerlink" title="(7) GiantPandaCV 🌟"></a><a href="http://giantpandacv.com/">(7) GiantPandaCV</a> 🌟</h3><h3 id="8-SIGAI"><a href="#8-SIGAI" class="headerlink" title="(8) SIGAI"></a><a href="https://www.zhihu.com/org/bei-jing-zhang-liang-wu-xian-ke-ji-you-xian-gong-si/posts">(8) SIGAI</a></h3><h2 id="（三）教程"><a href="#（三）教程" class="headerlink" title="（三）教程"></a>（三）教程</h2><h3 id="1-tensorflow2"><a href="#1-tensorflow2" class="headerlink" title="(1) tensorflow2"></a><a href="https://github.com/lyhue1991/eat_tensorflow2_in_30_days">(1) tensorflow2</a></h3><h3 id="2-pytorch"><a href="#2-pytorch" class="headerlink" title="(2) pytorch"></a><a href="https://github.com/lyhue1991/eat_pytorch_in_20_days">(2) pytorch</a></h3><h3 id="3-flask"><a href="#3-flask" class="headerlink" title="(3) flask"></a><a href="https://github.com/qzq1111/flask-restful-example">(3) flask</a></h3><h3 id="4-Ai-learn"><a href="#4-Ai-learn" class="headerlink" title="(4) Ai-learn"></a><a href="https://github.com/tangyudi/Ai-learn">(4) Ai-learn</a></h3><h3 id="5-莫烦-🌟"><a href="#5-莫烦-🌟" class="headerlink" title="(5) 莫烦 🌟"></a><a href="https://mofanpy.com/">(5) 莫烦</a> 🌟</h3><h3 id="6-李宏毅-🌟"><a href="#6-李宏毅-🌟" class="headerlink" title="(6) 李宏毅 🌟"></a><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses.html">(6) 李宏毅</a> 🌟</h3><h3 id="7-网络搭建-🌟"><a href="#7-网络搭建-🌟" class="headerlink" title="(7) 网络搭建 🌟"></a><a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">(7) 网络搭建</a> 🌟</h3><h2 id="（四）项目"><a href="#（四）项目" class="headerlink" title="（四）项目"></a>（四）项目</h2><blockquote>
<p>以下总结项目开发用得上的github</p>
</blockquote>
<h3 id="4-1模型"><a href="#4-1模型" class="headerlink" title="4.1模型"></a>4.1模型</h3><h4 id="（1）目标检测🌟"><a href="#（1）目标检测🌟" class="headerlink" title="（1）目标检测🌟"></a>（1）目标检测🌟</h4><p><a href="https://github.com/ultralytics/yolov5">Yolov5</a> </p>
<p><a href="https://github.com/PaddlePaddle/PaddleDetection">飞浆检测框架</a></p>
<h4 id="（2）目标检测（移动端）"><a href="#（2）目标检测（移动端）" class="headerlink" title="（2）目标检测（移动端）"></a>（2）目标检测（移动端）</h4><p><a href="https://github.com/ppogg/YOLOv5-Lite">YOLOv5-Lite</a></p>
<p><a href="https://github.com/cmdbug/YOLOv5_NCNN">YOLOv5_NCNN</a></p>
<h4 id="（3）目标跟踪"><a href="#（3）目标跟踪" class="headerlink" title="（3）目标跟踪"></a>（3）目标跟踪</h4><p><a href="https://github.com/mikel-brostrom/Yolov5_DeepSort_Pytorch">Yolov5_DeepSort</a></p>
<p><a href="https://github.com/cong/yolov5_deepsort_tensorrt">yolov5_deepsort_tensorrt</a></p>
<h4 id="（4）行为检测"><a href="#（4）行为检测" class="headerlink" title="（4）行为检测"></a>（4）行为检测</h4><p><a href="https://github.com/open-mmlab/mmaction2">mmaction2</a></p>
<h4 id="（5）姿态检测"><a href="#（5）姿态检测" class="headerlink" title="（5）姿态检测"></a>（5）姿态检测</h4><p><a href="https://github.com/MVIG-SJTU/AlphaPose">AlphaPose</a></p>
<h4 id="（6）人脸检测-amp-识别🌟"><a href="#（6）人脸检测-amp-识别🌟" class="headerlink" title="（6）人脸检测&amp;识别🌟"></a>（6）人脸检测&amp;识别🌟</h4><p><a href="https://github.com/deepinsight/insightface">insightface</a></p>
<p><a href="https://github.com/ronghuaiyang/arcface-pytorch">arcface</a></p>
<h4 id="（7）头部检测🌟"><a href="#（7）头部检测🌟" class="headerlink" title="（7）头部检测🌟"></a>（7）头部检测🌟</h4><p><a href="https://github.com/tgisaturday/S3FD_ATSS_SAPD">S3FD_ATSS_SAPD</a></p>
<p><a href="https://github.com/YonghaoHe/LFFD-A-Light-and-Fast-Face-Detector-for-Edge-Devices/tree/master/head_detection">head_detection</a></p>
<h4 id="（8）车牌检测🌟"><a href="#（8）车牌检测🌟" class="headerlink" title="（8）车牌检测🌟"></a>（8）车牌检测🌟</h4><p><a href="https://github.com/zeusees/License-Plate-Detector">License-Plate-Detector</a></p>
<p><a href="https://github.com/detectRecog/CCPD">CCPD</a></p>
<p><a href="https://github.com/xialuxi/yolov5-car-plate">yolov5-car-plate</a></p>
<h4 id="（9）图像分类🌟"><a href="#（9）图像分类🌟" class="headerlink" title="（9）图像分类🌟"></a>（9）图像分类🌟</h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/56779">resNet</a></p>
<p><a href="https://aistudio.baidu.com/aistudio/projectdetail/56889">SE_ResNeXt</a></p>
<p><a href="https://github.com/PaddlePaddle/PaddleClas">PaddleClas</a></p>
<h4 id="（10）文字识别🌟"><a href="#（10）文字识别🌟" class="headerlink" title="（10）文字识别🌟"></a>（10）文字识别🌟</h4><p><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a></p>
<h4 id="（11）实例分割"><a href="#（11）实例分割" class="headerlink" title="（11）实例分割"></a>（11）实例分割</h4><p><a href="https://github.com/dbolya/yolact">yolact</a></p>
<h4 id="（12）抠图"><a href="#（12）抠图" class="headerlink" title="（12）抠图"></a>（12）抠图</h4><p><a href="https://github.com/ZHKKKe/MODNet">MODNet</a></p>
<p><a href="https://github.com/danielgatis/rembg">rembg</a></p>
<h4 id="（13）小目标检测"><a href="#（13）小目标检测" class="headerlink" title="（13）小目标检测"></a>（13）小目标检测</h4><p><a href="https://mp.weixin.qq.com/s/mz3gC_PUhM7th0UboOAhzQ">YOLO-Z</a></p>
<h4 id="（14）文本分类🌟"><a href="#（14）文本分类🌟" class="headerlink" title="（14）文本分类🌟"></a>（14）文本分类🌟</h4><p><a href="https://github.com/649453932/Bert-Chinese-Text-Classification-Pytorch">Bert-Chinese-Text-Classification-Pytorch</a></p>
<p><a href="https://github.com/ymcui/Chinese-BERT-wwm">Chinese-BERT-wwm</a></p>
<p><a href="https://github.com/huggingface/transformers">transformers</a></p>
<h4 id="（15）文本纠错"><a href="#（15）文本纠错" class="headerlink" title="（15）文本纠错"></a>（15）文本纠错</h4><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/1872369">ERNIE</a></p>
<p><a href="https://github.com/PaddlePaddle/PaddleNLP">PaddleNLP</a></p>
<h4 id="（16）文章摘要"><a href="#（16）文章摘要" class="headerlink" title="（16）文章摘要"></a>（16）文章摘要</h4><p><a href="https://github.com/huggingface/transformers">transformers</a></p>
<h3 id="4-2-模型加速"><a href="#4-2-模型加速" class="headerlink" title="4.2 模型加速"></a>4.2 模型加速</h3><blockquote>
<p>ONNX 作为<strong>神经网络交换格式</strong></p>
</blockquote>
<h4 id="1-TensorRT"><a href="#1-TensorRT" class="headerlink" title="(1) TensorRT"></a><a href="https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html">(1) TensorRT</a></h4><p><a href="https://github.com/wang-xinyu/tensorrtx">tensorrtx</a></p>
<blockquote>
<p>不支持WIN系统的Python API调用</p>
</blockquote>
<h4 id="2-NCNN"><a href="#2-NCNN" class="headerlink" title="(2) NCNN"></a><a href="https://github.com/Tencent/ncnn">(2) NCNN</a></h4><h4 id="3-OpenVINO"><a href="#3-OpenVINO" class="headerlink" title="(3) OpenVINO"></a><a href="https://docs.openvinotoolkit.org/latest/index.html">(3) OpenVINO</a></h4><h3 id="4-3-中间件"><a href="#4-3-中间件" class="headerlink" title="4.3 中间件"></a>4.3 中间件</h3><h4 id="（1）消息推送-amp-通信"><a href="#（1）消息推送-amp-通信" class="headerlink" title="（1）消息推送&amp;通信"></a>（1）消息推送&amp;通信</h4><p><a href="https://github.com/miguelgrinberg/Flask-SocketIO">flask-socketio</a></p>
<h4 id="（2）向量检索"><a href="#（2）向量检索" class="headerlink" title="（2）向量检索"></a>（2）向量检索</h4><p><a href="https://github.com/erikbern/ann-benchmarks/">Annoy</a></p>
<h4 id="（3）全文检索引擎"><a href="#（3）全文检索引擎" class="headerlink" title="（3）全文检索引擎"></a>（3）全文检索引擎</h4><p><a href="https://elasticsearch-py.readthedocs.io/en/v7.16.2/">Elasticsearch</a></p>
<h4 id="（4）缓存"><a href="#（4）缓存" class="headerlink" title="（4）缓存"></a>（4）缓存</h4><p><a href="https://www.runoob.com/w3cnote/python-redis-intro.html">Redis</a></p>
<h4 id="（6）消息队列"><a href="#（6）消息队列" class="headerlink" title="（6）消息队列"></a>（6）消息队列</h4><p><a href="https://github.com/pika/pika">RabbitMQ</a></p>
<h4 id="（7）线程-amp-多进程"><a href="#（7）线程-amp-多进程" class="headerlink" title="（7）线程&amp;多进程"></a>（7）线程&amp;多进程</h4><blockquote>
<p>解决摄像头读取延迟问题</p>
</blockquote>
<p><a href="https://github.com/Yonv1943/Python/blob/master/Demo_camera_and_network/ip_camera.py">Ip_camera</a></p>
<p><a href="https://mp.weixin.qq.com/s/3xTdtrcyZ3BVCjjEXeaExA">多进程读取</a></p>
<h4 id="（8）分库分表，读写分离"><a href="#（8）分库分表，读写分离" class="headerlink" title="（8）分库分表，读写分离"></a>（8）分库分表，读写分离</h4><p><a href="https://shardingsphere.apache.org/index_zh.html">shardingsphere</a></p>
<h3 id="4-4-开源项目"><a href="#4-4-开源项目" class="headerlink" title="4.4 开源项目"></a>4.4 开源项目</h3><h4 id="（1）-Html网站模板"><a href="#（1）-Html网站模板" class="headerlink" title="（1） Html网站模板"></a>（1） Html网站模板</h4><p><a href="http://www.pearadmin.com/">pearadmin</a></p>
<h4 id="（2）-Vue网站模板"><a href="#（2）-Vue网站模板" class="headerlink" title="（2） Vue网站模板"></a>（2） Vue网站模板</h4><p><a href="https://github.com/PanJiaChen/vue-element-admin/tree/i18n">vue-element-admin</a></p>
<p><a href="https://github.com/bihell/Dice">Dice</a></p>
<p><a href="http://webflash.enilu.cn/">webflash</a></p>
<p><a href="https://github.com/microapp-store/linjiashop">linjiashop</a></p>
<h4 id="（3）-网站框架"><a href="#（3）-网站框架" class="headerlink" title="（3）  网站框架"></a>（3）  网站框架</h4><p><a href="https://arco.design/">arcodesign</a></p>
<p><a href="https://semi.design/zh-CN">semidesign</a></p>
<p><a href="https://pro.ant.design/">Ant Design Pro</a></p>
<p><a href="https://tdesign.tencent.com/starter/docs/get-started">TDesign</a></p>
<h4 id="（4）-跨平台应用开发"><a href="#（4）-跨平台应用开发" class="headerlink" title="（4） 跨平台应用开发"></a>（4） 跨平台应用开发</h4><p><a href="https://flutterchina.club/">Flutter</a></p>
<h4 id="（5）-桌面开发"><a href="#（5）-桌面开发" class="headerlink" title="（5） 桌面开发"></a>（5） 桌面开发</h4><p><a href="https://github.com/PyQt5/PyQt">PyQt</a></p>
<h4 id="（6）-移动开发"><a href="#（6）-移动开发" class="headerlink" title="（6） 移动开发"></a>（6） 移动开发</h4><p><a href="https://github.com/Tencent/QMUI_Android">QMUI_Android</a></p>
<h4 id="4-5-数字图像处理工具包"><a href="#4-5-数字图像处理工具包" class="headerlink" title="4.5 数字图像处理工具包"></a>4.5 数字图像处理工具包</h4><p><a href="https://github.com/o0o0o0o0o0o0o/image-processing-from-scratch">(1) image-processing</a></p>
<p><a href="https://github.com/CodecWang/opencv-python-tutorial">(2) opencv-python-tutorial</a></p>
<p><a href="https://github.com/PyImageSearch/imutils">(3) imutils</a></p>
<h4 id="4-6-图像-amp-文本特征提取"><a href="#4-6-图像-amp-文本特征提取" class="headerlink" title="4.6 图像&amp;文本特征提取"></a>4.6 图像&amp;文本特征提取</h4><p><a href="https://github.com/1044197988/Python-Image-feature-extraction">(1) Python-Image-feature-extraction</a></p>
<h2 id="（五）相关建议"><a href="#（五）相关建议" class="headerlink" title="（五）相关建议"></a>（五）相关建议</h2><h3 id="5-1导师沟通"><a href="#5-1导师沟通" class="headerlink" title="5.1导师沟通"></a>5.1导师沟通</h3><h4 id="（1）礼貌"><a href="#（1）礼貌" class="headerlink" title="（1）礼貌"></a>（1）礼貌</h4><blockquote>
<p>（1）打招呼，您</p>
<p>（2）进办公室，记得敲门</p>
</blockquote>
<h4 id="（2）及时反馈"><a href="#（2）及时反馈" class="headerlink" title="（2）及时反馈"></a>（2）及时反馈</h4><blockquote>
<p>交待的事情，做完或没做完都得及时跟导师说下</p>
</blockquote>
<h4 id="（3）想好再说"><a href="#（3）想好再说" class="headerlink" title="（3）想好再说"></a>（3）想好再说</h4><blockquote>
<p>（1）发信息要逻辑清晰，不要让老师去猜…</p>
<p>（2）有些事情无法在通过发信息说清，最好通过语音或者线下跟导师沟通</p>
</blockquote>
<h4 id="（4）有事提前说"><a href="#（4）有事提前说" class="headerlink" title="（4）有事提前说"></a>（4）有事提前说</h4><blockquote>
<p>（1）回家／组会请假：具体原因（不要含糊），具体时间，提前1-2天</p>
</blockquote>
<h4 id="（5）不用什么事情都交代"><a href="#（5）不用什么事情都交代" class="headerlink" title="（5）不用什么事情都交代"></a>（5）不用什么事情都交代</h4><blockquote>
<p>导师：不喜欢学生搞科研之外的事情（比如：蓝桥杯，华为杯等竞赛）</p>
<p>（1）自己确实报名参加了，不用跟导师说，直接去就行，千万不要组会上跟他说</p>
<p>（2）汇报内容最好是课程专业学习，论文，机器学习基础知识。</p>
</blockquote>
<h3 id="5-2-选课建议（专硕）"><a href="#5-2-选课建议（专硕）" class="headerlink" title="5.2 选课建议（专硕）"></a>5.2 选课建议（专硕）</h3><table>
<thead>
<tr>
<th>自然辩证法概论</th>
</tr>
</thead>
<tbody><tr>
<td>中国特色社会主义理论与实践研究</td>
</tr>
<tr>
<td>英语</td>
</tr>
<tr>
<td>专业英语</td>
</tr>
<tr>
<td>数据结构</td>
</tr>
<tr>
<td>统计学习</td>
</tr>
<tr>
<td>运筹学</td>
</tr>
<tr>
<td>高级操作系统或者计算机网络</td>
</tr>
<tr>
<td>工程伦理</td>
</tr>
<tr>
<td>软件系统实验</td>
</tr>
<tr>
<td>专业实践</td>
</tr>
<tr>
<td>劳动教育</td>
</tr>
</tbody></table>
<blockquote>
<p>组合数学，软件形式化方法（禁选）</p>
</blockquote>
<h2 id="（六）学术相关"><a href="#（六）学术相关" class="headerlink" title="（六）学术相关"></a>（六）学术相关</h2><h3 id="6-1-开题报告注意事项"><a href="#6-1-开题报告注意事项" class="headerlink" title="6.1 开题报告注意事项"></a>6.1 开题报告注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.技术路线图</span><br><span class="line">  1）要解释说明（详细点）</span><br><span class="line">  2）打印出来的图要清晰，最好不要加填充颜色（ppt可以）</span><br><span class="line">2.研究内容，采用什么方法解决什么问题</span><br><span class="line">3.关键技术，不能只是关键字</span><br><span class="line">4.参考文献</span><br><span class="line">  1）参考文献要有中英文献</span><br><span class="line">  2）引用要按顺序，或者时间顺序</span><br><span class="line">  3）参考文献时间近5年，不能太久远</span><br><span class="line">  4）有35多篇左右</span><br><span class="line">  5）文献按照GB/T 7714格式</span><br><span class="line">  5.英文字体要罗马字体</span><br><span class="line">6.打印的时候注意检查格式（行间距）</span><br><span class="line">7.选题类型跟老师商量</span><br><span class="line">8.标题，子标题，关键内容最好加粗（增强可读性）</span><br><span class="line">9.第一次出现的缩写英文，要用全称</span><br><span class="line">10.表达</span><br><span class="line">  1）不能口语化</span><br><span class="line">  2）简洁表达，不要啰嗦</span><br><span class="line">  3）不能使用我，我们等主观词语</span><br><span class="line">10.图要有编号</span><br></pre></td></tr></table></figure>

<h3 id="6-2-组会PPT演讲注意事项"><a href="#6-2-组会PPT演讲注意事项" class="headerlink" title="6.2 组会PPT演讲注意事项"></a>6.2 组会PPT演讲注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，要讲的内容先做好调研，为什么要研究这个，这个存在什么问题，挑战；</span><br><span class="line">目前有什么方法，这些方法的具体原理是什么，优缺点，最后再总结下。</span><br><span class="line"></span><br><span class="line">1.PPT本身</span><br><span class="line">  1）字体要大点，要让观众看得清（非常非常重要）</span><br><span class="line">  2）排版要整齐</span><br><span class="line">  3）公式用latex打出来</span><br><span class="line">  4）每页内容尽可能把页面填充满，不要留有太多空白区域</span><br><span class="line">2.演讲逻辑思路要清晰（非常非常重要）</span><br><span class="line">  举个栗子：一般分为以下4个步骤</span><br><span class="line">  1）任务定义（一句话概括）	</span><br><span class="line">  2）背景（存在什么问题，有什么难点，挑战，原因）</span><br><span class="line">  3）方法（一句话总体概括该方法（可以穿插该方法的来源），再讲述具体原理，接着举个通俗易懂的例子，最好画个图，这样观众更加容易理解）</span><br><span class="line">  4）总结方法的优点与缺点</span><br><span class="line">  PS：最好自己先打个演讲稿，私下演练至少3遍。</span><br></pre></td></tr></table></figure>

<h3 id="6-3-写论文等于开脑洞？"><a href="#6-3-写论文等于开脑洞？" class="headerlink" title="6.3 写论文等于开脑洞？"></a>6.3 写论文等于开脑洞？</h3><p><a href="https://www.youtube.com/watch?v=KAGm1ldMIPs">https://www.youtube.com/watch?v=KAGm1ldMIPs</a><br>一篇学术论文的诞生：从构思到发表</p>
<h3 id="6-4-如何看论文"><a href="#6-4-如何看论文" class="headerlink" title="6.4 如何看论文"></a>6.4 如何看论文</h3><p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A6%82%E4%BD%95%E7%9C%8B%E8%AE%BA%E6%96%87.png" alt="研究生如何看论文"></p>
<p><code>笔记例子</code></p>
<p><img src="/2021/12/26/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/image-20211226104343545.png" alt="image-20211226104343545"></p>
<h2 id="（七）找工作"><a href="#（七）找工作" class="headerlink" title="（七）找工作"></a>（七）找工作</h2><h3 id="7-1-刷题"><a href="#7-1-刷题" class="headerlink" title="7.1 刷题"></a>7.1 刷题</h3><h4 id="1-Leetcode-推荐刷题顺序"><a href="#1-Leetcode-推荐刷题顺序" class="headerlink" title="(1) Leetcode 推荐刷题顺序"></a><a href="https://www.bilibili.com/read/cv9904414">(1) Leetcode 推荐刷题顺序</a></h4><h4 id="2-代码随想录"><a href="#2-代码随想录" class="headerlink" title="(2) 代码随想录"></a><a href="https://programmercarl.com/">(2) 代码随想录</a></h4><h4 id="3-宫水三叶"><a href="#3-宫水三叶" class="headerlink" title="(3) 宫水三叶"></a><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/">(3) 宫水三叶</a></h4><h3 id="7-2-八股文"><a href="#7-2-八股文" class="headerlink" title="7.2 八股文"></a>7.2 八股文</h3><h4 id="1-CS-Notes"><a href="#1-CS-Notes" class="headerlink" title="(1) CS-Notes"></a><a href="https://github.com/CyC2018/CS-Notes">(1) CS-Notes</a></h4><h4 id="2-JavaGuide"><a href="#2-JavaGuide" class="headerlink" title="(2) JavaGuide"></a><a href="https://github.com/Snailclimb/JavaGuide">(2) JavaGuide</a></h4><h3 id="7-3-面经"><a href="#7-3-面经" class="headerlink" title="7.3 面经"></a>7.3 面经</h3><p><a href="https://www.nowcoder.com/discuss/576996">迟来的秋招总结，回馈牛油，已签约字节</a> 必看</p>
<p><a href="https://www.nowcoder.com/discuss/562887">2020年最新字节高频面试（Java岗）</a></p>
<p><a href="https://www.nowcoder.com/discuss/586326">神奇的3个月突击大厂后端上岸教程</a></p>
<p><a href="https://www.nowcoder.com/discuss/593392">来自一个菜鸟的Java后端面试经验总结</a></p>
<p><a href="https://www.nowcoder.com/discuss/67733">【干货】Java程序员面试考点大合集</a></p>
<p><a href="https://www.nowcoder.com/discuss/447742">Java 面试知识点【背诵版 240题 约7w字】</a></p>
<p><a href="https://www.nowcoder.com/discuss/586266">秋招总结,我是如何拿到两百万年薪offers</a></p>
<h3 id="7-4-JAVA技术路线"><a href="#7-4-JAVA技术路线" class="headerlink" title="7.4 JAVA技术路线"></a>7.4 JAVA技术路线</h3><p><a href="https://www.r2coding.com/#/">https://www.r2coding.com/#/</a></p>
<p><a href="https://github.com/liyupi/code-roadmap">https://github.com/liyupi/code-roadmap</a></p>
<h2 id="（八）兴趣爱好"><a href="#（八）兴趣爱好" class="headerlink" title="（八）兴趣爱好"></a>（八）兴趣爱好</h2><blockquote>
<p>用来对抗人生的荒谬</p>
</blockquote>
<h4 id="8-1-羽毛球"><a href="#8-1-羽毛球" class="headerlink" title="8.1 羽毛球"></a>8.1 羽毛球</h4><p><a href="https://www.bilibili.com/video/BV1tt41117wX">林丹 VS 李宗伟</a></p>
<h4 id="8-2-游泳"><a href="#8-2-游泳" class="headerlink" title="8.2 游泳"></a>8.2 游泳</h4><p><a href="https://www.bilibili.com/video/BV1bE411H7YM">孙杨</a></p>
<p><a href="https://space.bilibili.com/7283282">梦觉教游泳</a></p>
<h4 id="8-3-围棋"><a href="#8-3-围棋" class="headerlink" title="8.3 围棋"></a>8.3 围棋</h4><p><a href="https://www.youtube.com/watch?v=5kIQ0F8iN8U">柯洁 VS alphago</a></p>
<p><a href="https://www.youtube.com/channel/UCfGY9xUbDuSGWO-t5nIC33A">Yifei Hu</a></p>
<h4 id="8-4-跑步"><a href="#8-4-跑步" class="headerlink" title="8.4 跑步"></a>8.4 跑步</h4><h4 id="8-5-写博客"><a href="#8-5-写博客" class="headerlink" title="8.5 写博客"></a>8.5 写博客</h4><p><a href="https://blog.csdn.net/qq_36903042/article/details/82228883">搭建个人博客</a></p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>1.二叉树</title>
    <url>/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h1><span id="more"></span>

<h3 id="遍历系列"><a href="#遍历系列" class="headerlink" title="遍历系列"></a>遍历系列</h3><h4 id="二叉树遍历：迭代统一版本"><a href="#二叉树遍历：迭代统一版本" class="headerlink" title="二叉树遍历：迭代统一版本"></a>二叉树遍历：迭代统一版本</h4><p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈：访问逆序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node); <span class="comment">// 添加根节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 根节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>中序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br></pre></td></tr></table></figure>

<p><strong>前序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);   </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure>

<p><strong>后序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">pop</span>(); </span><br><span class="line">st.<span class="built_in">push</span>(node); </span><br><span class="line">st.<span class="built_in">push</span>(<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;left);  </span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;right);   </span><br></pre></td></tr></table></figure>

<h4 id="144-二叉树的前序遍历-🀄️"><a href="#144-二叉树的前序遍历-🀄️" class="headerlink" title="144. 二叉树的前序遍历 🀄️"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*前，中，后，主要看根在哪。</span></span><br><span class="line"><span class="comment">根左右</span></span><br><span class="line"><span class="comment">⚠️：当然有些可能是根右左</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左根右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左右根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LRN</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">LRN</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LRN</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BST用中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root) &#123;</span><br><span class="line">         <span class="built_in">LNR</span>(root,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= res.<span class="built_in">size</span>() ? <span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="102-二叉树的层序遍历-🀄️"><a href="#102-二叉树的层序遍历-🀄️" class="headerlink" title="102. 二叉树的层序遍历 🀄️"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树的层序遍历--广度优先搜索</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    首先根元素入队</span></span><br><span class="line"><span class="comment">    当队列不为空的时候</span></span><br><span class="line"><span class="comment">        求当前队列的长度 si</span></span><br><span class="line"><span class="comment">        依次从队列中取 si个元素进行拓展，然后进入下一次迭代</span></span><br><span class="line"><span class="comment">它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 si个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si 个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;        <span class="comment">//存储每一层的结点值</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;	<span class="comment">//注意🈳️树</span></span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">//树的队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);       <span class="comment">//根先进入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;  <span class="comment">//不为空</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());   <span class="comment">//先放入一个vector&lt;int&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();            <span class="comment">//取出队头，并删除队头</span></span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);        <span class="comment">//根结点值存入vector&lt;int&gt;</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)  q.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左结点不空,进入队列</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)  q.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右结点不空,进入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根结点的插入顺序不一样。</span></span><br><span class="line"><span class="comment">    如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。</span></span><br><span class="line"><span class="comment">    如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">//从左到右</span></span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(flag) res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);               <span class="comment">//插入到最后面</span></span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">back</span>().<span class="built_in">insert</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),node-&gt;val);   <span class="comment">//插入到最前面</span></span><br><span class="line">                   </span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：返回其节点值自底向上的层序遍历</span></span><br><span class="line"><span class="comment">思路：只需要将每次层序遍历的结点的容器插入到结果最前面就可以了，这样后面遍历的就变成前面的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">       queue&lt;TreeNode *&gt; q;</span><br><span class="line">       q.<span class="built_in">push</span>(root);</span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">           <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">           vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">               <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">               t.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">           &#125;</span><br><span class="line">           res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),t);   <span class="comment">//插入到最前面</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树的深度遍历和先根遍历基本上是一样的,只是先根遍历有左右之分,而深度遍历没有左右之分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路1:层序遍历，记录下每层的最后一个元素。</span></span><br><span class="line"><span class="comment">思路2:先序遍历(这里是根右左)，记录下每层的第一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s= q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == s - <span class="number">1</span>) res.<span class="built_in">push_back</span>(node-&gt;val);    <span class="comment">//⚠️保存最后一个</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/116_sample.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：用层序遍历，这样我们可以在遍历每一层的时候修改这一层节点的 next 指针，这样就可以把每一层都组织成链表。</span></span><br><span class="line"><span class="comment">（初始状态下，所有 next 指针都被设置为 NULL。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;      <span class="comment">//层序遍历</span></span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i &lt; s - <span class="number">1</span>) node-&gt;next = q.<span class="built_in">front</span>();  <span class="comment">//前面的指向后面，front()查询队头元素</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II-⭐️"><a href="#117-填充每个节点的下一个右侧节点指针-II-⭐️" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II ⭐️"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> ⭐️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/0dc6ed6ba29a12469f6254b1016c90608b852131939d03fd23d4bbd1aa0a9d78.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度O(1)</span></span><br><span class="line"><span class="comment">思路：使用已建立的 next 指针，cur 指针利用 next 不停的遍历当前层。</span></span><br><span class="line"><span class="comment">	1）如果 cur 的左右孩子不为 null 就将它接到 tail 后边，然后更新tail。</span></span><br><span class="line"><span class="comment">	2）当 cur 为 null 的时候，再利用 dummy 指针得到下一层的开始节点。</span></span><br><span class="line"><span class="comment">	遍历完每一层。就要将dummy-&gt;next赋值给cur</span></span><br><span class="line"><span class="comment">dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            Node* tail = dummy;  <span class="comment">//赋值给tail</span></span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) &#123;tail-&gt;next = cur-&gt;left;tail = tail-&gt;next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) &#123;tail-&gt;next = cur-&gt;right;tail= tail-&gt;next;&#125;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典中序</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同103</span><br></pre></td></tr></table></figure>



<h3 id="BST-中序遍历"><a href="#BST-中序遍历" class="headerlink" title="BST+中序遍历"></a>BST+中序遍历</h3><h4 id="98-验证二叉搜索树-⭐️"><a href="#98-验证二叉搜索树-⭐️" class="headerlink" title="98. 验证二叉搜索树 ⭐️"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a> ⭐️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉搜索树</span></span><br><span class="line"><span class="comment">1.左子树上所有结点的值均&lt;它的根结点的值。</span></span><br><span class="line"><span class="comment">2.右子树上所有结点的值均&gt;它的根结点的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">先序遍历</span></span><br><span class="line"><span class="comment">遍历时，不仅左结点小于根结点，根结点大于右结点。而是要整个左子树&lt;根&lt;右子树。此时需要保存子树的上界和下界。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。</span></span><br><span class="line"><span class="comment">同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> low,<span class="keyword">long</span> <span class="keyword">long</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">//本身空或者遍历完</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断根结点值(是否越界)，再遍历左子树，右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,low,root-&gt;val) &amp;&amp; <span class="built_in">check</span>(root-&gt;right,root-&gt;val,high); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root,LONG_MIN,LONG_MAX);<span class="comment">//要long long(32,64都是8字节) </span></span><br><span class="line">      																			 <span class="comment">//或者long(32位 4字节，64位8子节)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="99-恢复二叉搜索树-⭐️难"><a href="#99-恢复二叉搜索树-⭐️难" class="headerlink" title="99. 恢复二叉搜索树 ⭐️难"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a> ⭐️难</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/26e9f631ec22f42f50099cf4fd9a55510ad0e7b0a4a836c772b6850591ddb737-image.png" alt="image.png"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/fde85797d0aa3cee9f8a84f39e820aed269f6c45b8eaf4d0672489c08f98090b-4.png" alt="4.jpg"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20211119191906437.png" alt="image-20211119191906437"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3种解法：</span></span><br><span class="line"><span class="comment">1.先弄个vector容器。 再摘下“树”上的数据（中序遍历）。 然后vector排序。 再把vector容器里的数据挂在“树上”（中序遍历）。 </span></span><br><span class="line"><span class="comment">时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">2.只用比较前后访问的节点值，prev 保存上一个访问的节点，当前访问的是 root 节点。</span></span><br><span class="line"><span class="comment">每访问一个节点，如果prev.val&gt;=root.val，就找到了一对“错误对”。</span></span><br><span class="line"><span class="comment">检查一下它是第一对错误对，还是第二对错误对。</span></span><br><span class="line"><span class="comment">遍历结束，就确定了待交换的两个错误点，进行交换。</span></span><br><span class="line"><span class="comment">时间复杂度O(N)，N是节点个数</span></span><br><span class="line"><span class="comment">空间复杂度O(H)，递归栈的深度</span></span><br><span class="line"><span class="comment">3. Morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，Morris遍历可以将非递归遍历中的空间复杂度降为O(1)</span></span><br><span class="line"><span class="comment">Morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* err1=<span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* err2=<span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* prev=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 记录第一个错误点</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 == <span class="literal">nullptr</span>) err1 = prev;</span><br><span class="line">        <span class="comment">// 第一个错误点已确定,记录第二个错误点</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; root-&gt;val &amp;&amp; err1 != <span class="literal">nullptr</span>) err2 = root;</span><br><span class="line">        prev = root;    <span class="comment">//更新prev</span></span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LNR</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(err1-&gt;val,err2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *x = <span class="literal">nullptr</span>, *y = <span class="literal">nullptr</span>, *pred = <span class="literal">nullptr</span>, *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// (1)predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// (2)让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    predecessor-&gt;right = root; </span><br><span class="line">                    root = root-&gt;left;          <span class="comment">//访问左孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (3)说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//记录错误结点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                        x = root;</span><br><span class="line">                        <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                            y = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pred = root; <span class="comment">//更新pred</span></span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>; <span class="comment">//置为空</span></span><br><span class="line">                    root = root-&gt;right;           <span class="comment">//访问右孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录错误结点</span></span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pred-&gt;val) &#123;</span><br><span class="line">                    x = root;</span><br><span class="line">                    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        y = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pred = root;<span class="comment">//更新pred</span></span><br><span class="line">                root = root-&gt;right; <span class="comment">//直接访问右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val, y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思路：中序遍历完就是一个递增的序列，取出第k个元素就是第k小的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历(⚠️这里是右根左，由于是递归)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="285-二叉搜索树的后续结点"><a href="#285-二叉搜索树的后续结点" class="headerlink" title="285.二叉搜索树的后续结点"></a><a href="https://leetcode-cn.com/problems/inorder-successor-in-bst/">285.二叉搜索树的后续结点</a></h4><p>给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。</p>
<p>结点 p 的后继是值<strong>比 p.val 大</strong>的结点中<strong>键值最小</strong>的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果p比当前节点小，说明在左子树，res=root；否则去右子树搜索。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val) &#123;	</span><br><span class="line">                res = root;					<span class="comment">//在左子树的根（同时，键值最小，最左边）⚠️</span></span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="272-最接近的二叉搜索树值2"><a href="#272-最接近的二叉搜索树值2" class="headerlink" title="272.最接近的二叉搜索树值2"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/">272.最接近的二叉搜索树值2</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">先序遍历：pre暂存前面的结点，head</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *pre, *head;   <span class="comment">//pre暂存前面的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span>) pre-&gt;right = cur;    <span class="comment">//pre-&gt;r指向cur</span></span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur-&gt;left = pre;                        <span class="comment">//cur-&gt;l指向pre</span></span><br><span class="line">        pre = cur;  <span class="comment">//更新pre</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;   <span class="comment">//最后</span></span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//T,S:O(n^2) 根左右</span></span><br><span class="line"><span class="comment">思路：先序遍历，发现叶子结点就加入结果集中；没有就继续递归左右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode* root,string path,vector&lt;string&gt; &amp;res)</span></span>&#123; <span class="comment">//⚠️string类不加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">//叶子结点，加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//不是叶子结点，递归左右子树</span></span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;left,path,res);</span><br><span class="line">            <span class="built_in">getPath</span>(root-&gt;right,path,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">getPath</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270.最接近的二叉搜索树值"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">270.最接近的二叉搜索树值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="255-验证前序遍历序列二叉搜索树"><a href="#255-验证前序遍历序列二叉搜索树" class="headerlink" title="255.验证前序遍历序列二叉搜索树"></a><a href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/">255.验证前序遍历序列二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序遍历将二叉树取下来，再遍历一遍变成链表</span></span><br><span class="line"><span class="comment">⚠️：左孩子为空，右孩子赋值当前结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="built_in">NLR</span>(root,res);</span><br><span class="line">        <span class="keyword">int</span> s =res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s;i++)&#123;</span><br><span class="line">            TreeNode* prev = res[i<span class="number">-1</span>],*cur = res[i];</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;   <span class="comment">//前驱结点为空</span></span><br><span class="line">            prev-&gt;right = cur;      <span class="comment">//前驱结点的右结点为当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NLR</span><span class="params">(TreeNode* root,vector&lt;TreeNode*&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">NLR</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156.上下翻转二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-upside-down/">156.上下翻转二叉树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4><h4 id="297-二叉树的序列化与反序列化-⭐️难"><a href="#297-二叉树的序列化与反序列化-⭐️难" class="headerlink" title="297. 二叉树的序列化与反序列化 ⭐️难"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a> ⭐️难</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//后序遍历，单调栈</span><br><span class="line">//T,S:O(n)</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="计算个数，通过界定-1-n-求解"><a href="#计算个数，通过界定-1-n-求解" class="headerlink" title="计算个数，通过界定(1,n)求解"></a>计算个数，通过界定(1,n)求解</h3><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">如果我们枚举根节点的值为 i，</span></span><br><span class="line"><span class="comment">那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]</span></span><br><span class="line"><span class="comment">再枚举左，右子树，挂到根结点上，将根结点加入到结果集中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st &gt; ed) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;<span class="comment">//&#123;nullptr&#125; 长度为1，&#123;&#125;长度为0</span></span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=st;i &lt;= ed; i++)&#123;</span><br><span class="line">            <span class="comment">//获得所有可行的左子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; lTrees = <span class="built_in">generateTrees</span>(st,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//获得所有可行的右子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rTrees = <span class="built_in">generateTrees</span>(i+<span class="number">1</span>,ed);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; l:lTrees)&#123;    <span class="comment">//枚举左，右子树，挂到根结点上</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; r:rTrees)&#123;</span><br><span class="line">                    TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);  <span class="comment">//根结点</span></span><br><span class="line">                    allTrees.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    cur-&gt;left = l;</span><br><span class="line">                    cur-&gt;right = r;         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="先左右后自己"><a href="#先左右后自己" class="headerlink" title="先左右后自己"></a>先左右后自己</h3><h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306160658602.png" alt="image-20210306160658602"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306161232086.png" alt="image-20210306161232086"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</span></span><br><span class="line"><span class="comment">卡特兰数G(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:,</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += <span class="built_in">numTrees</span>(i - <span class="number">1</span>) * <span class="built_in">numTrees</span>(n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和-🀄️"><a href="#124-二叉树中的最大路径和-🀄️" class="headerlink" title="124. 二叉树中的最大路径和 🀄️"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 🀄️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095058804.png" alt="image-20210308095058804"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">题意：给你一个二叉树的根节点 root ，返回其最大路径和</span></span><br><span class="line"><span class="comment">思路：考虑一个二叉树单元：有3种情况：a+b+c,a+b,a+c</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  b   c</span></span><br><span class="line"><span class="comment">递归左右子树，更新3种情况的最大和，返回较大值a+max(b,+c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;left),<span class="number">0</span>); <span class="comment">//子问题:取max，如果结点负数就取0</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxSum</span>(root-&gt;right),<span class="number">0</span>);<span class="comment">//子问题</span></span><br><span class="line">        res = <span class="built_in">max</span>(res,l + r + root-&gt;val);	<span class="comment">//额外：人字形答案</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l,r);	<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果root等于q或者p，或者NULL，直接返回root</span></span><br><span class="line"><span class="comment">递归左子树</span></span><br><span class="line"><span class="comment">递归右子树</span></span><br><span class="line"><span class="comment">左结点，右结点都不为空，返回root（最终答案）</span></span><br><span class="line"><span class="comment">返回 左结点或者右结点，哪个不空返回哪个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span> &amp;&amp; r != <span class="literal">NULL</span>) <span class="keyword">return</span> root;	<span class="comment">//左右子树不空</span></span><br><span class="line">        <span class="keyword">return</span> l!=<span class="literal">NULL</span>?l:r;	<span class="comment">//哪个不空，返回哪个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="250-统计同值子树"><a href="#250-统计同值子树" class="headerlink" title="250.统计同值子树"></a><a href="https://leetcode-cn.com/problems/count-univalue-subtrees/">250.统计同值子树</a></h4><p>给定一个二叉树，统计该二叉树数值相同的子树个数。</p>
<p>同值子树是指该子树的所有节点都拥有相同的数值。</p>
<p>示例：</p>
<p>输入: root = [5,1,5,5,5,null,5]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   5</span><br><span class="line"> / \   \</span><br><span class="line">5   5   5</span><br></pre></td></tr></table></figure>

<p>输出: 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="333-最大BST子树"><a href="#333-最大BST子树" class="headerlink" title="333.最大BST子树"></a><a href="https://leetcode-cn.com/problems/largest-bst-subtree/">333.最大BST子树</a></h4><p>给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="先自己后左右"><a href="#先自己后左右" class="headerlink" title="先自己后左右"></a>先自己后左右</h3><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.如果两个二叉树都为空，则两个二叉树相同。</span></span><br><span class="line"><span class="comment">2.如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，</span></span><br><span class="line"><span class="comment">4.若不相同则两个二叉树一定不同，若相同，</span></span><br><span class="line"><span class="comment">  再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</span></span><br><span class="line"><span class="comment">  这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;      <span class="comment">//都为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//1个为空，1个不空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( p-&gt;val != q-&gt;val)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;   <span class="comment">//值不相等</span></span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);&#125; <span class="comment">//值相等，递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h4 id="剑指-Offer-55-I-二叉树的深度-同上"><a href="#剑指-Offer-55-I-二叉树的深度-同上" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度 同上"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a> 同上</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095241593.png" alt="image-20210308095241593"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  从下往上：后序遍历。</span></span><br><span class="line"><span class="comment">思路：如果为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+max（左子树的深度，右子树的深度）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));	<span class="comment">//根结点+左右子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的结点数"><a href="#获取二叉树的结点数" class="headerlink" title="获取二叉树的结点数"></a>获取二叉树的结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：为空，直接返回0</span></span><br><span class="line"><span class="comment">返回 递归1+左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAllNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">getAllNode</span>(root-&gt;left)+<span class="built_in">getAllNode</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取二叉树的叶子结点数"><a href="#获取二叉树的叶子结点数" class="headerlink" title="获取二叉树的叶子结点数"></a>获取二叉树的叶子结点数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：如果根结点为空，直接返回0</span></span><br><span class="line"><span class="comment">如果左结点和右结点同时为空，直接返回1</span></span><br><span class="line"><span class="comment">返回 递归左子树+右子树的结点数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leafCount</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">leafCount</span>(root-&gt;left)+<span class="built_in">leafCount</span>(root-&gt;right);<span class="comment">//不包含根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="某结点是否在二叉树中"><a href="#某结点是否在二叉树中" class="headerlink" title="某结点是否在二叉树中"></a>某结点是否在二叉树中</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isExist</span><span class="params">(TreeNode* root,TreeNode* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val == p-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//根</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isExist</span>(root-&gt;left,p)) <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//左</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isExist</span>(root-&gt;right,p);			<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><h4 id="105-从前序与中序遍历序列构造二叉树-🀄️"><a href="#105-从前序与中序遍历序列构造二叉树-🀄️" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 🀄️"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210306175110221.png" alt="image-20210306175110221"></p>
<p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306175018888.png" alt="image-20210306175018888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：先序的第一个就是根结点，取出来；</span></span><br><span class="line"><span class="comment">再查找根结点在中序中的位置；</span></span><br><span class="line"><span class="comment">然后递归寻找前序和中序的左区间，右区间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;    <span class="comment">//超出范围</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preL];           <span class="comment">//先序遍历的第一个是根，取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];              <span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);  <span class="comment">//new根结点</span></span><br><span class="line">        <span class="comment">//前序，中序的左区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(preorder,preL+<span class="number">1</span>,pIndex-inL+preL,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//前序，中序的右区间</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(preorder,pIndex-inL+preL+<span class="number">1</span>,preR,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = preorder.<span class="built_in">size</span>();   <span class="comment">//前序结点数</span></span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();     <span class="comment">//中序结点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; inLen; i++) map.<span class="built_in">insert</span>(&#123;inorder[i],i&#125;);   <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(preorder,<span class="number">0</span>,preLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210306194848625.png" alt="image-20210306194848625"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同105相同的思路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> postL,<span class="keyword">int</span> postR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postL &gt; postR || inL &gt;inR) <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postR];	<span class="comment">//取出根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = map[rootVal];	<span class="comment">//查询根在中序序列中的位置</span></span><br><span class="line">      	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);	<span class="comment">//new根结点</span></span><br><span class="line">				<span class="comment">//前序，后序的左区间  以及 //前序，后序的右区间 </span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(postorder,postL,postL+pIndex-inL<span class="number">-1</span>,inL,pIndex<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(postorder,postL+pIndex-inL,postR<span class="number">-1</span>,pIndex+<span class="number">1</span>,inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.<span class="built_in">size</span>();		<span class="comment">//后序结点数</span></span><br><span class="line">        <span class="keyword">int</span> postLen = postorder.<span class="built_in">size</span>();		<span class="comment">//前序结点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++) map.<span class="built_in">insert</span>(&#123;inorder[i],i&#125;); <span class="comment">//哈希先存储中序，查询的时候快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(postorder,<span class="number">0</span>,postLen<span class="number">-1</span>,<span class="number">0</span>,inLen<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h4><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：同109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(nums,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="109-有序链表转换二叉搜索树-🀄️"><a href="#109-有序链表转换二叉搜索树-🀄️" class="headerlink" title="109. 有序链表转换二叉搜索树 🀄️"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：将有序数组转换为二叉搜索树,并且高度平衡</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">构造出的二叉搜索树的中序遍历结果就是链表本身，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。</span></span><br><span class="line"><span class="comment">	中位数节点对应的编号为 mid=left+(right-left)/2+1；</span></span><br><span class="line"><span class="comment">	左右子树对应的编号范围分别为 [left,mid−1] 和 [mid+1,right]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组下标0,1,2,3,4 区别 </span></span><br><span class="line"><span class="comment">(r+l+1)/2			(1)	2 1 0 4 3	区间右边优先</span></span><br><span class="line"><span class="comment">l+(r-l)/2			(2)	2 0 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">while</span>(head)&#123;head = head-&gt;next;len++;&#125;</span><br><span class="line">        	<span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode*  <span class="title">buildTree</span><span class="params">(ListNode* &amp;head,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//⚠️记得head加&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (r+l+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;                    <span class="comment">//⚠️中间结点为根结点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();        <span class="comment">//根结点</span></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(head,l,mid<span class="number">-1</span>);   <span class="comment">//递归左子树</span></span><br><span class="line">        root-&gt;val = head-&gt;val;                  <span class="comment">//⚠️中序必须这里赋值给根结点</span></span><br><span class="line">        head = head-&gt;next;                      <span class="comment">//⚠️注意更新head</span></span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(head,mid+<span class="number">1</span>,r);  <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">getLength</span>(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自顶向下：T:O(n^2)</span></span><br><span class="line"><span class="comment">自底向上：T:O（n^2）</span></span><br><span class="line"><span class="comment">思路：后序遍历：先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//符合</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span> || r == <span class="number">-1</span> || <span class="built_in">abs</span>(r-l) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不符合</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题意：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">找出2个原始状态：为空直接返回0；左右结点为空，返回1；</span></span><br><span class="line"><span class="comment">再递归左子树，右子树的最小深度，取较小的+1就是答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) res=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right),res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(H) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4><h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum,vector&lt;<span class="keyword">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum,path);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum,path);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum,vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="comment">2.前缀和：T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetSum == root-&gt;val) res++;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum);    <span class="comment">//先递归根结点到叶子结点的路径；再递归子树的路径</span></span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110. 删点成林"></a><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(n) S:O(H+N)</span></span><br><span class="line"><span class="comment">思路：先序遍历：如果 node 是root 而且没有被删除，则加入答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; to_delete_set;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : to_delete) <span class="comment">//1.存入set</span></span><br><span class="line">            to_delete_set.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="built_in">helper</span>(root, result, to_delete_set, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, vector&lt;TreeNode*&gt;&amp; result, set&lt;<span class="keyword">int</span>&gt;&amp; to_delete_set, <span class="keyword">bool</span> is_root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> deleted = to_delete_set.<span class="built_in">count</span>(node-&gt;val);    <span class="comment">//2.判断是否删除</span></span><br><span class="line">        <span class="keyword">if</span> (is_root &amp;&amp; !deleted) result.<span class="built_in">push_back</span>(node);    <span class="comment">//是根结点且不删除</span></span><br><span class="line">        node-&gt;left = <span class="built_in">helper</span>(node-&gt;left, result, to_delete_set, deleted);</span><br><span class="line">        node-&gt;right =  <span class="built_in">helper</span>(node-&gt;right, result, to_delete_set, deleted);</span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="literal">NULL</span> : node;  <span class="comment">//3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="129-求根到叶子节点数字之和-🀄️"><a href="#129-求根到叶子节点数字之和-🀄️" class="headerlink" title="129. 求根到叶子节点数字之和 🀄️"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a> 🀄️</h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210308095648125.png" alt="image-20210308095648125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*从上到下:先序遍历</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_sum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;<span class="comment">//base case 根结点</span></span><br><span class="line">        num = root-&gt;val+num*<span class="number">10</span>;     </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) res += num; <span class="comment">//base case 叶结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">get_sum</span>(root-&gt;left,num);     <span class="comment">//子问题</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">get_sum</span>(root-&gt;right,num);   <span class="comment">//子问题</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">get_sum</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T：O(log⁡2n) S:O(1)</span></span><br><span class="line"><span class="comment">思路：二分查找 + 位运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><blockquote>
<p>Q： 为何需要暂存 root的左子节点？<br>A： 在递归右子节点 “root.left=mirrorTree(root.right);” 执行完毕后， root.left的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T，S：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p><img src="/2021/01/02/1.%E4%BA%8C%E5%8F%89%E6%A0%91/image-20210722224510100.png" alt="image-20210722224510100"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="298-二叉树最长连续序列"><a href="#298-二叉树最长连续序列" class="headerlink" title="298.二叉树最长连续序列"></a><a href="https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence/">298.二叉树最长连续序列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历：自顶向下：T,S:O(n)</span></span><br><span class="line"><span class="comment">//先递归根结点length =(parent != null &amp;&amp; p.val == parent.val + 1)? length + 1 : 1;再递归左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root, null, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode p, TreeNode parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == null) <span class="keyword">return</span> length;</span><br><span class="line">    length = (parent != null &amp;&amp; p.val == parent.val + <span class="number">1</span>) ? length + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(length, Math.<span class="built_in">max</span>(<span class="built_in">dfs</span>(p.left, p, length),</span><br><span class="line">                                     <span class="built_in">dfs</span>(p.right, p, length)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="366-寻找二叉树的叶子结点"><a href="#366-寻找二叉树的叶子结点" class="headerlink" title="366.寻找二叉树的叶子结点"></a><a href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">366.寻找二叉树的叶子结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="comment">//思路：后序遍历，深度从底向上算,叶子结点的深度为0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//depth从0开始</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//返回-1,从0开始</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= res.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findLeaves</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(s*t) S:O(max&#123;s,t&#125;)  树的深度s，t</span></span><br><span class="line"><span class="comment">//思路：转化为检查根结点，左右子树是否相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(!root &amp;&amp; !subRoot) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;left,subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：先序遍历：res+=左子树的左叶子结点的val</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">NLR</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* l = <span class="built_in">NLR</span>(root-&gt;left);</span><br><span class="line">        TreeNode* r = <span class="built_in">NLR</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; l-&gt;left == <span class="literal">nullptr</span> &amp;&amp; l-&gt;right ==<span class="literal">nullptr</span>) res+=l-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">NLR</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*层次遍历：每次保存第一个值 res=cur</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">538. 把二叉搜索树转换为累加树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*思路：反序中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">RNL</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">RNL</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RNL</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(n)</span></span><br><span class="line"><span class="comment">思路：中序遍历，pre，res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LNR</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;res,<span class="keyword">int</span> &amp;pre)</span></span>&#123;<span class="comment">//⚠️引用</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;left,res,pre);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="number">-1</span>)&#123;</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res,root-&gt;val-pre);</span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LNR</span>(root-&gt;right,res,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX,pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">LNR</span>(root,res,pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*中序遍历：dummyNode，中间改变指向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *resNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;left);</span><br><span class="line">        resNode-&gt;right = node;</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        resNode = node;     <span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">increasingBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        TreeNode *dummyNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        resNode = dummyNode;    <span class="comment">//dummyNode暂存头指针</span></span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈希表 set.count(target-root-&gt;val)</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; my_set;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(TreeNode* root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(my_set.<span class="built_in">count</span>(k-root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        my_set.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root-&gt;left,k) || <span class="built_in">find</span>(root-&gt;right,k);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p><img src="/Users/zcz/Desktop/images/image-20211125195244554.png" alt="image-20211125195244554"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：1.key&gt;root.val，删除右子树2.&lt;删除左子树 3.相等，root为叶子结点，有右结点，只有左结点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//中序遍历序列的下一个节点。即比当前节点大的最小节点（后续结点）</span></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left != <span class="literal">nullptr</span>) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//中序遍历序列的前一个节点。即比当前节点小的最大节点（前续结点）</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;right != <span class="literal">nullptr</span>) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">successor</span>(root);</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;val = <span class="built_in">predecessor</span>(root);</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*转化为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;  <span class="comment">//是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(subRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">if</span>((!root &amp;&amp; subRoot) || (root&amp;&amp;!subRoot) || root-&gt;val != subRoot-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="built_in">isSame</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || subRoot == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//⚠️</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;left,subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.递归：逻辑&amp;&amp;   T,S:O(n)</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));<span class="comment">//A &amp;&amp; B,A为false时，则不执行B</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">617.合并二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(min⁡(m,n))</span></span><br><span class="line"><span class="comment">思路：先序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        merged-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        merged-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree">654.最大二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*先序遍历：每次取最大值作为根结点</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 寻找最大值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), mid)</span></span>;           <span class="comment">// 构建左/右部分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(mid + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(*mid);        <span class="comment">// 递归的优美</span></span><br><span class="line">        root -&gt; left = <span class="built_in">constructMaximumBinaryTree</span>(l);</span><br><span class="line">        root -&gt; right = <span class="built_in">constructMaximumBinaryTree</span>(r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="655-输出二叉树"><a href="#655-输出二叉树" class="headerlink" title="655.输出二叉树"></a><a href="https://leetcode-cn.com/problems/print-binary-tree">655.输出二叉树</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T,S:O(h∗2^h)  h树的高度</span></span><br><span class="line"><span class="comment">思路：先序遍历+二分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">printTree</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">2</span>, m) <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 二维vector一致填充好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fill</span>(root, <span class="number">0</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        res[depth][mid] = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;left, depth+<span class="number">1</span>, begin, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(root-&gt;right, depth+<span class="number">1</span>, mid+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>2.DFS/BFS+回溯</title>
    <url>/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="2-DFS-BFS-回溯"><a href="#2-DFS-BFS-回溯" class="headerlink" title="2.DFS/BFS+回溯"></a>2.DFS/BFS+回溯</h1><span id="more"></span>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">模板</span><br><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line">def <span class="built_in">backtrack</span>(未探索区域, res, path):</span><br><span class="line">    <span class="keyword">if</span> 未探索区域满足结束条件:</span><br><span class="line">        res.<span class="built_in">add</span>(path) # 深度拷贝</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 未探索区域当前可能的选择:</span><br><span class="line">        <span class="keyword">if</span> 当前选择符合要求:</span><br><span class="line">            path.<span class="built_in">add</span>(作出选择)</span><br><span class="line">            <span class="built_in">backtrack</span>(新的未探索区域, res, path)</span><br><span class="line">            path.<span class="built_in">pop</span>() 撤销选择</span><br></pre></td></tr></table></figure>

<h4 id="131-分割回文串-🀄️"><a href="#131-分割回文串-🀄️" class="headerlink" title="131. 分割回文串 🀄️"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(N∗2^N)  S:O(2^N)</span></span><br><span class="line"><span class="comment">思路：经典回溯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backTrack</span>(s,res,&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(string s,vector&lt;vector&lt;string&gt;&gt; &amp;res,vector&lt;string&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;              <span class="comment">//空串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);        <span class="comment">//直接加入结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;       <span class="comment">//1.遍历所有可能,从1开始</span></span><br><span class="line">            string pre=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);       <span class="comment">//当前子串  没有取到i</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(pre))&#123;                 <span class="comment">//2.满足</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(pre);        <span class="comment">//3.作出选择 加入</span></span><br><span class="line">                <span class="built_in">backTrack</span>(s.<span class="built_in">substr</span>(i),res,path);    <span class="comment">//4.递归 前面的i-1已经匹配，现从i取到结尾</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();        <span class="comment">//5.回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">0</span>,ed=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st &lt;= ed)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[st] != s[ed]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st++;ed--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">backTrace</span>(candidates, i, len, target - candidates[i]);<span class="comment">//递归,i⚠️当前数可以重复选择</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment">//T:O(S) S可行解的长度  S:O(target)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> x,<span class="keyword">int</span> len,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;res.<span class="built_in">emplace_back</span>(output);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;x &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;	<span class="comment">//剪枝</span></span><br><span class="line">            output.<span class="built_in">emplace_back</span>(candidates[i]);             <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i+<span class="number">1</span>, len, target - candidates[i]);<span class="comment">//递归，i+1</span></span><br><span class="line">            output.<span class="built_in">pop_back</span>();                              <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());	<span class="comment">//为了去重</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates,<span class="number">0</span>,len,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211126202127765.png" alt="image-20211126202127765"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> k,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target &amp;&amp; output.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=(<span class="number">9</span> &gt; (target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>)?(target-sum-(k-output.<span class="built_in">size</span>()<span class="number">-1</span>)*(k-output.<span class="built_in">size</span>())/<span class="number">2</span>):<span class="number">9</span>);i++)&#123; <span class="comment">//剪枝</span></span><br><span class="line">            sum += i;</span><br><span class="line">            output.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,sum,k,target);</span><br><span class="line">            output.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">1</span>,<span class="number">0</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*2^n) S:O(n) </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;len;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backTrace</span>(i+<span class="number">1</span>,len,nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,len,nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原集合nums包含重复元素</span></span><br><span class="line"><span class="comment">//T:O(n*2^n) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;nums,vector&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//剪枝，去重⚠️</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);<span class="comment">//做出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,path,i+<span class="number">1</span>);<span class="comment">//递归进入下一层，注意i+1，标识下一个选择列表的开始位置，最重要的一步</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());  <span class="comment">//为了去重⚠️</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums不重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;	<span class="comment">//⚠️从0开始固定长度len</span></span><br><span class="line">            <span class="keyword">if</span> (vis[i]) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//⚠️递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//nums重复数字  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> len,vector&lt;<span class="keyword">int</span>&gt; &amp;perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//没有访问过 不重复</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums,x+<span class="number">1</span>,len,perm);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),perm);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n*n!) S:O(n)</span></span><br><span class="line"><span class="comment">//s有重复 同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(string &amp;s,<span class="keyword">int</span> x,<span class="keyword">int</span> len,string &amp;path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;<span class="comment">//不重复／没有访问过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(s[i]);<span class="comment">//作出选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(s,x+<span class="number">1</span>,len,path);  <span class="comment">//递归</span></span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>(),path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A-Z 65-90 a-z 97-122  0-9 48-57</span></span><br><span class="line"><span class="comment">//搜索 T,S:O(N*2^N)   N字符串长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> x,string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[x]))&#123;	<span class="comment">//数字直接回溯</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[x] = <span class="built_in">tolower</span>(s[x]);	<span class="comment">//回溯小写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">            s[x] = <span class="built_in">toupper</span>(s[x]);<span class="comment">//回溯大写</span></span><br><span class="line">            <span class="built_in">backTrace</span>(x+<span class="number">1</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归全排列</span></span><br><span class="line"><span class="comment">//T：O(10^n) S:O(10^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">char</span> NUM[<span class="number">10</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成长度为 len 的数字，正在确定第x位（从左往右）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == len) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = x==<span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// X=0表示左边第一位数字，不能为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(NUM[i]); <span class="comment">// 确定本位数字</span></span><br><span class="line">            <span class="built_in">backtrack</span>(x+<span class="number">1</span>, len); <span class="comment">// 确定下一位数字</span></span><br><span class="line">            cur.<span class="built_in">pop_back</span>(); <span class="comment">// 删除本位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 数字长度：1~n</span></span><br><span class="line">            <span class="built_in">backtrack</span>(<span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_int;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res_int.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(res[i]));</span><br><span class="line">        <span class="keyword">return</span> res_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="comment">//使用哈希表存储字符串 s 的每个下标和从该下标开始的部分可以组成的句子列表，</span></span><br><span class="line"><span class="comment">//在回溯过程中如果遇到已经访问过的下标，则可以直接从哈希表得到结果，而不需要重复计算。</span></span><br><span class="line"><span class="comment">//T,S:O(n*2^n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; res;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;  <span class="comment">//哈希表，加快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        wordSet = <span class="built_in">unordered_set</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">count</span>(x)) &#123;        <span class="comment">//没有存过，进入</span></span><br><span class="line">            <span class="keyword">if</span> (x == s.<span class="built_in">size</span>()) &#123;    </span><br><span class="line">                res[x] = &#123;<span class="string">&quot;&quot;</span>&#125;;      <span class="comment">//字符串末尾</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[x] = &#123;&#125;;</span><br><span class="line">          <span class="comment">//由于substr，因此i &lt;= s.size()⚠️</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(x, i - x);   <span class="comment">//从x开始，截取i-x个</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">count</span>(word)) &#123;  <span class="comment">//当前词是否在词典中</span></span><br><span class="line">                    <span class="built_in">backtrack</span>(s, i);        <span class="comment">//i可重复</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; succ: res[i]) &#123;</span><br><span class="line">                        res[x].<span class="built_in">push_back</span>(succ.<span class="built_in">empty</span>() ? word : word + <span class="string">&quot; &quot;</span> + succ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="267-回文排列-II"><a href="#267-回文排列-II" class="headerlink" title="267.回文排列  II"></a><a href="https://leetcode-cn.com/problems/palindrome-permutation-ii/">267.回文排列  II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><a href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hours[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  <span class="comment">//从10个选num个</span></span><br><span class="line">    <span class="keyword">int</span> mins[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x,<span class="keyword">int</span> h,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h &gt; <span class="number">11</span> | m &gt;<span class="number">59</span>) <span class="keyword">return</span>;  <span class="comment">//不符合</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;   <span class="comment">//没有指示灯了</span></span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">6</span>];    <span class="comment">//注意这里要字符数组，不能是 string</span></span><br><span class="line">            <span class="built_in">sprintf</span>(tmp,<span class="string">&quot;%d:%02d&quot;</span>,h,m);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">backTrace</span>(num<span class="number">-1</span>,i+<span class="number">1</span>,h+hours[i],m+mins[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(num,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="200-岛屿数量-🀄️"><a href="#200-岛屿数量-🀄️" class="headerlink" title="200. 岛屿数量 🀄️"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">思路：遍历整个地图的1，记得遍历过的1赋值为0，这样就不会重复访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;    <span class="comment">//4个方向</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)  <span class="comment">//遍历所有点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;  <span class="comment">//符合条件：dfs</span></span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= row|| j&lt;<span class="number">0</span> ||j &gt;= col || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;       <span class="comment">//遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;				<span class="comment">//遍历4个方向</span></span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j+ d[<span class="number">1</span>];	</span><br><span class="line">            <span class="built_in">dfs</span>(grid,x,y);			 <span class="comment">//没有越界 dfs</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(ROW*COl)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.<span class="built_in">size</span>() || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() ||grid[i][j] != <span class="number">1</span>)<span class="comment">//提前返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;	<span class="comment">//当前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            res += <span class="built_in">dfs</span>(grid,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(grid,i,j)); <span class="comment">//取最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS. T,S:O(nm)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] =&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//遍历过了</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;   </span><br><span class="line">            <span class="keyword">int</span> x=d[<span class="number">0</span>]+i,y=d[<span class="number">1</span>]+j;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid,x,y);   <span class="comment">//不用再判断 grid[i][j] == 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res += <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                  	<span class="comment">//res = max(res, dfs(grid,i,j));最大周长</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211212102721764.png" alt="image-20211212102721764"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*直接深搜：T：O(n^4)，超时</span></span><br><span class="line"><span class="comment">对于每个 0，将它变成 1，然后做一次深度优先搜索计算出连通块的大小。答案就是找到的最大连通块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以通过记录连通块编号来解决这个问题，不同的连通块编号不同。这样，我们就可以累加不同编号的连通块面积和。</span></span><br><span class="line"><span class="comment">T,S：O(n^2)，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图的连通数,T:O(n^2),S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="keyword">int</span>&gt; &amp;visited,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">      	visited[i] = <span class="literal">true</span>;		<span class="comment">//标记当前结点遍历过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;   <span class="comment">//遍历下一个j</span></span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;<span class="comment">//当前是1，并且没有访问过</span></span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">//遍历i</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;    <span class="comment">//注意没有访问过</span></span><br><span class="line">              	res++;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected,visited,n,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/">841. 钥匙和房间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n+m) S:O(n)  n 是房间的数量，m 是所有房间中的钥匙数量的总数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">bool</span>&gt; &amp;visited,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[x]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x] = <span class="literal">true</span>;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:rooms[x])&#123; <span class="comment">//遍历当前room[x]的所有钥匙</span></span><br><span class="line">            <span class="built_in">dfs</span>(visited,rooms,it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(visited,rooms,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="comment">//向下，右遍历：si，sj i，j各自的和。</span></span><br><span class="line"><span class="comment">//si等于9时,递归si+1，此时si=10,和为1，因此si-8=1，和也为1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, visited, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj, visited, m, n, k) +</span><br><span class="line">                   <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>, visited, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929200631155.png" alt="image-20210929200631155"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(m*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;	<span class="comment">//遍历过的赋值</span></span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=x+d[<span class="number">0</span>],ty=y+d[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(board,tx,ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">dfs</span>(board,i,<span class="number">0</span>),<span class="built_in">dfs</span>(board, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) <span class="built_in">dfs</span>(board, <span class="number">0</span>, i),<span class="built_in">dfs</span>(board, n - <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">//标志了，恢复了O</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆流而上。T，S：O(m*n)</span></span><br><span class="line"><span class="comment">//对于一个点它能流动两边的大洋，那么反过来，两边大洋的水反着流就能达到这个点。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; P, A, ans;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        n = M.<span class="built_in">size</span>(), m = M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        P = A = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//左右两边加上下两边出发深搜 ⚠️</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">dfs</span>(M, P, i, <span class="number">0</span>), <span class="built_in">dfs</span>(M, A, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">dfs</span>(M, P, <span class="number">0</span>, j), <span class="built_in">dfs</span>(M, A, n - <span class="number">1</span>, j);             </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i][j] &amp;&amp; A[i][j]) ans.<span class="built_in">push_back</span>(&#123;i,j&#125;); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i+d[<span class="number">0</span>],y=j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt;<span class="number">0</span> || y&gt;=m || M[x][y] &lt; M[i][j]) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(M, visited, x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment">欧拉路径：能否不走重复的路而遍历一个图的所有边。</span></span><br><span class="line"><span class="comment">Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</span></span><br><span class="line"><span class="comment">  从起点出发，进行深度优先搜索。</span></span><br><span class="line"><span class="comment">  每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</span></span><br><span class="line"><span class="comment">  如果没有可移动的路径，则将所在节点加入到栈中，并返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,priority_queue&lt;string,vector&lt;string&gt;,greater&lt;string&gt;&gt;&gt; map;    <span class="comment">//哈希表&lt;string,小根堆&gt;</span></span><br><span class="line">    vector&lt;string&gt; res;     <span class="comment">//结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">count</span>(cur) &amp;&amp; map[cur].<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;    <span class="comment">//遍历当前结点的所有下一个结点</span></span><br><span class="line">            string tmp = map[cur].<span class="built_in">top</span>();    <span class="comment">//取出下一个结点</span></span><br><span class="line">            map[cur].<span class="built_in">pop</span>();                 <span class="comment">//删除</span></span><br><span class="line">            <span class="built_in">dfs</span>(tmp);                       <span class="comment">//以下一个结点：dfs</span></span><br><span class="line">        &#125; </span><br><span class="line">        res.<span class="built_in">emplace_back</span>(cur);              <span class="comment">//将当前结点加入结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tk:tickets) map[tk[<span class="number">0</span>]].<span class="built_in">push</span>(tk[<span class="number">1</span>]); <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());	<span class="comment">//由于递归，结果集需要反转</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929190037482.png" alt="image-20210929190037482"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*T:O(m+n) S:O(n)</span></span><br><span class="line"><span class="comment">二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。(转化为图着色问题：连接的2点着色不同)</span></span><br><span class="line"><span class="comment">输入：graph = [[1,3],[0,2],[1,3],[0,2]]</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment">解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="keyword">int</span>&gt;&amp; color)</span> </span>&#123;</span><br><span class="line">        color[node] = c;<span class="comment">//u</span></span><br><span class="line">        <span class="keyword">int</span> next = (c == RED ? GREEN : RED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor: graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[neighbor] == UNCOLORED) &#123;  <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(neighbor, next, graph,color);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;   <span class="comment">//提前退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (color[neighbor] != next) &#123; <span class="comment">//当前节点不是设定好next</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(n,UNCOLORED)</span></span>;</span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == UNCOLORED) &#123;    <span class="comment">//未染色</span></span><br><span class="line">                <span class="built_in">dfs</span>(i, RED, graph,color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="60-排列序列-第k个排列"><a href="#60-排列序列-第k个排列" class="headerlink" title="60. 排列序列 第k个排列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a> 第k个排列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N^2) S:O(N) </span></span><br><span class="line"><span class="comment">//思路：剪枝（已访问，k&gt;叶子结点数）+DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = f[n<span class="number">-1</span>-x]; <span class="comment">//叶子结点个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;    <span class="comment">//（1）剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; cnt) &#123; k -= cnt;<span class="keyword">continue</span>;&#125;   <span class="comment">//（2）剪枝</span></span><br><span class="line">            res += <span class="built_in">to_string</span>(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(n,k,x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不回溯，没有回头的过程</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//后面的数没有必要遍历去尝试了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vis = vector&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>);</span><br><span class="line">        f = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i] = f[i<span class="number">-1</span>]*i;</span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="254-因子的组合"><a href="#254-因子的组合" class="headerlink" title="254.因子的组合"></a><a href="https://leetcode-cn.com/problems/factor-combinations/">254.因子的组合</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211211110937828.png" alt="image-20211211110937828"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS+剪枝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dfs</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">sqrt</span>(n));         <span class="comment">//(1)剪枝点，遍历终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;           </span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;i,n/i&#125;);</span><br><span class="line">                vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; next = <span class="built_in">dfs</span>(i,n/i);  <span class="comment">//(2)剪枝点,从i，不从1开始，避免重复</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sub:next)&#123;</span><br><span class="line">                    sub.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">getFactors</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">2</span>,n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="444-序列重建"><a href="#444-序列重建" class="headerlink" title="444. 序列重建"></a><a href="https://leetcode-cn.com/problems/sequence-reconstruction/">444. 序列重建</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n); <span class="comment">//列表存储边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : relation) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>], dst = edge[<span class="number">1</span>];</span><br><span class="line">            edges[src].<span class="built_in">push_back</span>(dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> index, <span class="keyword">int</span> steps) &#123; <span class="comment">//匿名函数</span></span><br><span class="line">            <span class="keyword">if</span> (steps == k &amp;&amp; index == n - <span class="number">1</span>)) &#123;</span><br><span class="line">                ++ways;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> to : edges[index]) </span><br><span class="line">                <span class="built_in">dfs</span>(to, steps + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> color, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= image.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= image[<span class="number">0</span>].<span class="built_in">size</span>() || image[x][y] != color )<span class="keyword">return</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            <span class="built_in">dfs</span>(image, mx, my, color, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> currColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (currColor != newColor) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>「力扣」第 684 题：<a href="https://leetcode-cn.com/problems/redundant-connection">冗余连接</a>（中等）；<br>「力扣」第 1319 题：<a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected">连通网络的操作次数</a>（中等）；<br>「力扣」第 1631 题：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort">最小体力消耗路径</a>（中等）；<br>「力扣」第 959 题：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes">由斜杠划分区域</a>（中等）；<br>「力扣」第 1202 题：<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps">交换字符串中的元素</a>（中等）；<br>「力扣」第 947 题：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column">移除最多的同行或同列石头</a>（中等）；<br>「力扣」第 721 题：<a href="https://leetcode-cn.com/problems/accounts-merge">账户合并</a>（中等）；<br>「力扣」第 803 题：<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit">打砖块</a>（困难）；<br>「力扣」第 1579 题：<a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable">保证图可完全遍历</a>（困难）;<br>「力扣」第 778 题：<a href="https://leetcode-cn.com/problems/swim-in-rising-water">水位上升的泳池中游泳</a>（困难）。</p>
<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS+回溯"></a>DFS+回溯</h3><h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20210929211741751.png" alt="image-20210929211741751"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数独首先行，列，还有 3*3 的方格内数字是 1~9 不能重复。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> line[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> column[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.<span class="built_in">size</span>()) &#123; <span class="comment">//递归出口 </span></span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [i, j] = spaces[pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">              	board[i][j] = digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;  <span class="comment">//x+1 转换为int</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>; <span class="comment">//标志</span></span><br><span class="line">                <span class="built_in">dfs</span>(board, pos + <span class="number">1</span>);	<span class="comment">//递归</span></span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(column, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(column));</span><br><span class="line">        <span class="built_in">memset</span>(block, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(block));</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">      <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;  <span class="comment">//x-1</span></span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后-🀄️"><a href="#51-N-皇后-🀄️" class="headerlink" title="51. N 皇后 🀄️"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; g;</span><br><span class="line">    <span class="keyword">bool</span> col[N],gd[N*<span class="number">2</span>],rgd[N*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用 </span></span><br><span class="line">  <span class="comment">//N=10,x+y最大为18</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">           res.<span class="built_in">push_back</span>(g);	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// x+y=b 正对角线 -x+y(+n)=b&gt;=0负对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[x+y] &amp;&amp; !rgd[y-x+n])&#123;</span><br><span class="line">                g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                g[x][y] = <span class="string">&#x27;.&#x27;</span>;	<span class="comment">//恢复现场，回溯</span></span><br><span class="line">                col[y] = gd[x+y] = rgd[y-x+n] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;	<span class="comment">//初始化棋盘</span></span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) tmp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            g.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0行开始 第n列开始</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上一题改一改就可以了</span></span><br><span class="line"><span class="comment">//T:O(n!) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">10</span>],gd[<span class="number">10</span>*<span class="number">2</span>],rgd[<span class="number">10</span>*<span class="number">2</span>];<span class="comment">//列占用，对角占用 反对角占用   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;	 <span class="comment">//从下标为x行开始搜索</span></span><br><span class="line">        <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">            res++;	<span class="comment">//将每个解放入结果集中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b =x+y 反对角线 b=y-x (+n) &gt;=0对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)&#123; <span class="comment">//计算x行的皇后应该放在哪一列</span></span><br><span class="line">            <span class="keyword">if</span>(!col[y] &amp;&amp; !gd[y-x+n] &amp;&amp; !rgd[x+y])&#123;</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">true</span>;<span class="comment">//占用两个对角线</span></span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,n);</span><br><span class="line">                col[y] = gd[y-x+n] = rgd[x+y] = <span class="literal">false</span>;<span class="comment">//恢复现场，回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n);	<span class="comment">//从第0个位置开始搜索</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(|s|*3^SEG_COUNT) S:O(SEG_COUNT)  ,每一段的位数不会超过 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>; <span class="comment">//ip段数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( segStart == s.<span class="built_in">size</span>())&#123; <span class="comment">//(1)</span></span><br><span class="line">                string ipAddr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                ipAddr += <span class="built_in">to_string</span>(segs[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;   <span class="comment">//不是最后一个都加&#x27;.&#x27;</span></span><br><span class="line">                        ipAddr += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">move</span>(ipAddr));    <span class="comment">//move()只是转移,提高利用效率</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//(2)4 段 IP 地址达到了，但是字符串没有遍历完，直接回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// (3)如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4)由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s[segStart] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segs[segId] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.<span class="built_in">size</span>(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s[segEnd] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转化为int</span></span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;<span class="comment">//在0-255范围内就加入</span></span><br><span class="line">                segs[segId] = addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segs.<span class="built_in">resize</span>(SEG_COUNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h4><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(min(L,MN))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,string &amp;word,<span class="keyword">int</span> k,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//不同</span></span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">length</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;               <span class="comment">//选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir: dirs) &#123;       <span class="comment">//递归搜索</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = <span class="built_in">dfs</span>(board, x, y, word, k + <span class="number">1</span>,visited);</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;	<span class="comment">//有一个符合就返回</span></span><br><span class="line">                        res = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;              <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">visited</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m)); <span class="comment">//二维</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> falg = <span class="built_in">dfs</span>(board,i,j,word,<span class="number">0</span>,visited);</span><br><span class="line">                <span class="keyword">if</span>(falg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/image-20211002001203923.png" alt="image-20211002001203923"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀树+DFS+回溯</span></span><br><span class="line"><span class="comment">//用字典树剪枝</span></span><br><span class="line"><span class="comment">//T: O(MN⋅3^L),S:O(k×L)，其中 k 是字典 words列表 的长度，L 是最长单词的长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    string word;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,TrieNode *&gt; children;</span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children.<span class="built_in">count</span>(c)) &#123;	<span class="comment">//没有，加入</span></span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];<span class="comment">//当前指向child</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool searchPrefix(TrieNode* root,string prefix) &#123;</span></span><br><span class="line"><span class="comment">  TrieNode* node = root;</span></span><br><span class="line"><span class="comment">  for (char ch : prefix) &#123;</span></span><br><span class="line"><span class="comment">    if (!node-&gt;children.count(ch)) &#123;</span></span><br><span class="line"><span class="comment">      return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    node = node-&gt;children[ch];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = board[i][j];        </span><br><span class="line">      	<span class="comment">//如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">count</span>(ch)) &#123;    <span class="comment">//字典words中没有该ch前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = root-&gt;children[ch];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;word.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;    <span class="comment">//加入当前ch</span></span><br><span class="line">            res.<span class="built_in">insert</span>(root-&gt;word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;      <span class="comment">//选择(标志)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir:dirs) &#123;   <span class="comment">//搜素</span></span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>],y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[x][y] != <span class="string">&#x27;#&#x27;</span>) <span class="built_in">dfs</span>(board, x, y, root,res);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = ch;   <span class="comment">//撤销选择</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp; board, vector&lt;string&gt; &amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode * root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        set&lt;string&gt; res;    <span class="comment">//去重</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造字典树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: words)&#123;</span><br><span class="line">            <span class="built_in">insertTrie</span>(root,word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, root, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: res) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h4 id="934-最短的桥-🀄️"><a href="#934-最短的桥-🀄️" class="headerlink" title="934. 最短的桥 🀄️"></a><a href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥</a> 🀄️</h4><p><img src="/2021/01/02/2.BFS_DFS_%E5%9B%9E%E6%BA%AF/1638328692-YrAjMu-1.png" alt="1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="126-单词接龙-II-🀄️-BFS-图的构建"><a href="#126-单词接龙-II-🀄️-BFS-图的构建" class="headerlink" title="126. 单词接龙 II 🀄️  BFS+图的构建"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a> 🀄️  BFS+图的构建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="127-单词接龙-BFS-图的构建"><a href="#127-单词接龙-BFS-图的构建" class="headerlink" title="127. 单词接龙  BFS+图的构建"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a>  BFS+图的构建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="286-墙与门-BFS-去重"><a href="#286-墙与门-BFS-去重" class="headerlink" title="286.墙与门 BFS+去重"></a><a href="https://leetcode-cn.com/problems/walls-and-gates/">286.墙与门</a> BFS+去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="301-删除无效的括号-不错"><a href="#301-删除无效的括号-不错" class="headerlink" title="301. 删除无效的括号 不错"></a><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a> 不错</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="310-最小高度树-不错"><a href="#310-最小高度树-不错" class="headerlink" title="310. 最小高度树 不错"></a><a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a> 不错</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="317-离建筑物最近的距离"><a href="#317-离建筑物最近的距离" class="headerlink" title="317.离建筑物最近的距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/">317.离建筑物最近的距离</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图BFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="133-克隆图-BFS-哈希"><a href="#133-克隆图-BFS-哈希" class="headerlink" title="133. 克隆图 BFS+哈希"></a><a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a> BFS+哈希</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*图DFS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="261-以图判树-BFS-并查集"><a href="#261-以图判树-BFS-并查集" class="headerlink" title="261.以图判树 BFS+并查集"></a><a href="https://leetcode-cn.com/problems/graph-valid-tree/">261.以图判树</a> BFS+并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="323-无向图中连通分量的数目-BFS-二维数组"><a href="#323-无向图中连通分量的数目-BFS-二维数组" class="headerlink" title="323.无向图中连通分量的数目 BFS+二维数组"></a><a href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/">323.无向图中连通分量的数目</a> BFS+二维数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="490-迷宫"><a href="#490-迷宫" class="headerlink" title="490. 迷宫"></a><a href="https://leetcode-cn.com/problems/the-maze/">490. 迷宫</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; start, vector&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">vis</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        vis[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; t[<span class="number">1</span>] == destination[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>],y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];      </span><br><span class="line">                <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; maze[x][y] == <span class="number">0</span>)&#123; <span class="comment">//遍历到墙</span></span><br><span class="line">                    x+=dir[<span class="number">0</span>];</span><br><span class="line">                    y+=dir[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                x -= dir[<span class="number">0</span>], y -= dir[<span class="number">1</span>];   <span class="comment">//撞墙了，就退一步</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="505-迷宫-II"><a href="#505-迷宫-II" class="headerlink" title="505. 迷宫 II"></a><a href="https://leetcode-cn.com/problems/the-maze-ii/">505. 迷宫 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="499-迷宫-III"><a href="#499-迷宫-III" class="headerlink" title="499. 迷宫 III"></a><a href="https://leetcode-cn.com/problems/the-maze-iii/">499. 迷宫 III</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="HJ43-迷宫问题"><a href="#HJ43-迷宫问题" class="headerlink" title="HJ43 迷宫问题"></a><a href="https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc">HJ43 迷宫问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(m*n) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//pair 默认对first升序，当first相同时对second升序；</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;PII&gt;&gt; &amp;path,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;              <span class="comment">//用于遍历</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="comment">// d[0][0] = 0;                    //移动次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())        <span class="comment">//队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();   <span class="comment">//出队</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">          <span class="comment">//if(x == n-1 &amp;&amp; y == m-1 &amp;&amp; g[x][y] == 0) cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl; //判断是否到达出口  </span></span><br><span class="line">          <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp;y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//d[x][y] = d[t.first][t.second] + 1;   //之前的距离加上又走的一步</span></span><br><span class="line">                g[x][y] = <span class="number">1</span>;</span><br><span class="line">                path[x][y] = t;        <span class="comment">//从t点到(x,y)</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x,y));   <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径</span></span><br><span class="line">    vector&lt;PII&gt;  res;          <span class="comment">//res用于逆序输出</span></span><br><span class="line">    <span class="keyword">int</span> x = n<span class="number">-1</span>,y=m<span class="number">-1</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">    <span class="keyword">while</span>(x || y)&#123;  <span class="comment">//同时为0时退出</span></span><br><span class="line">        <span class="keyword">auto</span> t = path[x][y];</span><br><span class="line">        x = t.first,y=t.second;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,res[i].first,res[i].second); <span class="comment">//(2)路径逆序输出</span></span><br><span class="line">    <span class="comment">//return d[n - 1][m - 1]; //（1）最少移动的次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));   <span class="comment">//g存储的是图  d存储的是移动次数</span></span><br><span class="line">        <span class="comment">//d = vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(m,0));</span></span><br><span class="line">        vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">path</span>(n*m,vector&lt;PII&gt;(n*m));   <span class="comment">//pre保存点映射点 注意这里需要n*m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                cin&gt;&gt;g[i][j];    <span class="comment">//存入地图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(path,g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1926-迷宫中离入口最近的出口"><a href="#1926-迷宫中离入口最近的出口" class="headerlink" title="1926. 迷宫中离入口最近的出口"></a><a href="https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestExit</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; maze, vector&lt;<span class="keyword">int</span>&gt;&amp; entrance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = maze.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = maze[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;           <span class="comment">//(x,y,d)   d是相对入口的距离</span></span><br><span class="line">        q.<span class="built_in">emplace</span>(entrance[<span class="number">0</span>],entrance[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        maze[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="string">&#x27;+&#x27;</span>;   <span class="comment">//遍历过了，防止重复访问</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [mx,my,d] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir:dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=mx+dir[<span class="number">0</span>],y=my+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;=<span class="number">0</span> &amp;&amp; x &lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y &lt;m &amp;&amp; maze[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">//边界时返回答案</span></span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">0</span> || x == n<span class="number">-1</span> || y== <span class="number">0</span> || y == m <span class="number">-1</span> ) <span class="keyword">return</span> d+<span class="number">1</span>;</span><br><span class="line">                    maze[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(x,y,d+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="PDD4迷宫寻路"><a href="#PDD4迷宫寻路" class="headerlink" title="PDD4迷宫寻路"></a><a href="https://www.nowcoder.com/practice/e3fc4f8094964a589735d640424b6a47?tpId=182&gioEnter=menu">PDD4迷宫寻路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC代码:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> G[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">105</span>][<span class="number">105</span>][<span class="number">1200</span>],N,M;</span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,k,step;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k,<span class="keyword">int</span> step):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">k</span>(k),<span class="built_in">step</span>(step)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,G[i]);</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(book));</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">                <span class="keyword">if</span>(G[i][j]==<span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    book[i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">bfs</span>(i,j));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX,<span class="keyword">int</span> startY)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">node</span>(startX,startY,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node head=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(G[head.x][head.y]==<span class="string">&#x27;3&#x27;</span>) <span class="keyword">return</span> head.step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx=head.x+Next[i][<span class="number">0</span>],ny=head.y+Next[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=N||nx&lt;<span class="number">0</span>||ny&gt;=M||ny&lt;<span class="number">0</span>||G[nx][ny]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> key=head.k;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;z&#x27;</span>) key=key|(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span>&lt;=G[nx][ny]&amp;&amp;G[nx][ny]&lt;=<span class="string">&#x27;Z&#x27;</span>&amp;&amp;(key&amp;(<span class="number">1</span>&lt;&lt;(G[nx][ny]-<span class="string">&#x27;A&#x27;</span>)))==<span class="number">0</span>) <span class="keyword">continue</span>;	<span class="comment">//没有该钥匙</span></span><br><span class="line">            <span class="keyword">if</span>(!book[nx][ny][key])&#123;</span><br><span class="line">                book[nx][ny][key]=<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx,ny,key,head.step+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//这题就是普通的bfs多了‘钥匙’这个状态 </span></span><br><span class="line"> <span class="comment">//所以book[x][y][key]的意义就是 横坐标为x,纵坐标为y,钥匙状态为key的点是否访问过 </span></span><br><span class="line"> <span class="comment">//钥匙的状态 就用二进制数表示 最多10 把钥匙 那就是1024</span></span><br><span class="line"> <span class="comment">//比如我现在有第二把钥匙和第四把钥匙  那么我的钥匙状态就是 0101000000 也就是 320</span></span><br></pre></td></tr></table></figure>

<h4 id="机器人走迷宫"><a href="#机器人走迷宫" class="headerlink" title="机器人走迷宫"></a><a href="https://www.nowcoder.com/discuss/596162?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7CDE02A66517EFFDE8544F0962A4C635-1639577561411">机器人走迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="走迷宫最小消耗"><a href="#走迷宫最小消耗" class="headerlink" title="走迷宫最小消耗"></a><a href="https://leetcode-cn.com/circle/discuss/cg0ayO/">走迷宫最小消耗</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1036-逃离大迷宫"><a href="#1036-逃离大迷宫" class="headerlink" title="1036. 逃离大迷宫"></a><a href="https://leetcode-cn.com/problems/escape-a-large-maze/">1036. 逃离大迷宫</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>3.贪心算法</title>
    <url>/2021/01/02/3.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="2-3-贪心算法"><a href="#2-3-贪心算法" class="headerlink" title="2.3 贪心算法"></a>2.3 贪心算法</h1><blockquote>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的<strong>局部最优解</strong>。 </p>
<p>分配问题：</p>
<p>区间问题：</p>
</blockquote>
<span id="more"></span>

<h4 id="455-分发饼干-🀄️"><a href="#455-分发饼干-🀄️" class="headerlink" title="455. 分发饼干 🀄️"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment">因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。</span></span><br><span class="line"><span class="comment">把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());    <span class="comment">//排序，小的优先</span></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> child=<span class="number">0</span>,cookie=<span class="number">0</span>;   <span class="comment">//类似双指针</span></span><br><span class="line">        <span class="keyword">while</span>(child &lt; g.<span class="built_in">size</span>() &amp;&amp; cookie &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child] &lt;= s[cookie]) child++;  <span class="comment">//满足</span></span><br><span class="line">            cookie++;   <span class="comment">//无论满不满足都得加</span></span><br><span class="line">          	<span class="comment">//每个孩子最多只能给一块饼干</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="135-分发糖果-🀄️"><a href="#135-分发糖果-🀄️" class="headerlink" title="135. 分发糖果 🀄️"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">从左到右遍历，右边大于左边，则右边= 左边+1</span></span><br><span class="line"><span class="comment">从右到左遍历，左边大于右边，则左边= max(左边,右边+1)</span></span><br><span class="line"><span class="comment">考虑：</span></span><br><span class="line"><span class="comment">[1,3,4,5,2]</span></span><br><span class="line"><span class="comment"> 1 1 1 1 1</span></span><br><span class="line"><span class="comment"> 1 2 3 4 1  右边大时，右边= 左边+1</span></span><br><span class="line"><span class="comment"> 1 2 3 4 1  左边大时，左边=max(左边，右边+1)  max(4,1+1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) <span class="keyword">return</span> size;          <span class="comment">//base case 0,1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;           <span class="comment">//全部初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i)      <span class="comment">//右边大于左边，右边= 左边+1</span></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])  num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)  <span class="comment">//左边大于右边，左边= max(左边,右边+1)</span></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>]) num[i<span class="number">-1</span>] = <span class="built_in">max</span>(num[i<span class="number">-1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//求和，0是初始的累加值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1518-换酒问题"><a href="#1518-换酒问题" class="headerlink" title="1518. 换酒问题"></a><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a><a href="https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1111-有效括号的嵌套深度"><a href="#1111-有效括号的嵌套深度" class="headerlink" title="1111. 有效括号的嵌套深度"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/">1111. 有效括号的嵌套深度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">861. 翻转矩阵后的得分</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：分配问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="435-无重叠区间-🀄️"><a href="#435-无重叠区间-🀄️" class="headerlink" title="435. 无重叠区间 🀄️"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*贪心：区间问题</span></span><br><span class="line"><span class="comment">题意：给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</span></span><br><span class="line"><span class="comment">思路：优先保留结尾小且不相交的区间，就越能保留更多的区间。</span></span><br><span class="line"><span class="comment">先排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。</span></span><br><span class="line"><span class="comment">⚠️需要根据实际情况判断按区间开头排序还是按区间结尾排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; gs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gs.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(gs.<span class="built_in">begin</span>(), gs.<span class="built_in">end</span>(),cmp);<span class="comment">//区间结尾排序，从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, pre = gs[<span class="number">0</span>][<span class="number">1</span>];   <span class="comment">//pre前区间结尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; gs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gs[i][<span class="number">0</span>] &lt; pre) res++;  <span class="comment">// 当前区间开始值 &lt; pre前区间结尾  有重叠</span></span><br><span class="line">            <span class="keyword">else</span>  pre = gs[i][<span class="number">1</span>];       <span class="comment">// &gt;= 无重叠，更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数学推导 / 贪心思想</span></span><br><span class="line"><span class="comment">//分成几段，求几段相乘的最大乘积,2 &lt;= n &lt;= 58</span></span><br><span class="line"><span class="comment">//S,T:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>; <span class="comment">//2=1+1 1x1=1</span></span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;	<span class="comment">//n=3a+b ，b可能为0，1，2</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);					<span class="comment">//6=3+3  a=2</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;	<span class="comment">//10=3+3+4 a=3</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>; <span class="comment">//8=3+3+2	a=2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数学推导 / 贪心思想 +快速幂求余</span></span><br><span class="line"><span class="comment">//分成几段，求几段相乘的最大乘积,2 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment">//S,T:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;	<span class="comment">//n=3a+b ，b可能为0，1，2</span></span><br><span class="line">        <span class="keyword">long</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;	<span class="comment">//快速幂(大数)求余 rem</span></span><br><span class="line">      	<span class="keyword">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>;			<span class="comment">//n=9 a=2</span></span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>) &#123;				<span class="comment">//rem=9</span></span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">          	a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">3</span> % p);<span class="comment">//rem^(a+1)%p</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">4</span> % p);	<span class="comment">//rem^(a)*4%p</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">3</span>*<span class="number">2</span> % p);	<span class="comment">//rem^(a+1)*2%p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>4.指针类问题</title>
    <url>/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="2-4-指针类问题"><a href="#2-4-指针类问题" class="headerlink" title="2.4 指针类问题"></a>2.4 指针类问题</h1><blockquote>
<p>1.<strong>双指针/滑动窗口</strong>，用快慢指针，遍历方向相同，且不相交</p>
<p>2.<strong>搜索</strong>（往往搜索的数组排好序），遍历方向相反</p>
</blockquote>
<span id="more"></span>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20210629195210802.png" alt="image-20210629195210802"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(target)	S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">int</span> sum = (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                l++;    <span class="comment">//⚠️</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) r++; </span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先整个翻转，再每个单词翻转</span></span><br><span class="line"><span class="comment">//T:O(n),S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != <span class="string">&#x27; &#x27;</span>)&#123;             <span class="comment">//当前不是空格</span></span><br><span class="line">                <span class="keyword">if</span>(r != <span class="number">0</span>) s[r++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//将前面的空格填上</span></span><br><span class="line">                <span class="keyword">int</span> end = l;</span><br><span class="line">                <span class="keyword">while</span>(s[end] != <span class="string">&#x27; &#x27;</span>&amp;&amp; end &lt; n)&#123;<span class="comment">// 遍历到空格停止</span></span><br><span class="line">                    s[r++] = s[end++];</span><br><span class="line">                &#125; <span class="comment">//此时r为单词末尾 单词长度end-l，起始位置 r-(end-l) </span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+r-(end-l),s.<span class="built_in">begin</span>()+r); <span class="comment">//到r-1</span></span><br><span class="line">                l = end;  <span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+r,s.<span class="built_in">end</span>());   <span class="comment">//删除末尾空格</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(m) m字符集大小</span></span><br><span class="line">  <span class="comment">//r指针一直右移，没有就存入，出现过就删除，并将l左移</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; occ;<span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (l &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[r + <span class="number">1</span>])) &#123;    <span class="comment">//当前字符没有出现过</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[r+<span class="number">1</span>]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;         <span class="comment">//已经出现了，删除</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l+ <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举最长子串中的字符种类数目(本题最大为26)</span></span><br><span class="line"><span class="comment">//枚举+滑动窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=<span class="number">26</span>;p++)&#123;</span><br><span class="line">           <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">           <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//total 代表 [left, right] 区间所有的字符种类数量；sum 代表满足「出现次数不少于 k」的字符种类数量</span></span><br><span class="line">           <span class="keyword">int</span> total=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(r &lt; n)&#123;</span><br><span class="line">               <span class="keyword">int</span> index = s[r]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">               cnt[index]++;</span><br><span class="line">               <span class="keyword">if</span>(cnt[index] == <span class="number">1</span>) total++; <span class="comment">//新的字符，直接加1</span></span><br><span class="line">               <span class="keyword">if</span>(cnt[index] == k) sum++;   <span class="comment">//满足加1</span></span><br><span class="line">               <span class="keyword">while</span>(total &gt; p)&#123;    <span class="comment">//一直左移，缩小窗口为p</span></span><br><span class="line">                   index = s[l] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[index] == <span class="number">1</span>) total--;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[index] == k) sum--;</span><br><span class="line">                   cnt[index]--;</span><br><span class="line">                   l++;</span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span>(total == sum) res=<span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">               r++; <span class="comment">//下一个</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(m*n)  S:O(m)   s 的长度是 n，words 里有 m 个单词</span></span><br><span class="line"><span class="comment">//map存words（单词，次数） map2临时统计（单词，次数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">int</span> wordNum = words.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(wordNum == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">       <span class="keyword">int</span> len = words[<span class="number">0</span>].<span class="built_in">size</span>();   <span class="comment">//滑动窗口大小</span></span><br><span class="line">       unordered_map&lt;string,<span class="keyword">int</span>&gt; map;	</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word:words) map[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()-wordNum*len+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            unordered_map&lt;string,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num &lt; wordNum)&#123;   <span class="comment">//不同于java的subString</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(i+num*len,len);  <span class="comment">//取出当前word</span></span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(word))&#123;</span><br><span class="line">                    tmp[word]++;</span><br><span class="line">                    <span class="keyword">if</span>(tmp[word] &gt; map[word]) <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                num++;  <span class="comment">//下一个word</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == wordNum)&#123;  <span class="comment">//判断是不是所有的单词都符合条件</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="76-最小覆盖子串🀄️"><a href="#76-最小覆盖子串🀄️" class="headerlink" title="76. 最小覆盖子串🀄️"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>🀄️</h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/76_fig1.gif" alt="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*滑动窗口 遍历方向相同，返回包含t的最小子串</span></span><br><span class="line"><span class="comment">T：O(C*s+t) S:O(C) C字符集大小</span></span><br><span class="line"><span class="comment">思路：r指针不断向右移动，直到包含T字串，此时l指针向右移，尝试找到最短的包含T的子串</span></span><br><span class="line"><span class="comment"> chars 表示T中每个字符的数量，flag 表示每个字符是否在 T 中存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;   </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;        <span class="comment">//哈希表 </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>,<span class="literal">false</span>)</span></span>;   <span class="comment">//是否为T中的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt[t[i]]++;</span><br><span class="line">            flag[t[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,min_l=<span class="number">0</span>,min_size = s.<span class="built_in">size</span>()+<span class="number">1</span>;<span class="comment">//min_size最短子串长度</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//T中字符串出现的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[s[r]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--cnt[s[r]] &gt;= <span class="number">0</span>) num++;</span><br><span class="line">                <span class="keyword">while</span>(num == t.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(r-l+<span class="number">1</span> &lt; min_size)&#123;</span><br><span class="line">                        min_l = l;  <span class="comment">//左边起始</span></span><br><span class="line">                        min_size = r-l+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//比如：T:BC，S:ABBACD，l=0,r=4,需要再移动l</span></span><br><span class="line">                    <span class="keyword">if</span>(flag[s[l]] &amp;&amp; ++cnt[s[l]] &gt; <span class="number">0</span>) num--;  <span class="comment">//是T中字符，且要将这个字符移除窗口</span></span><br><span class="line">                    l++;    <span class="comment">//缩小窗口,l=3,cnt=1，跳出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_size &gt; s.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span>: s.<span class="built_in">substr</span>(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159.至多包含两个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/">159.至多包含两个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;  <span class="comment">//找到符合的</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                sum -= nums[l]; <span class="comment">//左移，缩小窗口，直到最小</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="340-至多包含-K-个不同字符的最长子串"><a href="#340-至多包含-K-个不同字符的最长子串" class="headerlink" title="340. 至多包含 K 个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">340. 至多包含 K 个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(k+m) S:O(C) C:26个字母</span></span><br><span class="line"><span class="comment">//当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的排列。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.<span class="built_in">length</span>(), m = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">cnt2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++cnt1[s1[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == cnt2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; m; ++i) &#123;   <span class="comment">//n为窗口大小</span></span><br><span class="line">            --cnt2[s2[i - n] - <span class="string">&#x27;a&#x27;</span>];    <span class="comment">//向右滑动,左边界滑出</span></span><br><span class="line">            ++cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>];        <span class="comment">//右边界++</span></span><br><span class="line">            <span class="keyword">if</span> (cnt1 == cnt2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632. 最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range/">632. 最小区间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="727-最小窗口子序列"><a href="#727-最小窗口子序列" class="headerlink" title="727. 最小窗口子序列"></a><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【快慢指针（多走一步）寻找链表中点 + 反转链表（右半部分） +合并链表（ 左取1个，右边取1个）】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next )&#123;     <span class="comment">//保证前进的2个都不为空</span></span><br><span class="line">            slow =slow-&gt;next;</span><br><span class="line">            fast =fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur =head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tmp=cur-&gt;next;        <span class="comment">//暂存</span></span><br><span class="line">            cur-&gt;next = pre;        <span class="comment">//由于这里next改变了</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1,ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            ListNode*  tmp1 = l1-&gt;next;     <span class="comment">//暂存</span></span><br><span class="line">            ListNode*  tmp2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next=l2;    <span class="comment">//l1指向l2      由于这里next改变了</span></span><br><span class="line">            l1 = tmp1;     <span class="comment">//更新l1</span></span><br><span class="line">            l2-&gt;next=l1;</span><br><span class="line">            l2=tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">getMid</span>(head);</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = mid-&gt;next;   <span class="comment">//l2头结点</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;        <span class="comment">//l1尾结点next置为NULL</span></span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="built_in">mergeList</span>(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快指针先移动n步后，快，慢指针再同步移动</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">//必须要这个，否则删除的是头结点会报错</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* quick = dummy,*slow=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;   <span class="comment">//循环n+1多了个dummy</span></span><br><span class="line">            quick=quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(quick)&#123;</span><br><span class="line">            quick=quick-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;        </span><br><span class="line">        &#125;   <span class="comment">//slow为要删除的结点的前一个结点</span></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(slow &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【快慢指针，同步指针】2次相遇：第1次相遇不清楚位置，第二次相遇为入口结点。重合时 fast 比 slow 多走 环的长度整数倍</span></span><br><span class="line"><span class="comment">//第1次相遇：fast：f=2s f=s+nb ==&gt; slow:s = nb		a环前的长度，b环的长度</span></span><br><span class="line"><span class="comment">//第2次相遇：让slow在a步停下来，让slow和fast在a处相遇，</span></span><br><span class="line"><span class="comment">//slow不变，fast=head，同步移动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//⚠️处理特殊情况</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cur,pre</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p><img src="/Users/zcz/Desktop/images/image-20211227201227099.png" alt="image-20211227201227099"></p>
<p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227201238570.png" alt="image-20211227201238570"></p>
<p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227201258314.png" alt="image-20211227201258314"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三指针</span></span><br><span class="line"><span class="comment">// 1    2    3   4  5 翻转[2,4]</span></span><br><span class="line"><span class="comment">// pre cur next</span></span><br><span class="line"><span class="comment">// 1 3 2 4 5</span></span><br><span class="line"><span class="comment">// 1 4 3 2 5</span></span><br><span class="line"><span class="comment">// 1 5 4 3 2</span></span><br><span class="line"><span class="comment">// 1 4 3 2 5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* pre=dummy;  <span class="comment">//待反转区域的第一个节点的前一个结点  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;left;i++)&#123;<span class="comment">//⚠️</span></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = pre-&gt;next;  <span class="comment">//待反转区域的第一个节点       </span></span><br><span class="line">        ListNode* next;   <span class="comment">//待反转区域的第一个节点的下一个结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=right-left;i++)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;<span class="comment">//头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2 )&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;             <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 != <span class="literal">NULL</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227211706771.png" alt="image-20211227211706771"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助归并排序，分治思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;<span class="comment">//辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;q,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//取分治点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="built_in">merge_sort</span>(q,l,mid)+<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r); <span class="comment">//递归</span></span><br><span class="line">        <span class="comment">/*这里ans存储了左区间和右区间的逆序对总数*/</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//此循环统计不同区间的逆序对</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]&lt;=q[j]) &#123;    <span class="comment">//小的放入数组</span></span><br><span class="line">                tmp[k++]=q[i++]; </span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">/*由于左区间和右区间已经有序当前左区间元素构成逆序,之后的都会构成逆序对*/</span></span><br><span class="line">                <span class="comment">/*所以ans需要加上区间长度*/</span></span><br><span class="line">                ans+=mid-i+<span class="number">1</span>;           </span><br><span class="line">                tmp[k++]=q[j++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;) q[i++]=tmp[j++];<span class="comment">//⚠️需要还原数组  </span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针+烂漫相遇</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* pa=headA,*pb=headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">            pa = pa != <span class="literal">NULL</span> ? pa-&gt;next : headB;</span><br><span class="line">            pb = pb != <span class="literal">NULL</span> ? pb-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：同向遍历链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">//用来保存开始结点</span></span><br><span class="line">        ListNode* node = dummy; <span class="comment">//node循环遍历结点</span></span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;    <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 != <span class="literal">nullptr</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 != <span class="literal">nullptr</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = a+b+c;</span><br><span class="line">            </span><br><span class="line">            c = sum/<span class="number">10</span>; </span><br><span class="line">            <span class="keyword">int</span> cur = sum%<span class="number">10</span>;   </span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur); </span><br><span class="line"></span><br><span class="line">            node = node-&gt;next;      <span class="comment">//移到下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>) node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);<span class="comment">//处理最后一个进位</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h4><p><img src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20211227221628897.png" alt="image-20211227221628897"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序+三指针</span></span><br><span class="line"><span class="comment">//T:O(n^2)  S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; len ; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 当前数字大于0，提前结束（因为排序了，后面的都&gt;0）</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保a改变 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = a+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[a] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[a],nums[L],nums[R]&#125;);</span><br><span class="line">                    <span class="comment">// 还要去重，比如: [-2, -1, -1, -1, 3, 3, 3]</span></span><br><span class="line">      <span class="comment">//i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 确保b改变 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R<span class="number">-1</span>]) R--; <span class="comment">// 确保c改变 去重</span></span><br><span class="line">                    L++;    <span class="comment">//继续遍历</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;=len<span class="number">-4</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保a改变 去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a+<span class="number">1</span>; b &lt;=len<span class="number">-3</span> ; b++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b &gt; a+<span class="number">1</span> &amp;&amp; nums[b] == nums[b<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 确保b改变 去重</span></span><br><span class="line">                <span class="keyword">int</span> L = b+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> R = len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target - (nums[a] + nums[b])  == nums[L] + nums[R])&#123;    <span class="comment">//用减法，防止溢出</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[a],nums[b],nums[L],nums[R]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 确保c改变 去重</span></span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R<span class="number">-1</span>]) R--; <span class="comment">// 确保d改变 去重</span></span><br><span class="line">                        L++;    <span class="comment">//继续遍历</span></span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (target - (nums[a] + nums[b])  &gt; nums[L] + nums[R]) L++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (target - (nums[a] + nums[b])  &lt; nums[L] + nums[R]) R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三指针+排序（去重</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = INT_MAX;  <span class="comment">//上一次最接近多少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=a+<span class="number">1</span>,c=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(b &lt; c)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum =  nums[a] + nums[b] + nums[c];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-sum) &lt; pre)&#123;  <span class="comment">//比上次更佳接近</span></span><br><span class="line">                    pre = <span class="built_in">abs</span>(target-sum);  <span class="comment">//更新pre   </span></span><br><span class="line">                    res = sum;              <span class="comment">//保存当前sum</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> sum;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) c--;</span><br><span class="line">                <span class="keyword">else</span> b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259.较小的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/">259.较小的三数之和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快慢指针 遍历方向相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* quick=head,*slow=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            quick =quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(quick)&#123;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="167-两数之和-II-输入有序数组-🀄️"><a href="#167-两数之和-II-输入有序数组-🀄️" class="headerlink" title="167. 两数之和 II - 输入有序数组 🀄️"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 </a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 搜索 遍历方向相反</span></span><br><span class="line"><span class="comment">题意：在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(target == t) <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; t) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="88-合并两个有序数组🀄️"><a href="#88-合并两个有序数组🀄️" class="headerlink" title="88. 合并两个有序数组🀄️"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>🀄️</h4><img width="300" height="200" src="/2021/01/02/4.%E6%8C%87%E9%92%88%E7%B1%BB%E9%97%AE%E9%A2%98/image-20210308145931744.png">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 逆序双指针</span></span><br><span class="line"><span class="comment">T:O(m+n) S:O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1=m<span class="number">-1</span>,p2=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2])&#123;</span><br><span class="line">                nums1[end--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[end--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>) nums1[end--] = nums1[p1--];</span><br><span class="line">        <span class="keyword">while</span>(p2&gt;=<span class="number">0</span>) nums1[end--] = nums2[p2--];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="面试题-17-11-单词距离🀄️"><a href="#面试题-17-11-单词距离🀄️" class="headerlink" title="面试题 17.11. 单词距离🀄️"></a><a href="https://leetcode-cn.com/problems/find-closest-lcci/">面试题 17.11. 单词距离</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*双指针 同个方向</span></span><br><span class="line"><span class="comment">题解：用两个指针一直记录两个单词出现的下标，在一次遍历数组的循环中，不断记录两个下标，并取他们差值的最小值，返回结果即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(vector&lt;string&gt;&amp; words, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = words.<span class="built_in">size</span>();      <span class="comment">//最长距离不可能为len</span></span><br><span class="line">        <span class="keyword">int</span> res = len;              </span><br><span class="line">        <span class="keyword">int</span> index1=-len,index2=len; <span class="comment">//⚠️ 2者距离最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1 == words[i]) index1 = i;   <span class="comment">//记录下标</span></span><br><span class="line">            <span class="keyword">if</span>(word2 == words[i]) index2 = i;   <span class="comment">//记录下标</span></span><br><span class="line">            res = <span class="built_in">min</span>(res,<span class="built_in">abs</span>(index2-index1));  <span class="comment">//取最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键思想：从二维数组的右上角开始查找。</span></span><br><span class="line"><span class="comment">//t:O(n+m) S:O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>,col=m-<span class="number">1</span>;row &lt; n &amp;&amp; col &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            cout &lt;&lt; row &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;col &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(M[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(M[row][col] &gt; target) col--;</span><br><span class="line">            <span class="keyword">else</span> row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针，搜索  T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">/*左边搜索偶数，右边搜索奇数；然后交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] %<span class="number">2</span> != <span class="number">0</span>)&#123;<span class="comment">//搜索偶数    ⚠️记得加 l&lt;r</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] %<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//搜索奇数</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l++],nums[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(根号c) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = (<span class="keyword">long</span>) Math.<span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span> (sum == c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; c) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(|s|)</span></span><br><span class="line"><span class="comment">//【首尾双指针】先isalnum(ch)存下来，再用首尾指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string new_s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))</span><br><span class="line">                new_s+=<span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=new_s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(new_s[l] != new_s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="comment">//【首尾双指针】low==high，ow--.high++；否则判断2个区间[low,high-1]，[low+1,high]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++,r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l =<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] == s[r])&#123;</span><br><span class="line">                l++,r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">check</span>(s,l,r<span class="number">-1</span>) || <span class="built_in">check</span>(s,l+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> string &amp;a,<span class="keyword">const</span> string &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();  <span class="comment">//按大到小</span></span><br><span class="line">        <span class="keyword">return</span> a&lt;b;   <span class="comment">//长度相同，比较字典序，从小到大</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(D.<span class="built_in">begin</span>(),D.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word:D) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == word[j]) j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) <span class="keyword">return</span> word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="340-至多包含k个不同字符的最长子串"><a href="#340-至多包含k个不同字符的最长子串" class="headerlink" title="340.至多包含k个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">340.至多包含k个不同字符的最长子串</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆序双指针：原地修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;    <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(n+cnt*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[j] = s[i];    <span class="comment">//不为空格，直接赋值给s[j]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[j<span class="number">-2</span>] = <span class="string">&#x27;%&#x27;</span>,s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>,s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>; <span class="comment">//多个2个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> fast=<span class="number">1</span>,slow=<span class="number">1</span>;  <span class="comment">//同起点</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast<span class="number">-1</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【逆序双指针】取决于两端小的那个；左边小移动左边，反之右边；尽可能找大的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res,(r-l)*<span class="built_in">min</span>(height[l],height[r]));</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt;= height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先排序+区间指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());    <span class="comment">//⚠️，先排序</span></span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">-2e9</span>,ed=<span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ed &lt; it[<span class="number">0</span>])&#123;  <span class="comment">//上一段的ed &lt; 当前一段的st 没有交集</span></span><br><span class="line">                <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);  <span class="comment">//将上一段放入res</span></span><br><span class="line">                st = it[<span class="number">0</span>],ed=it[<span class="number">1</span>];    <span class="comment">//更新上一段</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//有交集</span></span><br><span class="line">                ed = <span class="built_in">max</span>(ed,it[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);  <span class="comment">//处理最后一个</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同向指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1_size= s1.<span class="built_in">size</span>(),l2_size=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l1_size || j &lt; l2_size) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; l1_size &amp;&amp; s1[i] != <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s1[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//⚠️转为int，恰好去除了前导0</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; l2_size &amp;&amp; s2[j] != <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">                y = y * <span class="number">10</span> + s2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>5.二分查找</title>
    <url>/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="5-二分查找"><a href="#5-二分查找" class="headerlink" title="5.二分查找"></a>5.二分查找</h2><blockquote>
<p>二分查找：每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为 <em>O</em>(<em>n</em>) 的数组，二分查找的时间复杂度为 <em>O</em>(log <em>n</em>)。 </p>
<p>双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p>
</blockquote>
<span id="more"></span>

<h3 id="二分查找模板-I"><a href="#二分查找模板-I" class="headerlink" title="二分查找模板 I"></a>二分查找模板 I</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r =nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;	<span class="comment">//每次都有一个结果</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;	</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><h4 id="69-x-的平方根-🀄️"><a href="#69-x-的平方根-🀄️" class="headerlink" title="69. x 的平方根 🀄️"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =  l+(r+l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid == x) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)mid*mid &gt; x) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;       <span class="comment">//⚠️ l&gt;r 返回小的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> res =<span class="built_in">guess</span>(mid);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res == <span class="number">-1</span>) r = mid <span class="number">-1</span>;  <span class="comment">// mid &gt; pick </span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="33-搜索旋转排序数组-🀄️"><a href="#33-搜索旋转排序数组-🀄️" class="headerlink" title="33. 搜索旋转排序数组 🀄️"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 🀄️</h4><p><img src="/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/33_fig1.png" alt="fig1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要注意的是，二分的写法有很多种，所以在判断 target 大小与有序部分的关系的时候可能会出现细节上的差别。</span></span><br><span class="line"><span class="comment">二分里面再二分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+ (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid])&#123; <span class="comment">//情况1 [l, mid - 1] 是有序数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; r=mid <span class="number">-1</span>; &#125;  </span><br><span class="line">                <span class="keyword">else</span> &#123; l = mid + <span class="number">1</span>;&#125;                                      </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;          <span class="comment">//情况2 [mid+1,n-1]是有序数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="number">-1</span>])&#123; l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;r =  mid - <span class="number">1</span>;&#125;                                     </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找模板-II"><a href="#二分查找模板-II" class="headerlink" title="二分查找模板 II"></a>二分查找模板 II</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;		<span class="comment">//满足左边[l...mid]</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid; <span class="comment">// 往左走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; l = mid + <span class="number">1</span>; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>) </span>&#123;		<span class="comment">//满足右边[mid,r] l要+1，避免死循环</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>+<span class="number">1</span>;		</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid; <span class="comment">// 往右走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; r = mid - <span class="number">1</span>; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>	) </span>&#123;		<span class="comment">//左,右边</span></span><br><span class="line"> 	  <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">      	<span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;		</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid; <span class="comment">// 往右走</span></span><br><span class="line">      	<span class="keyword">else</span>&#123; r = mid; &#125;        </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="81-搜索旋转排序数组-II-🀄️"><a href="#81-搜索旋转排序数组-II-🀄️" class="headerlink" title="81. 搜索旋转排序数组 II 🀄️"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a> 🀄️</h4><p>怎么分是关键，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一类</span><br><span class="line">10111 和 11101这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。</span><br><span class="line">第二类</span><br><span class="line">2 3 4 5 6 7 1  这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；</span><br><span class="line">这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。</span><br><span class="line">第三类</span><br><span class="line">6 7 1 2 3 4 5这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；</span><br><span class="line">这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+ (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] == nums[mid]) l++;   <span class="comment">// 过滤干扰 改这里</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; nums[mid])&#123; <span class="comment">//情况1 [l, mid - 1] 是有序数组 //0改为l</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; r=mid <span class="number">-1</span>; &#125;  <span class="comment">//0改为l</span></span><br><span class="line">                <span class="keyword">else</span> &#123; l = mid + <span class="number">1</span>;&#125;                                      </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;          <span class="comment">//情况2 [mid+1,n-1]是有序数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="number">-1</span>])&#123; l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;r =  mid - <span class="number">1</span>;&#125;                                     </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="comment">//时间复杂度 O(logN) ： 二分法为对数级别复杂度。</span></span><br><span class="line"><span class="comment">//空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hleper</span>(nums,target)-<span class="built_in">hleper</span>(nums,target<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hleper</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//target的右边界（边界不包括target）</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l=mid+<span class="number">1</span>;    <span class="comment">//在[mid+1,r]	⚠️</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;                   <span class="comment">//在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logN) S:O(1)</span></span><br></pre></td></tr></table></figure>



<h4 id="34-在排序数组中查找元素的第一个和最后一个位置-🀄️-左边-右边"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-🀄️-左边-右边" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 🀄️ 左边+右边"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a> 🀄️ 左边+右边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分，同上</span></span><br><span class="line"><span class="comment">//时间复杂度 O(logN) ： 二分法为对数级别复杂度。</span></span><br><span class="line"><span class="comment">//空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">hleper</span>(nums,target<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">hleper</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> &#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hleper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> target)</span></span>&#123;  <span class="comment">//target的右边界（边界不包括target）</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l=mid+<span class="number">1</span>;    <span class="comment">//在[mid+1,r]	⚠️</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;                   <span class="comment">//在[l,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="278-第一个错误的版本-左边"><a href="#278-第一个错误的版本-左边" class="headerlink" title="278. 第一个错误的版本 左边"></a><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r= n;		<span class="comment">//⚠️这里下标是从1到n</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;   <span class="comment">//不能相等,否则死循环</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid)) r = mid; <span class="comment">//有问题，往左(更早版本)走</span></span><br><span class="line">            <span class="keyword">else</span>&#123; l = mid + <span class="number">1</span>; &#125;        <span class="comment">//没问题，往后面的版本走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;       <span class="comment">//返回小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="162-寻找峰值-左边"><a href="#162-寻找峰值-左边" class="headerlink" title="162. 寻找峰值 左边"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">峰值元素是指其值大于左右相邻值的元素。</span></span><br><span class="line"><span class="comment">给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</span></span><br><span class="line"><span class="comment">你可以假设 nums[-1] = nums[n] = -∞ 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> , r= nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= nums[mid+<span class="number">1</span>]) r =  mid;	<span class="comment">//左边大或者等于 往左边走</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="153-寻找旋转排序数组中的最小值-左边"><a href="#153-寻找旋转排序数组中的最小值-左边" class="headerlink" title="153. 寻找旋转排序数组中的最小值 左边"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r= nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= nums[r]) r = mid;	<span class="comment">//往左走</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><h4 id="154-寻找旋转排序数组中的最小值-II-🀄️"><a href="#154-寻找旋转排序数组中的最小值-II-🀄️" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II 🀄️"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与1的区别，数组中可能存在重复的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;    <span class="comment">//最小值在左边[l,mid]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l = mid+<span class="number">1</span>;<span class="comment">//最小值在右边[mid+1,r]</span></span><br><span class="line">            <span class="keyword">else</span> r--;   <span class="comment">//最小值在[l,r]之间，去除r边界,</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="540-有序数组中的单一元素-右边-变形-🀄️"><a href="#540-有序数组中的单一元素-右边-变形-🀄️" class="headerlink" title="540. 有序数组中的单一元素 右边(变形)🀄️"></a><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a> 右边(变形)🀄️</h4><p><img src="/2021/01/02/5.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20210402152931582.png" alt="image-20210402152931582"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid %<span class="number">2</span> == <span class="number">1</span>) mid --; <span class="comment">//保证mid为偶数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid+<span class="number">1</span>]) l = mid + <span class="number">2</span>;   <span class="comment">//跳过2个</span></span><br><span class="line">            <span class="keyword">else</span> r = mid;   <span class="comment">//单个元素 保持 比如 1,1,3  mid=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l]; 	<span class="comment">//nums[r]都可以	r=l</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="658-找到-K-个最接近的元素-🀄️左边"><a href="#658-找到-K-个最接近的元素-🀄️左边" class="headerlink" title="658. 找到 K 个最接近的元素  🀄️左边"></a><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a>  🀄️左边</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - k;	<span class="comment">//这里</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =l +(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x - nums[mid] &lt;= nums[mid+k] -x ) r = mid;	<span class="comment">//左边差值小,向左侧靠近</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(nums.<span class="built_in">begin</span>()+l,nums.<span class="built_in">begin</span>()+l+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-寻找两个正序数组的中位数-归并或者二分"><a href="#4-寻找两个正序数组的中位数-归并或者二分" class="headerlink" title="4. 寻找两个正序数组的中位数 归并或者二分"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a> 归并或者二分</h4><p><strong>（归并排序空间复杂度O(1))怎么实现</strong></p>
<p><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value">最接近的二叉搜索树值</a>  </p>
<p><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii">最接近的二叉搜索树值 II</a>  </p>
<p><a href="https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size">搜索长度未知的有序数组</a>  </p>
<h4 id="50-Pow-x-n-🀄️"><a href="#50-Pow-x-n-🀄️" class="headerlink" title="50. Pow(x, n)🀄️"></a><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快速幂</span></span><br><span class="line"><span class="comment">1	0	0	1	1	0	1</span></span><br><span class="line"><span class="comment">x^64	x^32	x^16	x^8	x^4	x^2	x^1</span></span><br><span class="line"><span class="comment">最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 迭代算法，利用二进制位</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123; <span class="comment">// 0 的任何次方都等于 0,1 的任何次方都等于 1</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> power = n;    <span class="comment">// 为了保证-n不溢出，先转换成long类型</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;         <span class="comment">// 如果n小于0， 求1/x的-n次方</span></span><br><span class="line">            power *= <span class="number">-1</span>;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> weight = x;  <span class="comment">// 权值初值为x, 即二进制位第1位的权值为x^1</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(power != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果当前二进制位为1， 让结果乘上这个二进制位上的权值, </span></span><br><span class="line">            <span class="comment">// 该位权值在上一轮迭代中已经计算出来了</span></span><br><span class="line">            <span class="keyword">if</span>((power &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;   </span><br><span class="line">                res *= weight;</span><br><span class="line">            &#125;</span><br><span class="line">            weight *= weight;   <span class="comment">// 计算下一个二进制位的权值</span></span><br><span class="line">            power /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=letters.<span class="built_in">size</span>();   <span class="comment">//⚠️这里r遍历多出1个</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid =l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == letters.<span class="built_in">size</span>()) <span class="keyword">return</span> letters[<span class="number">0</span>]; <span class="comment">//越界,变成第一个</span></span><br><span class="line">        <span class="keyword">return</span> letters[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="719-找出第-k-小的距离对🀄️"><a href="#719-找出第-k-小的距离对🀄️" class="headerlink" title="719. 找出第 k 小的距离对🀄️"></a><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设数组元素有n个，那么共有n*(n-1)/2个所谓的距离。这些距离的大小是有范围的，即最小的距离必大于等于0，最大的距离为数组的最大元素减去数组的最小元素。题目中所求的第k个最小距离就在其中。</span></span><br><span class="line"><span class="comment">我们可以用二分查找来找到这个目标距离，初始化l=0，r=最大距离。mid=(l+r)/2，计算出距离小于等于mid的数对的个数count。</span></span><br><span class="line"><span class="comment">    若count&lt;k，则第k个最小距离不会在[mid+1,r]之间，故修改l=mid+1；</span></span><br><span class="line"><span class="comment">    否则，r=mid；(因为第k个最小距离在[l,mid]之间)；</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">[1,3,3,4]</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">r l  </span></span><br><span class="line"><span class="comment">1 1   3 3</span></span><br><span class="line"><span class="comment">2 1   3 3</span></span><br><span class="line"><span class="comment">3 1		4 3, 4 3</span></span><br><span class="line"><span class="comment">l:0r:3 mid:1count:3</span></span><br><span class="line"><span class="comment">1 1  3 3</span></span><br><span class="line"><span class="comment">2 1  3 3</span></span><br><span class="line"><span class="comment">3 3  4 4</span></span><br><span class="line"><span class="comment">l:0r:1 mid:0count:1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//nums数组一定要排序</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">back</span>() - nums.<span class="built_in">front</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">countPair</span>(nums, mid)&lt;k)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>; r &lt; nums.<span class="built_in">size</span>(); r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] - nums[l] &gt; mid) l++;</span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><h4 id="1044-最长重复子串"><a href="#1044-最长重复子串" class="headerlink" title="1044. 最长重复子串"></a><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">1044. 最长重复子串</a></h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>6.DP</title>
    <url>/2021/01/02/6.DP/</url>
    <content><![CDATA[<h1 id="6-DP-一"><a href="#6-DP-一" class="headerlink" title="6. DP(一)"></a>6. DP(一)</h1><blockquote>
<p>1.确定dp数组以及下标的含义<br>2.确定转移方程<br>3.dp数组初始化<br>4.确定遍历顺序<br>5.举例推导</p>
</blockquote>
<span id="more"></span>

<h3 id="1-滚动数组"><a href="#1-滚动数组" class="headerlink" title="(1)滚动数组"></a>(1)滚动数组</h3><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//sum:f(n) a:f(n-2) b:f(n-1)</span></span><br><span class="line">            sum = (a+b)%<span class="number">100000007</span>;      <span class="comment">//执行n-1次</span></span><br><span class="line">            a = b;</span><br><span class="line">            b =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b =c;</span><br><span class="line">            c =sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum=<span class="number">0</span>; <span class="comment">//0阶当作1</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b; </span><br><span class="line">            b = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="746-使用最小花费爬楼梯🀄️"><a href="#746-使用最小花费爬楼梯🀄️" class="headerlink" title="746. 使用最小花费爬楼梯🀄️"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211022223803669.png" alt="image-20211022223803669"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;    <span class="comment">//第0，1阶都可以作为起始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="built_in">min</span>(a+cost[i<span class="number">-2</span>],b+cost[i<span class="number">-1</span>]);<span class="comment">//向上爬一个阶梯或者爬两个阶梯</span></span><br><span class="line">            a = b;</span><br><span class="line">            b = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-打家劫舍系列🀄️"><a href="#2-打家劫舍系列🀄️" class="headerlink" title="(2)打家劫舍系列🀄️"></a>(2)打家劫舍系列🀄️</h3><h5 id="198-打家劫舍🀄️"><a href="#198-打家劫舍🀄️" class="headerlink" title="198. 打家劫舍🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="213-打家劫舍-II🀄️"><a href="#213-打家劫舍-II🀄️" class="headerlink" title="213. 打家劫舍 II🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房子围成一圈</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(),nums.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums2</span><span class="params">(nums.begin()+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">work</span>(nums1),<span class="built_in">work</span>(nums2));<span class="comment">//1.抢头，不抢尾 2.不抢头，抢尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="337-打家劫舍-III🀄️"><a href="#337-打家劫舍-III🀄️" class="headerlink" title="337. 打家劫舍 III🀄️"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一棵二叉树</span></span><br><span class="line"><span class="comment">T,S:O(n)</span></span><br><span class="line"><span class="comment">动态规划：</span></span><br><span class="line"><span class="comment">我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 下标0 代表不偷，1 代表偷</span></span><br><span class="line"><span class="comment">任何一个节点能偷到的最大钱的状态可以定义为</span></span><br><span class="line"><span class="comment">    当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</span></span><br><span class="line"><span class="comment">    当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;   </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; l=<span class="built_in">dp</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; r=<span class="built_in">dp</span>(root-&gt;right);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="built_in">max</span>(l[<span class="number">0</span>],l[<span class="number">1</span>])+<span class="built_in">max</span>(r[<span class="number">0</span>],r[<span class="number">1</span>]);<span class="comment">//不抢</span></span><br><span class="line">        res[<span class="number">1</span>] = l[<span class="number">0</span>]+r[<span class="number">0</span>]+root-&gt;val;<span class="comment">//抢</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res= <span class="built_in">dp</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数"></a><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,cur=<span class="number">0</span>,res=<span class="number">0</span>;  <span class="comment">//cur 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;<span class="comment">//dp[k] = max(dp[k-1],num[i]+dp[k-2]) 偷前k-1个，或者 偷前k-2个和最后一个</span></span><br><span class="line">            res = <span class="built_in">max</span>(cur,prev+it);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) maxVal = <span class="built_in">max</span>(val,maxVal);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(maxVal+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:nums) sum[val] += val; <span class="comment">//按顺序存,统计所有相同元素之和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rob</span>(sum);</span><br><span class="line">        <span class="comment">//若选择了x，则可以获取 sum[x] 的点数，且无法再选择 x−1和 x+1，这与打家劫舍一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-股票系列"><a href="#3-股票系列" class="headerlink" title="(3)股票系列"></a>(3)股票系列</h3><h4 id="121-买卖股票的最佳时机🀄️"><a href="#121-买卖股票的最佳时机🀄️" class="headerlink" title="121. 买卖股票的最佳时机🀄️"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20211008224812645.png" alt="image-20211008224812645"></p>
<p><img src="/Users/zcz/Desktop/images/image-20211008225718378.png" alt="image-20211008225718378"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  - prices[i]);<span class="comment">//今天持股：1.今天什么都不做 2.今天买入（只允许1次，所以是第一次买入）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="122-买卖股票的最佳时机-II🀄️"><a href="#122-买卖股票的最佳时机-II🀄️" class="headerlink" title="122. 买卖股票的最佳时机 II🀄️"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以多次交易</span></span><br><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);<span class="comment">//今天不持股：1.今天什么都不做 2.昨天持股卖出，加上今天的价钱</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],  dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);	<span class="comment">//今天持股：1.昨天持股，今天什么都不做 2.昨天没有持股，今天买入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-最大子数组和系列"><a href="#4-最大子数组和系列" class="headerlink" title="(4)最大子数组和系列"></a>(4)最大子数组和系列</h3><h4 id="53-最大子序和🀄️"><a href="#53-最大子序和🀄️" class="headerlink" title="53. 最大子序和🀄️"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev=<span class="number">0</span>,res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            prev = <span class="built_in">max</span>(prev+it,it); <span class="comment">// f(i) = max(f(i-1)+nums[i],nums[i])</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,prev);    <span class="comment">// max&#123;f(n)&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//maxSum最大和 minSum最小和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum=nums[<span class="number">0</span>],minSum=nums[<span class="number">0</span>],pre1=<span class="number">0</span>,pre2=<span class="number">0</span>,arrSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            arrSum+=num;</span><br><span class="line">            pre1=num&gt;pre1+num?num:pre1+num;</span><br><span class="line">            maxSum=maxSum&gt;pre1?maxSum:pre1;</span><br><span class="line">          </span><br><span class="line">            pre2=num&lt;pre2+num?num:pre2+num;</span><br><span class="line">            minSum=minSum&lt;pre2?minSum:pre2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxSum&lt;<span class="number">0</span>)&#123;      <span class="comment">//第三种情况，全部负数</span></span><br><span class="line">            <span class="keyword">return</span> maxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第2种情况，在两端：arrSum-minSum；第一种情况：在中间maxSum,就跟53题一样</span></span><br><span class="line">        <span class="keyword">return</span> arrSum-minSum&gt;maxSum?arrSum-minSum:maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于第 i 个状态只和第 i−1个状态相关，根据「滚动数组」思想</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = maxF, mn = minF;</span><br><span class="line">            maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>(nums[i], mn * nums[i]));<span class="comment">//三种情况</span></span><br><span class="line">            minF = <span class="built_in">min</span>(mx * nums[i], <span class="built_in">min</span>(nums[i], mn * nums[i]));</span><br><span class="line">            res = <span class="built_in">max</span>(maxF, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1567-乘积为正数的最长子数组长度"><a href="#1567-乘积为正数的最长子数组长度" class="headerlink" title="1567. 乘积为正数的最长子数组长度"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">1567. 乘积为正数的最长子数组长度</a></h4><p><img src="/2021/01/02/6.DP/image-20211006235824952.png" alt="image-20211006235824952"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> positive = (nums[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> negative = (nums[<span class="number">0</span>] &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLength = positive;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;  <span class="comment">//不变</span></span><br><span class="line">                ++positive;</span><br><span class="line">                negative = (negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">//全部取反</span></span><br><span class="line">                <span class="keyword">int</span> newPositive = negative &gt; <span class="number">0</span> ? negative + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> newNegative = positive + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">tie</span>(positive, negative) = &#123;newPositive, newNegative&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                positive = negative = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, positive);  <span class="comment">//乘积为正数的最长子数组长度</span></span><br><span class="line">            <span class="comment">//maxLength = max(maxLength, negative);//乘积为负数的最长子数组长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mx = values[<span class="number">0</span>] + <span class="number">0</span>;    <span class="comment">//mx = values[i] + i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; values.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mx + values[j] - j); <span class="comment">//values[j] - j是固定不变的</span></span><br><span class="line">            <span class="comment">// 边遍历边维护</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, values[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-单串-LIS-系列🀄️"><a href="#5-单串-LIS-系列🀄️" class="headerlink" title="(5)单串 LIS 系列🀄️"></a>(5)单串 LIS 系列🀄️</h3><h5 id="300-最长递增子序列🀄️"><a href="#300-最长递增子序列🀄️" class="headerlink" title="300. 最长递增子序列🀄️"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210608210105555.png" alt="image-20210608210105555"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);<span class="comment">//没有减，所以下标为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());<span class="comment">//取里面最大的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心+二分</span></span><br><span class="line"><span class="comment">//T:O(nlogn) S:O(n)</span></span><br><span class="line"> <span class="comment">//如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">//d数组单调递增</span></span><br><span class="line">        d[len] = nums[<span class="number">0</span>];           <span class="comment">//d[1] =nums[0]初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;   </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123; <span class="comment">//d数组的数尽可能小</span></span><br><span class="line">                d[++len] = nums[i]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">//所有的数不小于nums[i] ，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123; <span class="comment">//在d数组中寻找比nums[i]小的</span></span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="673-最长递增子序列的个数🀄️"><a href="#673-最长递增子序列的个数🀄️" class="headerlink" title="673. 最长递增子序列的个数🀄️"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a>🀄️</h5><p><img src="/2021/01/02/6.DP/image-20210611230159775.png" alt="image-20210611230159775"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)  S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">      	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;	</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(dp[j]+<span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                      	dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])<span class="comment">//长度一样的</span></span><br><span class="line">                    	cnt[i] += cnt[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">int</span> max_length = *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">      	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == max_length)</span><br><span class="line">          	    res +=cnt[i]; </span><br><span class="line">        <span class="keyword">return</span> res;	</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//贪心 + 前缀和 + 二分查找   T:O(nlogn) S:O(n)</span></span><br></pre></td></tr></table></figure>

<h5 id="354-俄罗斯套娃信封问题🀄️"><a href="#354-俄罗斯套娃信封问题🀄️" class="headerlink" title="354. 俄罗斯套娃信封问题🀄️"></a><a href="https://leetcode-cn.com/problems/russian-doll-es/">354. 俄罗斯套娃信封问题</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 因为我们在找第 i 件物品的前一件物品时，会对前面的 i - 1 件物品都遍历一遍，因此第二维（高度）排序与否都不影响</span></span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;	<span class="comment">//找下界</span></span><br><span class="line">                <span class="keyword">if</span> (es[j][<span class="number">1</span>] &lt; es[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法2:二分+动态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = es.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(es.<span class="built_in">begin</span>(), es.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;es[<span class="number">0</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> num = es[i][<span class="number">1</span>]; num &gt; dp.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), num);</span><br><span class="line">                *it = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-贪心数组"><a href="#6-贪心数组" class="headerlink" title="(6)贪心数组"></a>(6)贪心数组</h3><h5 id="55-跳跃游戏🀄️"><a href="#55-跳跃游戏🀄️" class="headerlink" title="55. 跳跃游戏🀄️"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;  <span class="comment">//实时维护 最远可以到达的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;   <span class="comment">// x+nums[x]≥y, x本身可以到达</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);    </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="45-跳跃游戏-II🀄️"><a href="#45-跳跃游戏-II🀄️" class="headerlink" title="45. 跳跃游戏 II🀄️"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>🀄️</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</span></span><br><span class="line"><span class="comment">在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123; <span class="comment">//当前i可以到达r</span></span><br><span class="line">                    end = r;	<span class="comment">//更新边界</span></span><br><span class="line">                    ++step;<span class="comment">//每过一个边界+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-带维度单串-dp-i-k"><a href="#7-带维度单串-dp-i-k" class="headerlink" title="(7)带维度单串 dp[i] [k]"></a>(7)带维度单串 dp[i] [k]</h3><h4 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="1478-安排邮筒"><a href="#1478-安排邮筒" class="headerlink" title="1478. 安排邮筒"></a><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">1478. 安排邮筒</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数，前缀和维护状态转移时的查询</span><br></pre></td></tr></table></figure>



<h4 id="1230-抛掷硬币"><a href="#1230-抛掷硬币" class="headerlink" title="1230. 抛掷硬币"></a><a href="https://leetcode-cn.com/problems/toss-strange-coins/">1230. 抛掷硬币</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//—— k 是个数</span><br></pre></td></tr></table></figure>



<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是份数</span></span><br></pre></td></tr></table></figure>

<h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是次数，k 上有二分</span></span><br></pre></td></tr></table></figure>

<h4 id="975-奇偶跳"><a href="#975-奇偶跳" class="headerlink" title="975. 奇偶跳"></a><a href="https://leetcode-cn.com/problems/odd-even-jump/">975. 奇偶跳</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示当前的奇偶状态</span></span><br></pre></td></tr></table></figure>



<h4 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 表示上一步的跳的步数</span></span><br></pre></td></tr></table></figure>

<h4 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256. 粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">256. 粉刷房子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// —— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265. 粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">265. 粉刷房子 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— k 是颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//—— 有两个指标 k 颜色；t 街区数</span></span><br></pre></td></tr></table></figure>

<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2)</span></span><br><span class="line"><span class="comment">/*暴力 O(n^3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	for(n)</span></span><br><span class="line"><span class="comment">		for(n)&#123;</span></span><br><span class="line"><span class="comment">			isVaild(n)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">//()()相邻匹配，</span></span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">// ()(()) 2:自身   dp[i - dp[i - 1] - 2]：外部  dp[i-1]：内部</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211019170438187.png" alt="image-20211019170438187"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n));  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;       <span class="comment">//每个字符的最大长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-双串"><a href="#8-双串" class="headerlink" title="(8)双串"></a><strong>(8)双串</strong></h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p><img src="/2021/01/02/6.DP/image-20211009202901971.png" alt="image-20211009202901971"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp"><a href="#712-两个字符串的最小ASCII删除和-——-LCS，len-和-ascii-各一个-dp" class="headerlink" title="712. 两个字符串的最小ASCII删除和 —— LCS，len 和 ascii 各一个 dp"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a> —— LCS，len 和 ascii 各一个 dp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别</p>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1923-最长公共子路径-718题的扩展"><a href="#1923-最长公共子路径-718题的扩展" class="headerlink" title="1923. 最长公共子路径 718题的扩展"></a><a href="https://leetcode-cn.com/problems/longest-common-subpath/">1923. 最长公共子路径</a> 718题的扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双串问题：字符串匹配系列"><a href="#双串问题：字符串匹配系列" class="headerlink" title="双串问题：字符串匹配系列"></a>双串问题：字符串匹配系列</h3><h4 id="72"><a href="#72" class="headerlink" title="[72. )"></a>[72. )</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通配符匹配</li>
</ul>
<h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h4><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双串问题：其它双串-dp-i-j-问题"><a href="#双串问题：其它双串-dp-i-j-问题" class="headerlink" title="双串问题：其它双串 dp[i] [j] 问题"></a>双串问题：其它双串 dp[i] [j] 问题</h3><ul>
<li>交错字符串</li>
<li>不同的子序列</li>
</ul>
<h3 id="双串问题：带维度双串-dp-i-j-k"><a href="#双串问题：带维度双串-dp-i-j-k" class="headerlink" title="双串问题：带维度双串 dp[i] [j] [k]"></a>双串问题：带维度双串 dp[i] [j] [k]</h3><ul>
<li>扰乱字符串</li>
</ul>
<h3 id="9-矩阵"><a href="#9-矩阵" class="headerlink" title="(9)矩阵"></a><strong>(9)矩阵</strong></h3><p>矩阵 dp[i] [j]</p>
<ul>
<li>三角形最小路径和</li>
<li>最小路径和</li>
<li>地下城游戏</li>
<li>下降路径最小和</li>
<li>最大正方形</li>
<li>下降路径最小和  II</li>
</ul>
<p>矩阵 dp[i] [j] [k]</p>
<p>最大矩形</p>
<ul>
<li>矩形区域不超过 K 的最大数值和 —— k 为宽度</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移</li>
</ul>
<p>无串线性问题</p>
<ul>
<li>只有两个键的键盘</li>
<li>丑数 II</li>
<li>完全平方数</li>
<li>整数拆分</li>
</ul>
<h3 id="10-前缀和-区间求和、子矩形求和"><a href="#10-前缀和-区间求和、子矩形求和" class="headerlink" title="(10)前缀和(区间求和、子矩形求和)"></a>(10)前缀和(区间求和、子矩形求和)</h3><p><strong>求区间和</strong></p>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></p>
<p><strong>实现前缀和问题</strong></p>
<ul>
<li>区域和检索 - 数组不可变</li>
<li>二维区域和检索 - 矩阵不可变</li>
</ul>
<p><strong>数据结构维护前缀和</strong></p>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p>
<p>数据结构维护前缀和问题：HashMap 维护（1）<br>HashMap 维护（1），键是前缀和（状态）的值，值为第一次出现时的索引。</p>
<ul>
<li>和等于 k 的最长子数组长度</li>
<li>连续数组</li>
<li>每个元音包含偶数次的最长子字符串 —— 前缀状态为 a,e,i,o,u 的个数的奇偶</li>
</ul>
<p>HashMap 维护（2），键是前缀和（前缀状态）的值，值为出现次数。</p>
<ul>
<li>和为 K 的子数组</li>
<li>统计优美子数组 —— 前缀状态为奇数的个数</li>
</ul>
<p>HashMap 维护（3），键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）。</p>
<ul>
<li>连续的子数组和 —— 值为第一次出现时的索引</li>
<li>和可被 K 整除的子数组 —— 值为出现次</li>
</ul>
<p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，例如下面这几道题。</p>
<ul>
<li>除自身以外数组的乘积</li>
<li>寻找数组的中心索引</li>
<li>找两个和为目标值且不重叠的子数组 —— 前缀和后缀和分别推一次，推的时候保存信息（DP），枚举分割点</li>
</ul>
<p>二维前缀和</p>
<ul>
<li>元素和为目标值的子矩阵数量</li>
<li>矩阵区域和</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K</li>
</ul>
<p>前缀积</p>
<ul>
<li>乘积最大子数组</li>
<li>乘积小于K的子数组</li>
<li>最后 K 个数的乘积 —— 若乘法的前缀积会溢出，可以用对数的前缀和防溢出，但是结果转回整数需要用四舍五入而不是下取整</li>
</ul>
<p>前缀异或</p>
<ul>
<li>子数组异或查询</li>
<li>形成两个异或相等数组的三元组数目 —— 哈希表维护前缀异或结果，类似 「560. 和为 K 的子数组」</li>
</ul>
<p>差分问题</p>
<ul>
<li>区间加法 —— 用差分维护区间加法模板</li>
</ul>
<h1 id="6-DP-二"><a href="#6-DP-二" class="headerlink" title="6.DP(二)"></a>6.DP(二)</h1><h2 id="1-背包DP"><a href="#1-背包DP" class="headerlink" title="(1)背包DP"></a><strong>(1)背包</strong>DP</h2><blockquote>
<p>背包问题是一种组合优化的 NP 完全问题：有 <em>N</em> 个物品和容量为<em>V</em> 的背包，每个物品都有自己的体积 v 和价值 w，求拿哪些物品可以使得背包所装下物品的总价值最大。<br>如果限定每种物品只能选择 0 个或 1 个，则问题称为 <u>0-1 背包问题</u>；<br>如果不限定每种物品的数量，则问题称为无界背包问题或<u>完全背包问题</u>。<br>如果每种物品的数量不一样，则问题称为<u>多重背包问题</u>。<br>如果每组有多种物品，每组只能选择1种，则问题称为<u>分组背包问题</u>。</p>
</blockquote>
<!--more-->

<p><strong>背包问题的分析步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析是否为背包问题。</span><br><span class="line">1)是背包问题三种问法中的哪一种。</span><br><span class="line">2)0-1 背包问题还是完全背包问题，即求最值。</span><br><span class="line">也就是题目给的 nums 数组中的元素是否可以重复使用。</span><br><span class="line">3)如果是组合问题，即求方案数，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法，需要注意。</span><br></pre></td></tr></table></figure>

<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html">背包问题总结篇</a></p>
<p><img src="/2021/01/02/6.DP/20210117171307407.png" alt="416.分割等和子集1"></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="/2021/01/02/6.DP/image-20210330110645464.png" alt="image-20210330110645464"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="keyword">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], 前i个物品且体积&lt;=j时的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">             <span class="comment">// 能装，需要决策选与不选第 i 个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01背包</span></span><br><span class="line"><span class="comment">版本2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];	<span class="comment">// 体积,价值</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//先遍历物品，再遍历背包</span></span><br><span class="line">      <span class="comment">//如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙保证物品i只被放入一次，防止dp[i]加上计算过的dp[i-1]</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么一维情况下枚举背包容量需要逆序？</span></span><br><span class="line"><span class="comment">一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包问题理论基础二维dp数组</a></p>
<p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包问题理论基础一维dp数组（滚动数组）</a></p>
<h4 id="416-分割等和子集🀄️"><a href="#416-分割等和子集🀄️" class="headerlink" title="416. 分割等和子集🀄️"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1)dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123; </span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<span class="comment">//(2)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有两个维度的01背包</span></span><br><span class="line"><span class="comment">//(1)dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// (3)默认初始化0</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// (4)遍历物品</span></span><br><span class="line">            <span class="keyword">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeroNum; i--) &#123; <span class="comment">// 遍历背包容量且从后向前遍历！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>###完全背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:朴素做法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k*v[i]&lt;=j ; k++)	<span class="comment">//体积最大j</span></span><br><span class="line">              f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/02/6.DP/image-20210330125318496.png" alt="image-20210330125318496"></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完全背包:优化</span></span><br><span class="line"><span class="comment">先遍历物品，后遍历背包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i] ; j&lt;=m ;j++) <span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">              f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换🀄️"><a href="#322-零钱兑换🀄️" class="headerlink" title="322. 零钱兑换🀄️"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题 T:O(amount*coins)  S:O(amount)   amount:总金额，coins为硬币数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;    <span class="comment">//dp[i]代表金额i所需最少的硬币个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;                          <span class="comment">//金额0所需要的0个硬币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=amount;i++)&#123;	<span class="comment">//⚠️先遍历金额</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;<span class="comment">//注意了，正向遍历，和01背包不一样</span></span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)&#123;  <span class="comment">//当前金额i必须&gt;=j，才可以兑换</span></span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II🀄️"><a href="#518-零钱兑换-II🀄️" class="headerlink" title="518. 零钱兑换 II🀄️"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a>🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案问题 T:O(amount*coins)  S:O(amount)   amount:总金额(背包)，coins为硬币数</span></span><br><span class="line"><span class="comment">//同原始 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;   <span class="comment">//dp[i]代表金额i的方案数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;                    <span class="comment">//金额0所需要的0个硬币,1个方案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;     <span class="comment">//⚠️先遍历面额，这样内循环遍历的金额都是按顺序的，不会重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin ; i&lt;=amount;i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><p><img src="/2021/01/02/6.DP/image-20211022230148139.png" alt="image-20211022230148139"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最值问题  T:O(n∗sqrt(n))</span></span><br><span class="line"><span class="comment">//(1)dp[i]代表i用最少的平方数的个数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">// (3)默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;         <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;  <span class="comment">// (4)顺序遍历</span></span><br><span class="line">                dp[i] =<span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// (2)动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><p><img src="/2021/01/02/6.DP/image-20211022221506617.png" alt="image-20211022221506617"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n^2) S:O(n)</span></span><br><span class="line"><span class="comment">//单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="comment">//拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123; <span class="comment">//哈希表</span></span><br><span class="line">            dict.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i]表示字符串 s 前 i 个字符组成的字符串 s[0..i−1]是否能被空格拆分成若干个字典中出现的单词</span></span><br><span class="line">        vector &lt;<span class="keyword">bool</span>&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 前i个字符串[0..j-1] 子串：[j,i]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方案数问题	T:O(targer*n) S:O(targer)</span></span><br><span class="line"><span class="comment">//（1）用 dp[i]表示选取的元素之和等于 i 的方案数</span></span><br><span class="line"><span class="comment">//nums数组就是物品，target就是背包，数字能否组成targer，就是问物品能不能把背包装满。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]) &#123;</span><br><span class="line">                    dp[i] += dp[i - num];<span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="进阶爬楼梯"><a href="#进阶爬楼梯" class="headerlink" title="进阶爬楼梯"></a>进阶爬楼梯</h4><p><strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html">动态规划：关于多重背包，你该了解这些！</a></p>
<p><a href="https://www.acwing.com/problem/content/description/4/">4.多重背包问题 I</a></p>
<blockquote>
<p>一个基本思路是，将此问题转换为01背包求解！</p>
<p>比如物品1有3件，每件价值为2，我们不妨创建3个物品1，存在数组v和数组w中</p>
<p>最终更新一下总物品数n即可，然后套用01背包问题进行求解。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">朴素版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,n,m,dp[<span class="number">10005</span>]=&#123; &#125;,w,v,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s--)</span><br><span class="line">    &#123;a[++t]=v;</span><br><span class="line">    b[t]=w;&#125;<span class="comment">//死拆，把多重背包拆成01背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a[i];j--)</span><br><span class="line">    dp[j]=<span class="built_in">max</span>(dp[j-a[i]]+b[i],dp[j]);<span class="comment">//直接套01背包的板子</span></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优化版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1005</span>],n,m,v,w,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v;j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.acwing.com/problem/content/5/">5. 多重背包问题 II</a></p>
<p><img src="/2021/01/02/6.DP/006eb5E0gy1g7z0e5ghloj31150fw0ub.png" alt="image.png"></p>
<p>思路和多重背包问题I一样，但这题的数据范围变成1000了，非优化写法时间复杂度O(n^3) 接近 1e9</p>
<p>必超时。</p>
<p><img src="/2021/01/02/6.DP/image-20210330214658423.png" alt="image-20210330214658423"></p>
<p><img src="/2021/01/02/6.DP/image-20210330214742786.png" alt="image-20210330214742786"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N],n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;good&gt; Good;</span><br><span class="line">    good tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="comment">//坑,k &lt;= s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= s ; k*=<span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            Good.<span class="built_in">push_back</span>(&#123;k*w,k*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) Good.<span class="built_in">push_back</span>(&#123;s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包优化+二进制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : Good)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= t.v ; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j] , dp[j-t.v]+t.w ); <span class="comment">//这里就是dp[j]</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/problem/content/6/">6. 多重背包问题 III</a></p>
<p><strong>(单调队列优化) O(NV)</strong></p>
<p>一共 n 类物品，背包的容量是 m</p>
<p>每类物品的体积为v, 价值为w，个数为s</p>
<p>我们先来回顾一下传统的dp方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(不放入物品 i，放入<span class="number">1</span>个物品 i，放入<span class="number">2</span>个物品 i, ... , 放入k个物品 i)</span><br><span class="line">这里 k 要满足：k &lt;= s, j - k*v &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">不放物品  i = dp[i<span class="number">-1</span>][j]</span><br><span class="line">放k个物品 i = dp[i<span class="number">-1</span>][j - k*v] + k*w</span><br><span class="line"></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v] + w, dp[i<span class="number">-1</span>][j<span class="number">-2</span>*v] + <span class="number">2</span>*w,..., dp[i<span class="number">-1</span>][j-k*v] + k*w)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">实际上我们并不需要二维的dp数组，适当的调整循环条件，我们可以重复利用dp数组来保存上一轮的信息</span><br><span class="line"></span><br><span class="line">我们令 dp[j] 表示容量为j的情况下，获得的最大价值</span><br><span class="line">那么，针对每一类物品 i ，我们都更新一下 dp[m] --&gt; dp[<span class="number">0</span>] 的值，最后 dp[m] 就是一个全局最优值</span><br><span class="line"></span><br><span class="line">dp[m] = <span class="built_in">max</span>(dp[m], dp[m-v] + w, dp[m<span class="number">-2</span>*v] + <span class="number">2</span>*w, dp[m<span class="number">-3</span>*v] + <span class="number">3</span>*w, ...)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">显而易见，m 一定等于 k*v + j，其中  <span class="number">0</span> &lt;= j &lt; v</span><br><span class="line">所以，我们可以把 dp 数组分成 j 个类，每一类中的值，都是在同类之间转换得到的</span><br><span class="line">也就是说，dp[k*v+j] 只依赖于 &#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125;</span><br><span class="line"></span><br><span class="line">因为我们需要的是&#123; dp[j], dp[v+j], dp[<span class="number">2</span>*v+j], dp[<span class="number">3</span>*v+j], ... , dp[k*v+j] &#125; 中的最大值，</span><br><span class="line">可以通过维护一个单调队列来得到结果。这样的话，问题就变成了 j 个单调队列的问题</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">所以，我们可以得到</span><br><span class="line">dp[j]    =     dp[j]</span><br><span class="line">dp[j+v]  = <span class="built_in">max</span>(dp[j] +  w,  dp[j+v])</span><br><span class="line">dp[j+<span class="number">2</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">2</span>w,  dp[j+v] +  w, dp[j+<span class="number">2</span>v])</span><br><span class="line">dp[j+<span class="number">3</span>v] = <span class="built_in">max</span>(dp[j] + <span class="number">3</span>w,  dp[j+v] + <span class="number">2</span>w, dp[j+<span class="number">2</span>v] + w, dp[j+<span class="number">3</span>v])</span><br><span class="line">...</span><br><span class="line">但是，这个队列中前面的数，每次都会增加一个 w ，所以我们需要做一些转换</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">单调队列问题，最重要的两点</span><br><span class="line"><span class="number">1</span>）维护队列元素的个数，如果不能继续入队，弹出队头元素</span><br><span class="line"><span class="number">2</span>）维护队列的单调性，即：尾值 &gt;= dp[j + k*v] - k*w</span><br><span class="line"></span><br><span class="line">本题中，队列中元素的个数应该为 s+<span class="number">1</span> 个，即 <span class="number">0</span> -- s 个物品 i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], pre[N], q[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= m; k += v) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - s*v &gt; q[head])</span><br><span class="line">                    ++head;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] - (q[tail] - j)/v * w &lt;= pre[k] - (k - j)/v * w)</span><br><span class="line">                    --tail;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head])/v * w);</span><br><span class="line"></span><br><span class="line">                q[++tail] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><a href="https://www.acwing.com/problem/content/9/">9. 分组背包问题</a></p>
<p><img src="/2021/01/02/6.DP/image-20210330215834022.png" alt="image-20210330215834022"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];  <span class="comment">//只从前i组物品中选，当前体积小于等于j的最大值</span></span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];   <span class="comment">//v为体积，w为价值，s代表第i组物品的个数</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123; <span class="comment">//第i组的第k个物品</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一维优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;    <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最值问题</strong></p>
<ul>
<li>零钱兑换（完全背包）</li>
<li>一和零（二维费用背包）</li>
<li>最后一块石头的重量 II —— 转换为01背包问题，使得背包剩余容量最小</li>
</ul>
<p>这道题是要求<strong>恰好取到背包容量</strong>的背包问题。</p>
<ul>
<li>分割等和子集（01 背包 - 要求恰好取到背包容量）</li>
</ul>
<p><strong>方案数问题</strong></p>
<p>这四道题是背包问题求方案数的题目，涉及到 01背包，完全背包的方案数问题。以及考虑顺序和不考虑顺序的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组合总和 Ⅳ —— 顺序不同的序列被视作不同的组合</span><br><span class="line">目标和 —— 01背包-求方案数</span><br><span class="line">零钱兑换 II —— 完全背包-求方案数</span><br><span class="line">盈利计划 —— 01背包-求方案数总价值有要求：有下限</span><br></pre></td></tr></table></figure>

<h2 id="2-状态压缩DP"><a href="#2-状态压缩DP" class="headerlink" title="(2)状态压缩DP"></a>(2)状态压缩DP</h2><p>安卓系统手势解锁<br>我能赢吗<br>不同路径 III —— 状态压缩 DP + 记忆化<br>划分为 k 个相等的子集 —— 状态压缩 DP + 记忆化<br>访问所有节点的最短路径 —— Floyd + 状态压缩 DP 求最短哈密顿路<br>最短超级串 —— 状态压缩 DP + DP 过程记录路径<br>优美的排列<br>骑士拨号器<br>参加考试的最大学生数<br>大礼包<br>贴纸拼词<br>按位与为零的三元组</p>
<h2 id="3-树形DP"><a href="#3-树形DP" class="headerlink" title="(3)树形DP"></a>(3)树形DP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-区间DP"><a href="#4-区间DP" class="headerlink" title="(4)区间DP"></a>(4)区间DP</h2><p><strong>回文相关问题</strong></p>
<ul>
<li>最长回文子串</li>
<li>回文子串</li>
<li>最长回文子序列</li>
<li>段式回文</li>
<li>统计不同回文子字符串</li>
<li>让字符串成为回文串的最少插入次数 —— 最长回文子序列</li>
</ul>
<p><strong>区间动态规划其它问题</strong></p>
<p>戳气球<br>移除盒子 —— 戳气球升级版，[i][j] 基础上加了一维 k 状态，k 是 j 右侧与 j 相同的元素个数, 记忆化<br>多边形三角剖分的最低得分<br>奇怪的打印机<br>合并石头的最低成本<br>预测赢家<br>编码最短长度的字符串</p>
<h2 id="5-计数DP"><a href="#5-计数DP" class="headerlink" title="(5)计数DP"></a>(5)计数DP</h2><p><a href="https://leetcode-cn.com/problems/unique-paths">62. 不同路径</a></p>
<p><a href="https://leetcode-cn.com/problems/paint-fence/">276. 栅栏涂色</a></p>
<p><strong>计数问题相关练习题</strong></p>
<ol>
<li>路径问题</li>
<li>卡特兰数</li>
<li>铺砖问题</li>
<li>斐波那契</li>
<li>隐晦的递推关系</li>
</ol>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></p>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p>
<h2 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="(6)数位DP"></a>(6)数位DP</h2><p><a href="https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p>
<p>以下 9 道题是力扣上数位 DP 相关的题目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满足某些条件的数字个数</span><br><span class="line">    最大为 N 的数字组合</span><br><span class="line">    中心对称数 III</span><br><span class="line">    计算各个位数不同的数字个数</span><br><span class="line">    不含连续 1 的非负整数</span><br><span class="line">    至少有 1 位重复的数字</span><br><span class="line">    易混淆数 II</span><br><span class="line"></span><br><span class="line">将 x∈[L,R]x \in [L, R]x∈[L,R] 代到一个函数 f(x) 中, 一个数字 x 的 f(x) 值为一次贡献的量, 求总的贡献</span><br><span class="line">    数字 1 的个数</span><br><span class="line">    范围内的数字计数</span><br><span class="line">    2 出现的次数</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-10-II-青蛙跳台阶问题🀄️"><a href="#剑指-Offer-10-II-青蛙跳台阶问题🀄️" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题🀄️"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🀄️</h4><p><img src="/2021/01/02/6.DP/image-20210813162608191.png" alt="image-20210813162608191"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162640327.png" alt="image-20210813162640327"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(x,pre+x);	<span class="comment">//⚠️当前x 或者 x加上之前</span></span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-46-把数字翻译成字符串-🀄️"><a href="#剑指-Offer-46-把数字翻译成字符串-🀄️" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串 🀄️"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a> 🀄️</h4><p><img src="/Users/zcz/Desktop/images/image-20210812100300618.png" alt="image-20210812100300618"></p>
<p><img src="/2021/01/02/6.DP/image-20210812101125269.png" alt="image-20210812101125269"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T：O(n)</span></span><br><span class="line"><span class="comment">//S：用了滚动数组O(1)，但是这里用了一个临时变量把数字转化成了字符串，故渐进空间复杂度也是 O(log⁡n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            p =q;</span><br><span class="line">            q =r;</span><br><span class="line">            r =<span class="number">0</span>;</span><br><span class="line">            r += q; <span class="comment">//f(i-1)贡献</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String pre = str.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);    <span class="comment">//取i-1到i的子串</span></span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">                r+=p;   <span class="comment">//f(i-2)贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p><img src="/Users/zcz/Desktop/images/image-20210812101713646.png" alt="image-20210812101713646"></p>
<p><img src="/2021/01/02/6.DP/image-20210812102323894.png" alt="image-20210812102323894"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(MN)</span></span><br><span class="line"><span class="comment">//S:O(1) grid作为dp使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length; <span class="comment">//m行，n列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];              <span class="comment">//从左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];           <span class="comment">//从上</span></span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);<span class="comment">//从上或从左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设动态规划列表dp ，dp[i]代表第 i+1 个丑数；（下标从0开始的）</span></span><br><span class="line"><span class="comment">//T:O(n)</span></span><br><span class="line"><span class="comment">//S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=dp[a]*<span class="number">2</span>,n2=dp[b]*<span class="number">3</span>,n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(n1,Math.min(n2,n3));</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字-约瑟环"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-约瑟环" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 约瑟环"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> 约瑟环</h4><p><img src="/2021/01/02/6.DP/image-20210813162901260.png" alt="image-20210813162901260"></p>
<p><img src="/2021/01/02/6.DP/image-20210813162843069.png" alt="image-20210813162843069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归 T:O(N) S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;		<span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上往下推</span></span><br><span class="line">        <span class="keyword">return</span> (m + f(n - <span class="number">1</span>, m)) % n;		<span class="comment">//下一个删除的数   等价关系式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态 T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;		<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f = (m + f) % i;	<span class="comment">//⚠️从下往上推，从2开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p><img src="/2021/01/02/6.DP/image-20210813162930157.png" alt="image-20210813162930157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);	<span class="comment">//min(prices[0:i])</span></span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-19-正则表达式匹配-困难"><a href="#剑指-Offer-19-正则表达式匹配-困难" class="headerlink" title="剑指 Offer 19. 正则表达式匹配  困难"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>  困难</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p><img src="/2021/01/02/6.DP/image-20210701155141042.png" alt="image-20210701155141042"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划+哈希</span></span><br><span class="line"><span class="comment">//由于返回值是取 dp列表最大值，因此可借助变量 tmp 存储 dp[j]</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>8.基础</title>
    <url>/2021/01/02/8.%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="8-基础"><a href="#8-基础" class="headerlink" title="8.基础"></a>8.基础</h1><span id="more"></span>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20210830173325392.png" alt="image-20210830173325392"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;	<span class="comment">//位数digit</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;		<span class="comment">//数位数量count</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.计算n所在的数位数量count  </span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;	<span class="comment">//（n:11  n=2 count=180 start=10 digit=2 num=10 ）</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.计算n所在的数字num </span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.确定 n 是num 中的哪一数位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摩尔投票法</span></span><br><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br></pre></td></tr></table></figure>



<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟、设定边界</span></span><br><span class="line"><span class="comment">//T:O(mn) S:O(mn)</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表格分区</span></span><br><span class="line"><span class="comment">//T:O(N)	S:O(1)</span></span><br></pre></td></tr></table></figure>

<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n) S:O(1)</span></span><br><span class="line"><span class="comment">//我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;    <span class="comment">//倒数第2个</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;  <span class="comment">//从后向前找，大于nums[i]</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;   <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;    <span class="comment">//最后一个</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<span class="comment">//从后向前找，大于nums[i]</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());  <span class="comment">//翻转后，(i+1,n)升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(log|x|)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || rev &gt; INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//越界</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365. 水壶问题"></a><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365. 水壶问题</a></h4><p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/image-20211215152432707.png" alt="image-20211215152432707"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(xy)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(z &gt; (x + y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Math.<span class="built_in">min</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> max = Math.<span class="built_in">max</span>(x, y);</span><br><span class="line"></span><br><span class="line">        boolean[] app = <span class="keyword">new</span> boolean[max];   <span class="comment">//记录是否出现一个周期，是则说明永远达不到目标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!app[remain])&#123;</span><br><span class="line">            app[remain] = <span class="literal">true</span>;</span><br><span class="line">            remain = (remain + min) % max;</span><br><span class="line">            <span class="keyword">if</span>(remain == z || remain + max == z) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="comment">//T:O(NlogN) ，最差为 O(N^2) 	S:O(N)</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//T:O(nlogn),S:O(n)</span><br><span class="line">//归并排序，加了个计数器</span><br><span class="line">//在第2个数组元素归并上去时，计数，计数后的元素不再计算</span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表-1"><a href="#25-K-个一组翻转链表-1" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//快排  T：O(n) S:O(logn)</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求<strong>O(1)空间</strong>和O(n)时间。</p>
</blockquote>
<p><img src="/2021/01/02/8.%E5%9F%BA%E7%A1%80/2-9657443.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GOOGLE面试题  </span></span><br><span class="line"><span class="comment">//一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求O(1)空间和O(n)时间。  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NO_REPEAT_FLAG = <span class="number">-1</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t = x;  </span><br><span class="line">    x = y;  </span><br><span class="line">    y = t;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//类似于基数排序，找出数组中第一个重复元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  &#123;  </span><br><span class="line">        <span class="keyword">while</span> (i != a[i])  &#123;  </span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[a[i]])  <span class="keyword">return</span> a[i];  <span class="comment">//重复</span></span><br><span class="line">            <span class="built_in">Swap</span>(a[i], a[a[i]]);  <span class="comment">//不等,交换</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> NO_REPEAT_FLAG;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);  </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">int</span> a[MAXN] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>,  <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">    <span class="comment">//int a[MAXN] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组为: \n&quot;</span>);  </span><br><span class="line">    <span class="built_in">PrintfArray</span>(a, MAXN);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> nRepeatNumber = <span class="built_in">RadixSort</span>(a, MAXN);  </span><br><span class="line">    <span class="keyword">if</span> (nRepeatNumber != NO_REPEAT_FLAG)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该数组有重复元素，此元素为%d\n&quot;</span>, nRepeatNumber);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该数组没有重复元素\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>7.数据结构</title>
    <url>/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="7-数据结构"><a href="#7-数据结构" class="headerlink" title="7. 数据结构"></a>7. 数据结构</h2><span id="more"></span>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的且比它大/小的数</span><br><span class="line"><span class="comment">/*如何确定是使用严格单调栈还是非严格单调栈？只要根据题意确定我们栈中是否可以存放相同元素即可。</span></span><br><span class="line"><span class="comment">参考：https://blog.csdn.net/qq_17550379/article/details/86519771</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;	<span class="comment">//往左边找 栈顶比当前i比较  top&lt;i,单调递减，top&gt;i单调递增</span></span><br><span class="line">    stk[ ++ tt] = i;		<span class="comment">//将i插入栈中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">830.单调栈</span></span><br><span class="line"><span class="comment">先用暴力破解，再其中挖掘某些特性，每次把没用删除掉，得到单调栈</span></span><br><span class="line"><span class="comment">样例</span></span><br><span class="line"><span class="comment">输入样例：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3 4 2 7 5</span></span><br><span class="line"><span class="comment">输出样例：</span></span><br><span class="line"><span class="comment">-1 3 -1 2 2</span></span><br><span class="line"><span class="comment">3左边没有 返回-1	4左边3，返回3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N],tt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(tt&amp;&amp;s[tt]&gt;=x)tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[tt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        s[++tt]=x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题1：比当前元素更大的下一个元素 <strong>单调递减栈</strong></p>
<h4 id="42-接雨水-🀄️"><a href="#42-接雨水-🀄️" class="headerlink" title="42.接雨水 🀄️"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water">42.接雨水</a> 🀄️</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">//单调递减栈，存储h的下标</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;h.<span class="built_in">size</span>())&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &gt; h[stk.<span class="built_in">top</span>()])&#123; <span class="comment">//当前i &gt; 栈顶，才进入</span></span><br><span class="line">                <span class="keyword">int</span> top = stk.<span class="built_in">top</span>(); </span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">//空，栈顶前没有元素了</span></span><br><span class="line">                <span class="keyword">int</span> dis = i-stk.<span class="built_in">top</span>()<span class="number">-1</span>;  <span class="comment">// 栈顶前1个 &gt; 栈顶 &lt; 当前i，形成低洼</span></span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(h[stk.<span class="built_in">top</span>()],h[i])-h[top];<span class="comment">//min(栈顶前1个高度，当前i高度)-栈顶高度</span></span><br><span class="line">                res += dis*height;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="496-下一个更大元素-I-🀄️"><a href="#496-下一个更大元素-I-🀄️" class="headerlink" title="496.下一个更大元素 I  🀄️"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i">496.下一个更大元素 I</a>  🀄️</h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210415195029992.png" alt="image-20210415195029992"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nums1和nums2中所有整数 互不相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;                 <span class="comment">//单调递减栈</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.<span class="built_in">size</span>();i++)&#123;    <span class="comment">//num2处理映射</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &lt; nums2[i])&#123;    <span class="comment">//当前i &gt; 栈顶，才进入</span></span><br><span class="line">                mymap[stk.<span class="built_in">top</span>()] = nums2[i];    <span class="comment">//之前都是递减的，处理映射</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(nums2[i]);   <span class="comment">//将i压栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123; <span class="comment">//将栈的所有元素弹出</span></span><br><span class="line">            mymap[stk.<span class="built_in">top</span>()] = <span class="number">-1</span>;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++) <span class="comment">//加入结果集</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(mymap[nums1[i]]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503.下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii">503.下一个更大元素 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*多了个循环查找*/</span></span><br><span class="line"><span class="comment">/*长度变了，stack存储是下标*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">//存储下标</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123; <span class="comment">//遍历大小size+size-1</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()] &lt; nums[i%n] )&#123;</span><br><span class="line">                res[stk.<span class="built_in">top</span>()] = nums[i%n];   <span class="comment">//栈顶对应位置，赋值大于栈顶的数</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i%n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures">739.每日温度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">栈存储的是下标</span></span><br><span class="line"><span class="comment">当前i的下标 &gt; 栈顶的下标， 距离=当前i的下标 - 出栈的元素的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(t.size(),<span class="number">0</span>)</span></span>;	<span class="comment">//初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; t[i] &gt; t[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                res[stk.<span class="built_in">top</span>()] = i-stk.<span class="built_in">top</span>();	<span class="comment">//求距离</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题2：比当前元素更大的前一个元素 <strong>单调递减栈</strong></p>
<h4 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901.股票价格跨度"></a><a href="https://leetcode-cn.com/problems/online-stock-span">901.股票价格跨度</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk,weights; <span class="comment">//stk存储price，</span></span><br><span class="line">  <span class="comment">//weights它离上一个价格之间（即最近的一个大于它的价格之间）的天数  100 80 60 75 (75：2)</span></span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; price &gt;= stk.<span class="built_in">top</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            w += weights.<span class="built_in">top</span>();</span><br><span class="line">            weights.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(price);</span><br><span class="line">        weights.<span class="built_in">push</span>(w);</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题3：比当前元素更小的下一个元素  <strong>递增单调栈</strong></p>
<h4 id="84柱状图中最大的矩形-好难🀄️"><a href="#84柱状图中最大的矩形-好难🀄️" class="headerlink" title="84柱状图中最大的矩形   好难🀄️"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">84柱状图中最大的矩形</a>   好难🀄️</h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210419215726759.png" alt="image-20210419215726759"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">超时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            <span class="keyword">int</span> minHeight = INT_MAX;</span><br><span class="line">            <span class="comment">// 枚举右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="comment">// 确定高度</span></span><br><span class="line">                minHeight = <span class="built_in">min</span>(minHeight, heights[right]);</span><br><span class="line">                <span class="comment">// 计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先我们枚举某一根柱子 i 作为高 h=heights[i]</span></span><br><span class="line"><span class="comment">随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。 h &lt;=  heights[stk.top()]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            l[i] = (stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>());</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = (stk.<span class="built_in">empty</span>() ? n : stk.<span class="built_in">top</span>());</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (r[i] - l[i] - <span class="number">1</span>) * h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题4：比当前元素更小的前一个元素</p>
<h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(n)  S:O(k)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">//队首最大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;   <span class="comment">//先生成1个k大小的窗口</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) &#123;<span class="comment">//严格单调递减</span></span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;nums[q.<span class="built_in">front</span>()]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">front</span>() &lt;= i - k) &#123;    <span class="comment">//维护当前窗口大小为k，将前面的删除掉</span></span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。</p>
</blockquote>
<h4 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></h4><h4 id="932-漂亮数组"><a href="#932-漂亮数组" class="headerlink" title="932. 漂亮数组"></a><a href="https://leetcode-cn.com/problems/beautiful-array/">932. 漂亮数组</a></h4><h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球</a></h4><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="堆-amp-amp-优先队列"><a href="#堆-amp-amp-优先队列" class="headerlink" title="堆&amp;&amp;优先队列"></a>堆&amp;&amp;优先队列</h3><h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;   <span class="comment">//删除的是头结点</span></span><br><span class="line">        ListNode pre = head, cur = head.next;   <span class="comment">//2个指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) pre.next = cur.next;    <span class="comment">//如果找到了，将当前结点删除</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode l=head,r=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;r = r.next;&#125;</span><br><span class="line">        <span class="keyword">while</span>(r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            r = r.next;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1) </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* pre=nullptr;</span><br><span class="line">        <span class="keyword">while</span>(cur != nullptr)&#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//当前指向之前</span></span><br><span class="line">            pre = cur;      <span class="comment">//更新之前</span></span><br><span class="line">            cur = tmp;      <span class="comment">//更新当前结点为下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针+头插法</span></span><br><span class="line"><span class="comment">//T:O(n)  S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">//虚假指针，解决头结点的问题</span></span><br><span class="line">        dummyNode-&gt;next = head; <span class="comment">//这样头结点就不会改了</span></span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;    <span class="comment">//先移动　left个</span></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = head;<span class="comment">//头结点，并临时cur</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;             <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1:l2;  <span class="comment">//哪个不为空直接指向它</span></span><br><span class="line">        <span class="keyword">return</span> head.next;       <span class="comment">//⚠️头结点没有存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力：for(k)&#123;两个两个合并&#125; T:O(k^2n) S:O(1)</span></span><br><span class="line"><span class="comment">//分治法：配对，k/2,k/4,k/8,... T:O(kn×logk) S:O(logk)</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针  完美偶遇</span></span><br><span class="line"><span class="comment">// T:O(M+N) S:O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode node1 =headA,node2=headB;</span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="keyword">null</span> ? node1.next : headB;<span class="comment">//循环遍历A，到null时，变为headB</span></span><br><span class="line">            node2 = node2 != <span class="keyword">null</span> ? node2.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2;<span class="comment">//返回node1也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-20-表示数值的字符串-中等"><a href="#剑指-Offer-20-表示数值的字符串-中等" class="headerlink" title="剑指 Offer 20. 表示数值的字符串  中等"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串 </a> 中等</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(M):M二进制1的个数 S：O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-16-数值的整数次方-快速幂"><a href="#剑指-Offer-16-数值的整数次方-快速幂" class="headerlink" title="剑指 Offer 16. 数值的整数次方 快速幂"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a> 快速幂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:O(logn) S:O(1)</span></span><br><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;	<span class="comment">//处理越界</span></span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;	<span class="comment">//处理负数</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;	</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x; <span class="comment">//n为奇数时</span></span><br><span class="line">            x *= x;		<span class="comment">//x^2</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;	<span class="comment">//算术右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组异或：(2,1,3,2)     其他2次，找2个</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//全员异或后得到这个只出现一次的数（本题需要找到2个）</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">//结果,0与任何数异或还是自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//找到第一位不是0的 是1</span></span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;	<span class="comment">//判断该位是否为0进行分组 （2，1，2）=&gt;1</span></span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//(3)</span></span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210830112644359.png" alt="image-20210830112644359"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 333 的倍数。</span></span><br><span class="line"><span class="comment">//因此，统计所有数字的各二进制位中 1 的出现次数，并对3求余，结果则为只出现一次的数字。</span></span><br><span class="line"><span class="comment">//其他3次，找1个   (1,0,1,1)</span></span><br><span class="line"><span class="comment">//有限状态自动机 T:O(n)  S:O(1)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;	<span class="comment">//二进制数的2个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算：x ^ 0 = x， x ^ 1 = ~x</span></span><br><span class="line"><span class="comment">// 与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和 </span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高低位交换"><a href="#高低位交换" class="headerlink" title="高低位交换"></a>高低位交换</h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211216203523340.png" alt="image-20211216203523340"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高低位交换 by MoreWindows( http://blog.csdn.net/MoreWindows )    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfBinary</span><span class="params">(T a)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> i;  </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="built_in"><span class="keyword">sizeof</span></span>(a) * <span class="number">8</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)  </span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">if</span> ((a &gt;&gt; i) &amp; <span class="number">1</span>)  </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);  </span><br><span class="line">       <span class="keyword">else</span>   </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">8</span>)  </span><br><span class="line">           <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;高低位交换 --- by MoreWindows( http://blog.csdn.net/MoreWindows )  ---\n\n&quot;</span>);  </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前:    &quot;</span>);  </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">3344520</span>;  </span><br><span class="line">   <span class="built_in">PrintfBinary</span>(a);  </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后:    &quot;</span>);  </span><br><span class="line">   a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>);  	<span class="comment">//核心</span></span><br><span class="line">   <span class="built_in">PrintfBinary</span>(a);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T,S:O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != map.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;<span class="comment">//找到了，直接返回</span></span><br><span class="line">            map[nums[i]] = i;<span class="comment">//没有找到,插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序哈希表</span></span><br><span class="line"><span class="comment">//T:O(N) S:O(1)</span></span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;	<span class="comment">//初始为0	</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            res[it]++;</span><br><span class="line">            <span class="keyword">if</span>(res[it] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; us&#123; nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>() &#125;;<span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (us.<span class="built_in">find</span>(it) != us.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                us.<span class="built_in">erase</span>(it);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/350_fig1.gif" alt="fig1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">空间复杂度：O(min⁡(m,n))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*二分，数组有序*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;	<span class="comment">//从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;	<span class="comment">//下标+1 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*哈希*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="组合数据结构"><a href="#组合数据结构" class="headerlink" title="组合数据结构"></a>组合数据结构</h3><h4 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h4><p><img src="/2021/01/02/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b84cf65debb43b28bd212787ca63d34c9962696ed427f638763be71a3cb8f89d.png" alt="HashLinkedList"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map查找O（1）</span></span><br><span class="line"><span class="comment">//双向链表查找，删除O（1）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;  <span class="comment">//LU  最少使用</span></span><br><span class="line">    DLinkedNode* tail;  <span class="comment">//LRU 最近最少使用</span></span><br><span class="line">    <span class="keyword">int</span> size;	<span class="comment">//1.计数法</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="432-全-O-1-的数据结构"><a href="#432-全-O-1-的数据结构" class="headerlink" title="432. 全 O(1) 的数据结构"></a><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>0.绪论</title>
    <url>/2021/01/02/0.%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0.绪论"></a>0.绪论</h2><p><code>明确：考的不是智商，是熟练度。</code></p>
<p><img src="/2021/01/02/0.%E7%BB%AA%E8%AE%BA/image-20210226104343928.png" alt="image-20210226104343928"></p>
<ul>
<li>代码 </li>
<li><strong>背模型</strong></li>
<li>题目</li>
</ul>
<blockquote>
<p>算法知识点-1.干嘛的，什么时候用，原理是什么 2.积累题型。<strong>参考</strong>：<a href="https://www.bilibili.com/read/cv9904414">郭大神</a>，<a href="https://space.bilibili.com/7836741">Y总</a></p>
</blockquote>
<span id="more"></span>

<h4 id="我刷题总结的笔记"><a href="#我刷题总结的笔记" class="headerlink" title="我刷题总结的笔记"></a><a href="conclusion/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.xlsx">我刷题总结的笔记</a></h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
